use std::collections::HashSet;

use clap::Parser;
use indexmap::IndexMap;
use rustdoc_types::{Item, Crate, ItemEnum};
use serde::Deserialize;

use crate::WrapperType;

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
pub struct Args {

    /// Paths to json files generated by `rustdoc -p <crate> --output-format json`
    #[clap(short, long, value_parser)]
    pub json: Vec<String>,
    
    /// The path to toml config file which contains the types to be wrapped and overrides
    #[clap(short, long, value_parser)]
    pub config: String,

    /// if true the excluded methods will show up as commented out code with reasons for exclusion
    #[clap(long)]
    pub print_errors: bool
}

#[derive(Deserialize,Debug)]
pub struct Config {
    #[serde(skip_deserializing,default)]
    pub types : IndexMap<String,Newtype>,

    #[serde(rename="types")]
    pub types_ : Vec<Newtype>,

    pub imports : String,

    pub external_types : Vec<String>,

    pub primitives : HashSet<String>,
}




#[derive(Deserialize,Debug, Hash, PartialEq, Eq)]
pub struct Newtype {

    #[serde(rename="type")]
    pub type_ : String,

    /// Override type-level docstring 
    pub doc : Option<String>,

    #[serde(default)]
    pub source : Source,

    #[serde(default)]
    pub wrapper_type : WrapperType,

    #[serde(default)]
    pub lua_methods: Vec<String>,

    #[serde(default)]
    pub derive_flags: Vec<String>,

    #[serde(default)]
    pub import_path: String,

    #[serde(default)]
    pub traits : Vec<TraitMethods>
}

#[derive(Deserialize, Debug, PartialEq, Eq, Hash, Default)]
pub struct TraitMethods {
    pub name: String,
    pub import_path: String
}

#[derive(Deserialize,Debug, PartialEq, Eq, Hash)]
pub struct Source(pub String);

impl Default for Source {
    fn default() -> Self {
        Self("bevy".to_string())
    }
}

impl Newtype {
    /// Returns true if this Type:
    /// - describes the given item element
    /// - if the element is fully described in the source crate
    /// - if the element is a struct or enum
    pub fn matches_result(&self, item : &Item, source : &Crate) -> bool {
        
        match &item.inner {
            ItemEnum::Struct(_) => {},
            ItemEnum::Enum(_) => {},
            _ => return false
        };

        if source.external_crates.contains_key(&item.crate_id){
            return false
        };

        true
    }
}
