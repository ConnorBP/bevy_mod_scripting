use bevy_api_gen_lib::PrettyWriter;

use std::{io::{self, BufReader},fs::{File,read_to_string}, collections::{HashSet}};
use clap::Parser;
use indexmap::{IndexMap, IndexSet};
use serde_json::from_reader;
use rustdoc_types::{Crate, Item, ItemEnum, Id, Impl,Type};
use serde_derive::Deserialize;


static WRAPPER_PREFIX : &'static str = "Lua";

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {

    /// Paths to json files generated by `rustdoc -p <crate> --output-format json`
    #[clap(short, long, value_parser)]
    json: Vec<String>,
    
    /// The path to toml config file which contains the types to be wrapped and overrides
    #[clap(short, long, value_parser)]
    config: String,

    /// if true the excluded methods will show up as commented out code with reasons for exclusion
    #[clap(long)]
    print_errors: bool
}

#[derive(Deserialize,Debug)]
pub(crate) struct Config {
    #[serde(skip_deserializing,default)]
    pub types : IndexMap<String,Newtype>,

    #[serde(rename="types")]
    pub types_ : Vec<Newtype>,

    pub imports : String,

    pub external_types : Vec<String>,

    pub primitives : HashSet<String>,
}




#[derive(Deserialize,Debug, Hash, PartialEq, Eq)]
pub(crate) struct Newtype {

    #[serde(rename="type")]
    type_ : String,

    /// Override type-level docstring 
    pub doc : Option<String>,

    #[serde(default)]
    pub source : Source,

    #[serde(default)]
    pub wrapper_type : WrapperType,

    #[serde(default)]
    pub lua_methods: Vec<String>,

    #[serde(default)]
    pub derive_flags: Vec<String>,

    #[serde(default)]
    pub import_path: String,

    #[serde(default)]
    pub traits : Vec<TraitMethods>
}

#[derive(Deserialize, Debug, PartialEq, Eq, Hash, Default)]
pub(crate) struct TraitMethods {
    pub name: String,
    pub import_path: String
}

#[derive(Deserialize,Debug, PartialEq, Eq, Hash)]
pub(crate) struct Source(String);

impl Default for Source {
    fn default() -> Self {
        Self("bevy".to_string())
    }
}

impl Newtype {
    /// Returns true if this Type:
    /// - describes the given item element
    /// - if the element is fully described in the source crate
    /// - if the element is a struct or enum
    pub fn matches_result(&self, item : &Item, source : &Crate) -> bool {
        
        match &item.inner {
            ItemEnum::Struct(_) => {},
            ItemEnum::Enum(_) => {},
            _ => return false
        };

        if source.external_crates.contains_key(&item.crate_id){
            return false
        };

        true
    }
}


#[derive(Deserialize, Debug,Clone, Copy, PartialEq, Eq, Hash)]
pub(crate) enum WrapperType {
    /// things which have pass by value semantics
    Value,
    /// things which have pass by reference semantics
    Ref,
    /// For primitives
    Primitive
}

impl ToString for WrapperType {
    fn to_string(&self) -> String {
        match self {
            WrapperType::Value => "Value".to_string(),
            WrapperType::Ref => "Ref".to_string(),
            WrapperType::Primitive => "Primitive".to_string(),
        }
    }
}

impl Default for WrapperType {
    fn default() -> Self {
        Self::Value
    }
}

#[derive(Debug)]
pub(crate) struct WrappedItem<'a> {
    wrapper_type : WrapperType,
    wrapper_name : String,
    wrapped_type: &'a String,
    path_components: &'a [String],
    source: &'a Crate,
    config: &'a Newtype,
    item : &'a Item,
    /// The items coming from all trait implementations
    impl_items: IndexMap<&'a str,Vec<(&'a Impl, &'a Item)>>, 
    self_impl: Option<&'a Impl>,
    crates : &'a [Crate],
}


pub(crate) fn is_valid_lua_fn_arg(str : &str, config : &Config) -> bool{
    const FROM_PRIMITIVES : [&str;18] = ["bool","StdString","CString","BString","i8","u8","i16","u16","i32","u32","i64","u64","i128","u128","isize","usize","f32","f64"];

    // we also allow references to these, since we can just reference by value
    // but we do not allow mutable versions since that can easilly cause unexpected behaviour
    // TODO: only allow refs for Ref types ?
    let base_string = 
        if str.starts_with("&"){
            &str[1..]
        } else if str.starts_with("& mut") {
            &str[4..]
        } else {
            &str[..]
        };
    
    if  base_string == "self" ||
        FROM_PRIMITIVES.contains(&base_string) ||
        (base_string.starts_with("Lua") &&
        config.types.contains_key(&base_string[WRAPPER_PREFIX.len()..])){
        return true
    };

    false
}

pub(crate) fn is_valid_lua_fn_return_typ(str : &str, config : &Config) -> bool{
    const TO_PRIMITIVES : [&str;22] = ["bool","StdString","&str","Box<str>","CString","&CStr","BString","&BStr","i8","u8","i16","u16","i32","u32","i64","u64","i128","u128","isize","usize","f32","f64"];

    // TODO: support slices of supported types + Cow strings

    // we also allow references to these, since we can just reference by value
    // but we do not allow mutable versions since that can easilly cause unexpected behaviour
    
    if TO_PRIMITIVES.contains(&str) ||
        (str.starts_with("Lua") &&
        config.types.contains_key(&str[WRAPPER_PREFIX.len()..])){
        return true
    };

    false
}

/// standardizes simple function arguments identifiers to auto method format
pub(crate) fn to_auto_method_argument(base_string : &String,wrapped: &WrappedItem, config : &Config, is_first_arg : bool) -> Result<String,String>{
    let underlying_type = 
        if base_string == "Self"{
            if is_first_arg {
                return Ok("self".to_owned())
            } else {
                wrapped.wrapped_type
            }
        } else {
            base_string
        };

    if config.types.contains_key(underlying_type){
        // wrap things that need wrapped
        Ok(format!("{WRAPPER_PREFIX}{underlying_type}"))
    } else if config.primitives.contains(underlying_type) {
        Ok(underlying_type.to_string())
    } else {
        Err(underlying_type.to_owned())
    }
    
}

pub(crate) fn to_op_argument(base_string: &String, self_type : &String, wrapped : &WrappedItem, config : &Config, is_first_arg : bool, is_return_type : bool) -> Result<String,String>{
        // first of all deal with Self arguments
    // return if needs to just be self
    // otherwise get unwrapped type name

    let self_on_lhs = self_type == wrapped.wrapped_type;

    let underlying_type = 
        if base_string == "Self" && self_on_lhs && is_first_arg{
            return Ok("self".to_owned())
        } else if base_string == "Self"{
            &self_type
        } else {
            if !self_on_lhs && !is_return_type{
                return Ok("self".to_owned())
            } else{
                base_string
            }
        };

    if config.types.contains_key(underlying_type){
        // wrap things that need wrapped
        Ok(format!("{WRAPPER_PREFIX}{underlying_type}"))
    } else if config.primitives.contains(underlying_type) {
        Ok(underlying_type.to_string())
    } else {
        Err(underlying_type.to_owned())
    }
}

/// Converts an arbitary type to its simple string representation while converting the base type identifier with the given function
pub(crate) fn type_to_string<F : Fn(&String) -> Result<String,String>>(t : &Type, f : &F) -> Result<String,String> {
    match t {
        Type::ResolvedPath { name, .. } | 
        Type::Generic(name) => // For some reason Self is a generic
                f(name)
        ,
        Type::Primitive(v) => Ok(v.to_string()),
        Type::Tuple(v) => Ok(format!("({})",v.iter().map(|t| type_to_string(t,f.clone())).collect::<Result<Vec<_>,_>>()?.join(","))),
        Type::Slice(v) => Ok(format!("[{}]",type_to_string(v,f)?)),
        Type::Array { type_, len } => Ok(format!("[{};{}]",type_to_string(type_,f)?,len)),
        Type::BorrowedRef { lifetime, mutable, type_ } => {
            
            let base = type_to_string(type_,f)?;
            let inner = format!("&{}{}{}",
                lifetime.as_ref()
                        .map(|v| format!("'{v} "))
                        .unwrap_or_default(),
                mutable.then(|| "mut ")
                    .unwrap_or_default(),
                base
            );
            Ok(inner)
            
        },
        _ => Err(format!("{t:?}"))
    }
}

impl WrappedItem<'_> {

    /// Writes full type path inline corresponding to `Reflect::type_name` of each type
    /// 
    /// As: 
    /// ```rust,ignore
    /// 
    /// this
    /// |
    /// |..........|
    /// my_type_path::Type : Value : 
    ///  UnaryOps( ...
    /// ```
    pub fn write_inline_full_path(&self, writer: &mut PrettyWriter, _: &Args) {
        if self.config.import_path.is_empty(){
            writer.write_inline(&self.path_components.join("::"));
        } else {
            writer.write_inline(&self.config.import_path);
        }
    }

    /// Writes the docstring for the type over multiple lines
    /// 
    /// As:
    /// ```rust,ignore
    /// 
    /// /// generated docstring
    /// /// here
    /// my_macro_key : Value : 
    ///  UnaryOps(
    ///  ... 
    ///  )
    ///  +
    ///  ...
    /// ```
    pub fn write_type_docstring(&self, writer : &mut PrettyWriter, _: &Args){
        let strings = if let Some(d) = &self.config.doc {
            d.to_string()
        } else {
            self.item.docs
            .as_ref()
            .cloned()
            .unwrap_or_else(||"".to_string())
        };
        writer.set_prefix("///".into());
        strings.lines().for_each(|l| 
            {writer.write_line(l);}
        );
        writer.clear_prefix();
    }

    /// Writes the docstring for the given auto method over multiple lines
    /// 
    /// As:
    /// ```rust,ignore
    /// 
    ///
    /// my_macro_key : Value : 
    ///  AutoMethods(
    ///        /// generated docstring 
    ///        /// here
    ///        my_method(usize) -> u32
    ///  )
    ///  +
    ///  ...
    /// ```
    pub fn write_method_docstring(&self, id : &Id, writer : &mut PrettyWriter, _: &Args){
        writer.set_prefix("///".into());
        self.source.index
                .get(id)
                .unwrap().docs
                .as_ref()
                .cloned()
                .unwrap_or_else(||"".to_owned())
                .lines().for_each(|l| {writer.write_line(l);});
        writer.clear_prefix();
    }

    /// Writes the contents of the impl block for this wrapper
    /// 
    /// As:
    /// 
    /// ```rust,ignore
    ///     impl {
    ///     ... // this!
    ///     }
    /// ```
    pub fn write_impl_block_body(&self, writer: &mut PrettyWriter, _: &Args) {
        self.config.lua_methods
            .iter()
            .for_each(|v| {
                writer.write_postfixed_line(v, ";");
            })
    }

    /// Generates all derive flags for the type,
    /// 
    /// Returns additional imports necessary for the generated methods
    /// 
    /// ```rust,ignore
    /// my_type::Type : Value: 
    /// ... // flags go here
    /// ``` 
    pub fn write_derive_flags_body(&self, config: &Config, writer: &mut PrettyWriter, args: &Args) {


        writer.write_line(": AutoMethods");
        writer.open_paren();
        self.impl_items.iter()
            .flat_map(|(_,items)| items.iter())
            .for_each(|(impl_,v)| { 

                // only select trait methods are allowed
                if let Some(trait_) = &impl_.trait_ {
                    if self.config.traits.iter().find(|f| 
                        match type_to_string(trait_, &|s| Ok(s.to_string())).map(|s|&s == &f.name){
                            Ok(true) => true,
                            _ => false,
                        }
                    ).is_some(){
                        // keep going
                    } else {
                        return
                    }
                };

                let (decl,generics) = match &v.inner {
                    ItemEnum::Function(f) => (&f.decl,&f.generics),
                    ItemEnum::Method(m) => (&m.decl,&m.generics),
                    _ => return,
                };

                let mut errors = Vec::default();

                let mut inner_writer = PrettyWriter::new();

                self.write_method_docstring(&v.id, &mut inner_writer,args);

                inner_writer.write_inline(v.name.as_ref().unwrap());
                inner_writer.write_inline("(");
                decl.inputs
                    .iter()
                    .enumerate()
                    .for_each(|(i,(_,tp))| {
                        let type_ = 
                            type_to_string(tp, &|base_string : &String| 
                                to_auto_method_argument(base_string,self,config,i==0));
                        if let Ok(type_) = type_ {
                            if !is_valid_lua_fn_arg(&type_, config){
                                inner_writer.write_inline(&format!("<invalid: {type_}>"));
                                errors.push(format!("Unsupported argument {}",type_));
                                return;
                            } else {
                                inner_writer.write_inline(&type_);
                            }
                            if i + 1 != decl.inputs.len() {
                                inner_writer.write_inline(",");
                            }
                        } else {
                            errors.push(format!("Unsupported argument {}",type_.unwrap_err()))
                        };
                });
                inner_writer.write_inline(")");
                
                decl.output
                    .as_ref()
                    .map(|tp| {
                        let type_ = type_to_string(tp, &|base_string : &String| to_auto_method_argument(base_string,self,config,false));
                        if let Ok(type_) = type_ {
                            if !is_valid_lua_fn_return_typ(&type_, config){
                                errors.push(format!("Unsupported argument {}",type_));
                                inner_writer.write_inline(&format!("<invalid: {type_}>"));
                            } else {
                                inner_writer.write_inline(" -> ");
                                inner_writer.write_inline(&type_);
                            }
                        } else {
                            errors.push(format!("Unsupported argument {}",type_.unwrap_err()))
                        }
                    });

                if !generics.params.is_empty(){
                    errors.push("Generics on the method".to_owned());
                }

                if !errors.is_empty(){
                    if args.print_errors {
                        writer.set_prefix("// ".into());
                        writer.write_line(&format!("Exclusion reason: {}",errors.join(",")));
                        writer.extend(inner_writer);
                        writer.clear_prefix();
                        writer.newline();
                    }
                } else {
                    inner_writer.write_inline(",");
                    writer.extend(inner_writer);
                    writer.newline();
                }
        });
        writer.close_paren();

        static BINARY_OPS : [(&str,&str); 5] = [("add","Add"),
                                        ("sub","Sub"),
                                        ("div","Div"),
                                        ("mul","Mul"),
                                        ("rem","Rem")];
        writer.write_line("+ BinOps");
        writer.open_paren();
        BINARY_OPS.into_iter().for_each(|(op,rep) |{
            self.impl_items.get(op).map(|items| {
                items.iter()
                .filter_map(|(impl_,item)| Some((impl_,item,type_to_string(&impl_.for_,&|s : &String| Ok(s.to_string())).ok()?)) )
                .filter(|(_,_, self_type)| 
                    (self_type == self.wrapped_type && config.types.contains_key(self_type)) 
                        || config.primitives.contains(self_type))
                .for_each(|(impl_,item, self_type)| {
                    let _ = match &item.inner {
                        ItemEnum::Method(m) => {
                            m.decl.inputs
                                .iter()
                                .enumerate()
                                .map(|(idx,(_,t))| 
                                    type_to_string(t, &|b: &String| to_op_argument(b, &self_type, self, &config, idx == 0,false))
                                ).collect::<Result<Vec<_>,_>>()
                                .and_then(|v| Ok(v.join(&format!(" {} ",rep))))
                                .and_then(|expr| {
                                    // then provide return type
                                    // for these traits that's on associated types within the impl
                                    let out_type = impl_.items.iter().find_map(|v| {
                                        let item = self.source.index.get(v).unwrap();
                                        if let ItemEnum::AssocType { default, .. }= &item.inner{
                                            match item.name.as_ref().map(|v| v.as_str()) {
                                                Some("Output") => return Some(default.as_ref().unwrap()),
                                                _ => {}
                                            }
                                        }
                                        None
                                    }).ok_or_else(|| expr.clone())?;

                                    let return_string = type_to_string(out_type, &|b: &String| to_op_argument(b, &self_type, &self, &config, false,true))?;

                                    writer.write_no_newline(&expr);
                                    writer.write_inline(" -> ");
                                    writer.write_inline(&return_string);
                                    writer.write_inline(",");
                                    writer.newline();
                                    Ok(())
                                })
                        },
                        _ => panic!("Expected method")
                    };
                })
            });
        });
        writer.close_paren();

        static UNARY_OPS : [(&str,&str);1] = [("neg","Neg")];

        writer.write_line("+ UnaryOps");
        writer.open_paren();
        UNARY_OPS.into_iter().for_each(|(op,rep)|{
            self.impl_items.get(op).map(|items|{
                items.iter().for_each(|(_,_)|{
                    writer.write_line(&format!("{rep} self"));
                });
            });
        });
        writer.close_paren();

        self.config.derive_flags.iter().for_each(|flag| {
            writer.write_inline("+ ");
            flag.lines().for_each(|line| {
                writer.write_line(line);
            });
        });

    }


}

pub(crate) fn write_use_items_from_path(module_name: &str,path_components: &[String], writer: &mut PrettyWriter) {
    // generate imports for each item
    writer.write_no_newline("use ");

    if module_name.starts_with("bevy") && module_name.len() > 5{
        writer.write_inline("bevy::");
        writer.write_inline(&module_name[5..]);
    } else {
        writer.write_inline(&module_name);
    }

    for item in path_components{
        writer.write_inline("::");
        writer.write_inline(item);
    }
    writer.write_inline(";");
    writer.newline();
}

pub(crate) fn generate_macros(crates: &[Crate], config: Config, args: &Args) -> Result<String,io::Error> {

    // the items we want to generate macro instantiations for
    let mut unmatched_types : HashSet<&String> = config.types.iter().map(|(k,_v)|k).collect();

    let mut wrapped_items : Vec<_> = crates.iter().flat_map(|source| source.index
        .iter()
        .filter(|(_,item)| item.name
                                    .as_ref()
                                    .and_then(|k|  config.types.get(k))
                                    .and_then(|k| Some(k.matches_result(item,source)))
                                    .unwrap_or(false))
        .map(|(id,item)| {
            // extract all available associated constants,methods etc available to this item
            
            let mut self_impl : Option<&Impl> = None;
            let mut impl_items: IndexMap<&str,Vec<(&Impl,&Item)>> = Default::default();

            let impls = match &item.inner{
                ItemEnum::Struct(s) => &s.impls,
                ItemEnum::Enum(e) => &e.impls,
                _ => panic!("Only structs or enums are allowed!")
            };

            impls.iter().for_each(|id| 
                if let ItemEnum::Impl(i) = &source.index.get(id).unwrap().inner {
                    if i.trait_.is_none(){
                        self_impl = Some(i);
                    }
                    i.items.iter().for_each(|id| {
                        let it = source.index.get(id).unwrap();

                        impl_items.entry(it.name.as_ref().unwrap().as_str())
                                    .or_default()
                                    .push((i,it));

                    })
                    
                } else {
                    panic!("Expected impl items here!")
                }
            );
            
            let config = config.types.get(item.name.as_ref().unwrap()).unwrap();

            let wrapper_type = config.wrapper_type;
            
            let path_components = &source.paths.get(id).unwrap().path;

            let wrapper_name = format!("{WRAPPER_PREFIX}{}",item.name.as_ref().unwrap());
            let wrapped_type = item.name.as_ref().unwrap();
            WrappedItem {
                wrapper_type,
                wrapper_name,
                wrapped_type,
                path_components,
                source,
                config,
                item,
                self_impl,
                impl_items,
                crates,
            }
        }
        )
    )
    .collect();

    wrapped_items.iter().for_each(|v| {
        unmatched_types.remove(&v.wrapped_type);
    });

    if !unmatched_types.is_empty(){
        panic!("Some types were not found in the given crates: {unmatched_types:#?}")
    }


    let mut writer = PrettyWriter::new();


    let mut writer = PrettyWriter::new();

    // we want to preserve the original ordering from the config file
    wrapped_items.sort_by_cached_key(|f| config.types.get_index_of(f.wrapped_type).unwrap());

    writer.write_line("// This file is generated by `bevy_mod_scripting_derive/main.rs` change the template not this file");
    writer.write_line("use bevy_mod_scripting_derive::impl_lua_newtypes;");

    // macro invocation
    writer.write_no_newline("impl_lua_newtypes!");
    writer.open_paren();

    // additional imports
    writer.open_paren();

    // user defined 
    config.imports.lines().for_each(|import| {writer.write_line(import);});
    // automatic

    wrapped_items.iter().for_each(|item| {
        write_use_items_from_path(&item.config.source.0,&item.path_components[1..],&mut writer);
    });

    wrapped_items.iter().for_each(|item|{
        item.config.traits.iter().for_each(|trait_methods|{
            writer.write_no_newline("use ");
            writer.write_inline(&trait_methods.import_path);
            writer.write_inline(";");
            writer.newline();
        })
    });

    // ) import brakcets
    writer.close_paren();

    writer.open_bracket();
    let external_types = &config.external_types.join(",");
    writer.write_line(external_types);
    writer.close_bracket();





    // list of wrapper types
    writer.open_bracket();

    let primitives = r#"
    {
            usize : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<usize>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_usize().ok_or_else(||Error::RuntimeError("Value not compatibile with usize".to_owned()))?)));
            }
    },
    {
            isize : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<isize>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_isize().ok_or_else(||Error::RuntimeError("Value not compatibile with isize".to_owned()))?)));
            }
    },
    {
            i128 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i128>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i128().ok_or_else(||Error::RuntimeError("Value not compatibile with i128".to_owned()))?)));
            }
    },
    {
            i64 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i64>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i64().ok_or_else(||Error::RuntimeError("Value not compatibile with i64".to_owned()))?)));
            }
    },
    {
            i32 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i32>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i32().ok_or_else(||Error::RuntimeError("Value not compatibile with i32".to_owned()))?)));
            }
    },
    {
            i16 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i16>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i16().ok_or_else(||Error::RuntimeError("Value not compatibile with i16".to_owned()))?)));
            }
    },
    {
            i8 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i8>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i8().ok_or_else(||Error::RuntimeError("Value not compatibile with i8".to_owned()))?)));
            }
    },
    {
            u128 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u128>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u128().ok_or_else(||Error::RuntimeError("Value not compatibile with u128".to_owned()))?)));
            }
    },
    {
            u64 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u64>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u64().ok_or_else(||Error::RuntimeError("Value not compatibile with u64".to_owned()))?)));
            }
    },
    {
            u32 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u32>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u32().ok_or_else(||Error::RuntimeError("Value not compatibile with u32".to_owned()))?)));
            }
    },
    {
            u16 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u16>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u16().ok_or_else(||Error::RuntimeError("Value not compatibile with u16".to_owned()))?)));
            }
    },
    {
            u8 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u8>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u8().ok_or_else(||Error::RuntimeError("Value not compatibile with u8".to_owned()))?)));
            }
    },
    {
            f32 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Number(s.downcast_ref::<f32>().unwrap().to_f64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_number(v)?.ok_or_else(||Error::RuntimeError("Not a number".to_owned()))?.to_f32().ok_or_else(||Error::RuntimeError("Value not compatibile with f32".to_owned()))?)));
            }
    },
    {
            f64 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Number(s.downcast_ref::<f64>().unwrap().to_f64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_number(v)?.ok_or_else(||Error::RuntimeError("Not a number".to_owned()))?.to_f64().ok_or_else(||Error::RuntimeError("Value not compatibile with f64".to_owned()))?)));
            }
    },
    {
            alloc::string::String : Primitive
            impl {
            "to" => |r,c| r.get(|s,_| Value::String(c.create_string(s.downcast_ref::<String>().unwrap()).unwrap()));
            "from" =>   |r,c,v : Value| c.coerce_string(v)?.ok_or_else(||Error::RuntimeError("Not a string".to_owned())).and_then(|string| r.get_mut(|s,_| Ok(s.apply(&string.to_str()?.to_owned()))));                             //      
            }
    },
    "#;

    for line in primitives.lines(){
        writer.write_line(line);
    };

    wrapped_items.iter().for_each(|v| {
        writer.open_brace();
        
        v.write_type_docstring(&mut writer, args);
        writer.write_indentation();
        v.write_inline_full_path(&mut writer, args);
        writer.write_inline(" : ");
        writer.write_inline(&v.wrapper_type.to_string());
        writer.newline();

        writer.indent();
        v.write_derive_flags_body(&config, &mut writer, args);
        writer.dedent();

        writer.write_line("impl");
        writer.open_brace();
        v.write_impl_block_body(&mut writer, args);
        writer.close_brace();

        writer.close_brace();
        
        writer.write_inline(",");
    });


   
    // close ] wrapper list
    writer.close_bracket();
    // close ) macro call
    writer.close_paren();
    writer.write_inline(";");

    Ok(writer.finish())
}

pub fn main() -> Result<(),io::Error>{
    let args = Args::parse();



    let crates : Vec<_> = args.json.iter().map(|json| {
        let f = File::open(&json).expect(&format!("Could not open {}", &json));
        let rdr = BufReader::new(f);
        from_reader(rdr)
    }).collect::<Result<Vec<_>,_>>()?;


    let f = read_to_string(&args.config)?;
    let mut config: Config = toml::from_str(&f)?;

    config.types_.reverse();

    while !config.types_.is_empty(){
        let t = config.types_.remove(config.types_.len() - 1);
        config.types.insert(t.type_.to_string(),t);
    }



    let out = generate_macros(&crates,config, &args)?;

    println!("{}",out);

    Ok(())
}