use bevy_api_gen_lib::{PrettyWriter, WrappedItem, Config, Args, WRAPPER_PREFIX};

use std::{io::{self, BufReader},fs::{File,read_to_string}, collections::{HashSet}, borrow::Cow};
use clap::Parser;
use indexmap::{IndexMap, IndexSet};
use serde_json::from_reader;
use rustdoc_types::{Crate, Item, ItemEnum, Id, Impl,Type};
use serde_derive::Deserialize;



pub(crate) fn write_use_items_from_path(module_name: &str,path_components: &[String], writer: &mut PrettyWriter) {
    // generate imports for each item
    writer.write_no_newline("use ");

    if module_name.starts_with("bevy") && module_name.len() > 5{
        writer.write_inline("bevy::");
        writer.write_inline(&module_name[5..]);
    } else {
        writer.write_inline(&module_name);
    }

    for item in path_components{
        writer.write_inline("::");
        writer.write_inline(item);
    }
    writer.write_inline(";");
    writer.newline();
}

pub(crate) fn generate_macros(crates: &[Crate], config: Config, args: &Args) -> Result<String,io::Error> {

    // the items we want to generate macro instantiations for
    let mut unmatched_types : HashSet<&String> = config.types.iter().map(|(k,_v)|k).collect();

    let mut wrapped_items : Vec<_> = crates.iter().flat_map(|source| source.index
        .iter()
        .filter(|(_,item)| item.name
                                    .as_ref()
                                    .and_then(|k|  config.types.get(k))
                                    .and_then(|k| Some(k.matches_result(item,source)))
                                    .unwrap_or(false))
        .map(|(id,item)| {
            // extract all available associated constants,methods etc available to this item
            
            let mut self_impl : Option<&Impl> = None;
            let mut impl_items: IndexMap<&str,Vec<(&Impl,&Item)>> = Default::default();

            let impls = match &item.inner{
                ItemEnum::Struct(s) => &s.impls,
                ItemEnum::Enum(e) => &e.impls,
                _ => panic!("Only structs or enums are allowed!")
            };

            impls.iter().for_each(|id| 
                if let ItemEnum::Impl(i) = &source.index.get(id).unwrap().inner {
                    if i.trait_.is_none(){
                        self_impl = Some(i);
                    }
                    i.items.iter().for_each(|id| {
                        let it = source.index.get(id).unwrap();

                        impl_items.entry(it.name.as_ref().unwrap().as_str())
                                    .or_default()
                                    .push((i,it));

                    })
                    
                } else {
                    panic!("Expected impl items here!")
                }
            );
            
            let config = config.types.get(item.name.as_ref().unwrap()).unwrap();

            let wrapper_type = config.wrapper_type;
            
            let path_components = &source.paths.get(id).unwrap().path;

            let wrapper_name = format!("{WRAPPER_PREFIX}{}",item.name.as_ref().unwrap());
            let wrapped_type = item.name.as_ref().unwrap();
            WrappedItem {
                wrapper_type,
                wrapper_name,
                wrapped_type,
                path_components,
                source,
                config,
                item,
                self_impl,
                impl_items,
                crates,
            }
        }
        )
    )
    .collect();

    wrapped_items.iter().for_each(|v| {
        unmatched_types.remove(&v.wrapped_type);
    });

    if !unmatched_types.is_empty(){
        panic!("Some types were not found in the given crates: {unmatched_types:#?}")
    }


    let mut writer = PrettyWriter::new();

    // we want to preserve the original ordering from the config file
    wrapped_items.sort_by_cached_key(|f| config.types.get_index_of(f.wrapped_type).unwrap());

    writer.write_line("// This file is generated by `bevy_mod_scripting_derive/main.rs` change the template not this file");
    writer.write_line("use bevy_mod_scripting_derive::impl_lua_newtypes;");

    // macro invocation
    writer.write_no_newline("impl_lua_newtypes!");
    writer.open_paren();

    // additional imports
    writer.open_paren();

    // user defined 
    config.imports.lines().for_each(|import| {writer.write_line(import);});
    // automatic

    wrapped_items.iter().for_each(|item| {
        write_use_items_from_path(&item.config.source.0,&item.path_components[1..],&mut writer);
    });

    let mut imported = HashSet::<String>::default();

    wrapped_items.iter().for_each(|item|{
        item.config.traits.iter().for_each(|trait_methods|{
            if !imported.contains(&trait_methods.name){
                writer.write_no_newline("use ");
                writer.write_inline(&trait_methods.import_path);
                writer.write_inline(";");
                writer.newline();
                imported.insert(trait_methods.name.to_owned());
            }

        })
    });

    // ) import brakcets
    writer.close_paren();

    writer.open_bracket();
    let external_types = &config.external_types.join(",");
    writer.write_line(external_types);
    writer.close_bracket();





    // list of wrapper types
    writer.open_bracket();

    let primitives = r#"
    {
            usize : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<usize>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_usize().ok_or_else(||Error::RuntimeError("Value not compatibile with usize".to_owned()))?)));
            }
    },
    {
            isize : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<isize>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_isize().ok_or_else(||Error::RuntimeError("Value not compatibile with isize".to_owned()))?)));
            }
    },
    {
            i128 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i128>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i128().ok_or_else(||Error::RuntimeError("Value not compatibile with i128".to_owned()))?)));
            }
    },
    {
            i64 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i64>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i64().ok_or_else(||Error::RuntimeError("Value not compatibile with i64".to_owned()))?)));
            }
    },
    {
            i32 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i32>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i32().ok_or_else(||Error::RuntimeError("Value not compatibile with i32".to_owned()))?)));
            }
    },
    {
            i16 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i16>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i16().ok_or_else(||Error::RuntimeError("Value not compatibile with i16".to_owned()))?)));
            }
    },
    {
            i8 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i8>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i8().ok_or_else(||Error::RuntimeError("Value not compatibile with i8".to_owned()))?)));
            }
    },
    {
            u128 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u128>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u128().ok_or_else(||Error::RuntimeError("Value not compatibile with u128".to_owned()))?)));
            }
    },
    {
            u64 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u64>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u64().ok_or_else(||Error::RuntimeError("Value not compatibile with u64".to_owned()))?)));
            }
    },
    {
            u32 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u32>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u32().ok_or_else(||Error::RuntimeError("Value not compatibile with u32".to_owned()))?)));
            }
    },
    {
            u16 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u16>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u16().ok_or_else(||Error::RuntimeError("Value not compatibile with u16".to_owned()))?)));
            }
    },
    {
            u8 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u8>().unwrap().to_i64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u8().ok_or_else(||Error::RuntimeError("Value not compatibile with u8".to_owned()))?)));
            }
    },
    {
            f32 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Number(s.downcast_ref::<f32>().unwrap().to_f64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_number(v)?.ok_or_else(||Error::RuntimeError("Not a number".to_owned()))?.to_f32().ok_or_else(||Error::RuntimeError("Value not compatibile with f32".to_owned()))?)));
            }
    },
    {
            f64 : Primitive
            impl {
            "to" => |r,_| r.get(|s,_| Value::Number(s.downcast_ref::<f64>().unwrap().to_f64().unwrap()));
            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_number(v)?.ok_or_else(||Error::RuntimeError("Not a number".to_owned()))?.to_f64().ok_or_else(||Error::RuntimeError("Value not compatibile with f64".to_owned()))?)));
            }
    },
    {
            alloc::string::String : Primitive
            impl {
            "to" => |r,c| r.get(|s,_| Value::String(c.create_string(s.downcast_ref::<String>().unwrap()).unwrap()));
            "from" =>   |r,c,v : Value| c.coerce_string(v)?.ok_or_else(||Error::RuntimeError("Not a string".to_owned())).and_then(|string| r.get_mut(|s,_| Ok(s.apply(&string.to_str()?.to_owned()))));                             //      
            }
    },
    "#;

    for line in primitives.lines(){
        writer.write_line(line);
    };

    wrapped_items.iter().for_each(|v| {
        writer.open_brace();
        
        v.write_type_docstring(&mut writer, args);
        writer.write_indentation();
        v.write_inline_full_path(&mut writer, args);
        writer.write_inline(" : ");
        writer.write_inline(&v.wrapper_type.to_string());
        writer.newline();

        // writer.indent();
        v.write_derive_flags_body(&config, &mut writer, args);
        // writer.dedent();

        writer.write_line("impl");
        writer.open_brace();
        v.write_impl_block_body(&mut writer, args);
        writer.close_brace();

        writer.close_brace();
        
        writer.write_inline(",");
    });


   
    // close ] wrapper list
    writer.close_bracket();
    // close ) macro call
    writer.close_paren();
    writer.write_inline(";");

    Ok(writer.finish())
}

pub fn main() -> Result<(),io::Error>{
    let args = Args::parse();



    let crates : Vec<_> = args.json.iter().map(|json| {
        let f = File::open(&json).expect(&format!("Could not open {}", &json));
        let rdr = BufReader::new(f);
        from_reader(rdr)
    }).collect::<Result<Vec<_>,_>>()?;


    let f = read_to_string(&args.config)?;
    let mut config: Config = toml::from_str(&f)?;

    config.types_.reverse();

    while !config.types_.is_empty(){
        let t = config.types_.remove(config.types_.len() - 1);
        config.types.insert(t.type_.to_string(),t);
    }



    let out = generate_macros(&crates,config, &args)?;

    println!("{}",out);

    Ok(())
}