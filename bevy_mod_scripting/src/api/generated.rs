// This file is generated by `bevy_mod_scripting_derive/main.rs` change the template not this file
use bevy_mod_scripting_derive::impl_lua_newtypes;
impl_lua_newtypes!(
	(
		use std::ops::*;
		use phf::{phf_map, Map};
		use crate::ReflectPtr;
		use crate::{LuaWorld,ScriptRef,ScriptRefBase};
		use std::sync::Arc;
		use crate::util::impl_tealr_type;
		use num_traits::cast::ToPrimitive;
		use bevy_mod_scripting_derive::{replace};
		use tealr::{mlu::{mlua,mlua::{prelude::*,Error,MetaMethod,Value}},create_union_mlua};
		use bevy::{prelude::*,pbr::*,render::{*,camera::{DepthCalculation,CameraRenderGraph}},utils::*,asset::*,ecs::*,math::*};
	)
	[
		LuaWorld
	]
	[
		{
			///Lightweight identifier of an [entity](crate::entity).
			///
			///The identifier is implemented using a [generational index]: a combination of an ID and a generation.
			///This allows fast insertion after data removal in an array while minimizing loss of spatial locality.
			///
			///[generational index]: https://lucassardois.medium.com/generational-indices-guide-8e3c5f7fd594
			///
			///# Usage
			///
			///This data type is returned by iterating a `Query` that has `Entity` as part of its query fetch type parameter ([learn more]).
			///It can also be obtained by calling [`EntityCommands::id`] or [`EntityMut::id`].
			///
			///```
			///# use bevy_ecs::prelude::*;
			///#
			///fn setup(mut commands: Commands) {
			///    // Calling `spawn` returns `EntityCommands`.
			///    let entity = commands.spawn().id();
			///}
			///
			///fn exclusive_system(world: &mut World) {
			///    // Calling `spawn` returns `EntityMut`.
			///    let entity = world.spawn().id();
			///}
			///#
			///# bevy_ecs::system::assert_is_system(setup);
			///# bevy_ecs::system::IntoExclusiveSystem::exclusive_system(exclusive_system);
			///```
			///
			///It can be used to refer to a specific entity to apply [`EntityCommands`], or to call [`Query::get`] (or similar methods) to access its components.
			///
			///```
			///# use bevy_ecs::prelude::*;
			///#
			///# #[derive(Component)]
			///# struct Expired;
			///#
			///fn dispose_expired_food(mut commands: Commands, query: Query<Entity, With<Expired>>) {
			///    for food_entity in query.iter() {
			///        commands.entity(food_entity).despawn();
			///    }
			///}
			///#
			///# bevy_ecs::system::assert_is_system(dispose_expired_food);
			///```
			///
			///[learn more]: crate::system::Query#entity-id-access
			///[`EntityCommands::id`]: crate::system::EntityCommands::id
			///[`EntityMut::id`]: crate::world::EntityMut::id
			///[`EntityCommands`]: crate::system::EntityCommands
			///[`Query::get`]: crate::system::Query::get
bevy_ecs::entity::Entity : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new entity reference with the specified `id` and a generation of 0.
				// ///
				// ///# Note
				// ///
				// ///Spawning a specific `entity` value is __rarely the right choice__. Most apps should favor
				// ///[`Commands::spawn`](crate::system::Commands::spawn). This method should generally
				// ///only be used for sharing entities across apps, and only when they have a scheme
				// ///worked out to share an ID space (which doesn't happen by default).
				// ///
				// ///In general, one should not try to synchronize the ECS by attempting to ensure that
				// ///`Entity` lines up between instances, but instead insert a secondary identifier as
				// ///a component.
				// ///
				// ///There are still some use cases where it might be appropriate to use this function
				// ///externally.
				// ///
				// ///## Examples
				// ///
				// ///Initializing a collection (e.g. `array` or `Vec`) with a known size:
				// ///
				// ///```no_run
				// ///# use bevy_ecs::prelude::*;
				// ///// Create a new array of size 10 and initialize it with (invalid) entities.
				// ///let mut entities: [Entity; 10] = [Entity::from_raw(0); 10];
				// ///
				// ///// ... replace the entities with valid ones.
				// ///```
				// ///
				// ///Deriving `Reflect` for a component that has an `Entity` field:
				// ///
				// ///```no_run
				// ///# use bevy_ecs::{prelude::*, component::*};
				// ///# use bevy_reflect::Reflect;
				// ///#[derive(Reflect, Component)]
				// ///#[reflect(Component)]
				// ///pub struct MyStruct {
				// ///    pub entity: Entity,
				// ///}
				// ///
				// ///impl FromWorld for MyStruct {
				// ///    fn from_world(_world: &mut World) -> Self {
				// ///        Self {
				// ///            entity: Entity::from_raw(u32::MAX),
				// ///        }
				// ///    }
				// ///}
				// ///```
				// from_raw(u32) -> LuaEntity

				// Exclusion reason: 
				// ///Convert to a form convenient for passing outside of rust.
				// ///
				// ///Only useful for identifying entities within the same instance of an application. Do not use
				// ///for serialization between runs.
				// ///
				// ///No particular structure is guaranteed for the returned bits.
				// to_bits(self) -> u64

				// Exclusion reason: 
				// ///Reconstruct an `Entity` previously destructured with [`Entity::to_bits`].
				// ///
				// ///Only useful when applied to results from `to_bits` in the same instance of an application.
				// from_bits(u64) -> LuaEntity

				// Exclusion reason: 
				// ///Return a transiently unique identifier.
				// ///
				// ///No two simultaneously-live entities share the same ID, but dead entities' IDs may collide
				// ///with both live and dead entities. Useful for compactly representing entities within a
				// ///specific snapshot of the world, such as when serializing.
				// id(self) -> u32

				// Exclusion reason: 
				// ///Returns the generation of this Entity's id. The generation is incremented each time an
				// ///entity with a given id is despawned. This serves as a "count" of the number of times a
				// ///given id has been reused (id, generation) pairs uniquely identify a given Entity.
				// generation(self) -> u32

				try_from()

				///Returns the argument unchanged.
				from()

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_owned(&self)

				clone_into(&self)

				path(<invalid: &''r self><invalid: &''p str>)

				path_mut(<invalid: &''r mut self><invalid: &''p str>)

				clone_type_data(&self)

				as_dyn_eq(&self)

				dyn_hash(&self)

				as_any(&self)

				as_any(&self)

				as_any(&self)

				dyn_eq(&self) -> bool

				get_hash() -> u64

				into_any_arc()

				into_any()

				into_any()

				into_any_rc()

				as_any_mut(<invalid: &mut self>)

				as_any_mut(<invalid: &mut self>)

				erased_serialize(&self)

				serialize(&self)

				deserialize()

				// Exclusion reason: 
				// clone(&self) -> LuaEntity

				hash(&self)<invalid: ()>

				cmp(&self&LuaEntity)

				// Exclusion reason: 
				// eq(&self&LuaEntity) -> bool

				// Exclusion reason: 
				// ne(&self&LuaEntity) -> bool

				partial_cmp(&self&LuaEntity)

				fmt(&self)

				// Exclusion reason: 
				// sparse_set_index(&self) -> usize

				// Exclusion reason: 
				// get_sparse_set_index(usize) -> LuaEntity

				shrink()

				get_type_registration()

				type_info()

				// Exclusion reason: 
				// type_name(&self) -> &str

				get_type_info(&self)

				as_reflect(&self)

				as_reflect_mut(<invalid: &mut self>)

				clone_value(&self)

				apply(<invalid: &mut self>)

				set(<invalid: &mut self>)

				reflect_ref(&self)

				reflect_mut(<invalid: &mut self>)

				reflect_hash(&self)

				reflect_partial_eq(&self)

				from_reflect()

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
			///Alpha mode
bevy_pbr::AlphaMode : Value
AutoMethods			(
				try_from()

				///Returns the argument unchanged.
				from()

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_owned(&self)

				clone_into(&self)

				from_world()

				path(<invalid: &''r self><invalid: &''p str>)

				path_mut(<invalid: &''r mut self><invalid: &''p str>)

				clone_type_data(&self)

				as_any(&self)

				as_any(&self)

				as_any(&self)

				dyn_eq(&self) -> bool

				into_any_arc()

				into_any()

				into_any()

				into_any_rc()

				as_any_mut(<invalid: &mut self>)

				as_any_mut(<invalid: &mut self>)

				vzip(self)

				as_bind_group_shader_type(&self)

				equivalent(&self) -> bool

				downcast(&self)

				upcast(&self)

				fmt(&self)

				// Exclusion reason: 
				// default() -> LuaAlphaMode

				get_type_registration()

				type_info()

				// Exclusion reason: 
				// type_name(&self) -> &str

				get_type_info(&self)

				as_reflect(&self)

				as_reflect_mut(<invalid: &mut self>)

				clone_value(&self)

				apply(<invalid: &mut self>)

				set(<invalid: &mut self>)

				reflect_ref(&self)

				reflect_mut(<invalid: &mut self>)

				// Exclusion reason: 
				// clone(&self) -> LuaAlphaMode

				// Exclusion reason: 
				// eq(&self&LuaAlphaMode) -> bool

				// Exclusion reason: 
				// ne(&self&LuaAlphaMode) -> bool

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
			///A configurable [`CameraProjection`] that can select its projection type at runtime.
bevy_render::camera::Projection : Value
AutoMethods			(
				try_from()

				///Returns the argument unchanged.
				from()

				from() -> LuaProjection

				from() -> LuaProjection

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_owned(&self)

				clone_into(&self)

				from_world()

				path(<invalid: &''r self><invalid: &''p str>)

				path_mut(<invalid: &''r mut self><invalid: &''p str>)

				clone_type_data(&self)

				into_any_arc()

				into_any()

				into_any()

				into_any_rc()

				as_any(&self)

				as_any(&self)

				as_any_mut(<invalid: &mut self>)

				as_any_mut(<invalid: &mut self>)

				vzip(self)

				downcast(&self)

				upcast(&self)

				fmt(&self)

				// Exclusion reason: 
				// clone(&self) -> LuaProjection

				get_type_registration()

				type_info()

				// Exclusion reason: 
				// type_name(&self) -> &str

				get_type_info(&self)

				as_reflect(&self)

				as_reflect_mut(<invalid: &mut self>)

				clone_value(&self)

				apply(<invalid: &mut self>)

				set(<invalid: &mut self>)

				reflect_ref(&self)

				reflect_mut(<invalid: &mut self>)

				// Exclusion reason: 
				// get_projection_matrix(&self) -> LuaMat4

				update(<invalid: &mut self>f32f32)

				// Exclusion reason: 
				// depth_calculation(&self) -> LuaDepthCalculation

				// Exclusion reason: 
				// far(&self) -> f32

				// Exclusion reason: 
				// default() -> LuaProjection

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
			///The "target" that a [`Camera`] will render to. For example, this could be a [`Window`](bevy_window::Window)
			///swapchain or an [`Image`].
bevy_render::camera::RenderTarget : Value
AutoMethods			(
				get_texture_view(&self)

				get_render_target_info(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_owned(&self)

				clone_into(&self)

				from_world()

				path(<invalid: &''r self><invalid: &''p str>)

				path_mut(<invalid: &''r mut self><invalid: &''p str>)

				clone_type_data(&self)

				as_dyn_eq(&self)

				dyn_hash(&self)

				as_any(&self)

				as_any(&self)

				as_any(&self)

				dyn_eq(&self) -> bool

				get_hash() -> u64

				into_any_arc()

				into_any()

				into_any()

				into_any_rc()

				as_any_mut(<invalid: &mut self>)

				as_any_mut(<invalid: &mut self>)

				vzip(self)

				equivalent(&self) -> bool

				downcast(&self)

				upcast(&self)

				fmt(&self)

				// Exclusion reason: 
				// clone(&self) -> LuaRenderTarget

				get_type_registration()

				type_info()

				// Exclusion reason: 
				// type_name(&self) -> &str

				get_type_info(&self)

				as_reflect(&self)

				as_reflect_mut(<invalid: &mut self>)

				clone_value(&self)

				apply(<invalid: &mut self>)

				set(<invalid: &mut self>)

				reflect_ref(&self)

				reflect_mut(<invalid: &mut self>)

				// Exclusion reason: 
				// eq(&self&LuaRenderTarget) -> bool

				// Exclusion reason: 
				// ne(&self&LuaRenderTarget) -> bool

				hash(&self)<invalid: ()>

				partial_cmp(&self&LuaRenderTarget)

				cmp(&self&LuaRenderTarget)

				// Exclusion reason: 
				// default() -> LuaRenderTarget

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
bevy_render::camera::DepthCalculation : Value
AutoMethods			(
				try_from()

				///Returns the argument unchanged.
				from()

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_owned(&self)

				clone_into(&self)

				from_world()

				path(<invalid: &''r self><invalid: &''p str>)

				path_mut(<invalid: &''r mut self><invalid: &''p str>)

				clone_type_data(&self)

				into_any_arc()

				into_any()

				into_any()

				into_any_rc()

				as_any(&self)

				as_any(&self)

				as_any_mut(<invalid: &mut self>)

				as_any_mut(<invalid: &mut self>)

				erased_serialize(&self)

				vzip(self)

				downcast(&self)

				upcast(&self)

				fmt(&self)

				// Exclusion reason: 
				// clone(&self) -> LuaDepthCalculation

				// Exclusion reason: 
				// default() -> LuaDepthCalculation

				get_type_registration()

				type_info()

				// Exclusion reason: 
				// type_name(&self) -> &str

				get_type_info(&self)

				as_reflect(&self)

				as_reflect_mut(<invalid: &mut self>)

				clone_value(&self)

				apply(<invalid: &mut self>)

				set(<invalid: &mut self>)

				reflect_ref(&self)

				reflect_mut(<invalid: &mut self>)

				serialize(&self)

				deserialize()

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
			///Configures the [`RenderGraph`](crate::render_graph::RenderGraph) name assigned to be run for a given [`Camera`] entity.
bevy_render::camera::CameraRenderGraph : Value
AutoMethods			(
				new() -> LuaCameraRenderGraph

				try_from()

				///Returns the argument unchanged.
				from()

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				from_world()

				get_field(&selfusize)

				get_field_mut(<invalid: &mut self>usize)

				path(<invalid: &''r self><invalid: &''p str>)

				path_mut(<invalid: &''r mut self><invalid: &''p str>)

				into_any_arc()

				into_any()

				into_any()

				into_any_rc()

				as_any(&self)

				as_any(&self)

				as_any_mut(<invalid: &mut self>)

				as_any_mut(<invalid: &mut self>)

				vzip(self)

				downcast(&self)

				upcast(&self)

				deref(&self)

				deref_mut(<invalid: &mut self>)

				get_type_registration()

				type_info()

				field(&selfusize)

				field_mut(<invalid: &mut self>usize)

				// Exclusion reason: 
				// field_len(&self) -> usize

				iter_fields(&self)

				clone_dynamic(&self)

				// Exclusion reason: 
				// type_name(&self) -> &str

				get_type_info(&self)

				as_reflect(&self)

				as_reflect_mut(<invalid: &mut self>)

				clone_value(&self)

				set(<invalid: &mut self>)

				apply(<invalid: &mut self>)

				reflect_ref(&self)

				reflect_mut(<invalid: &mut self>)

				reflect_partial_eq(&self)

				// Exclusion reason: 
				// default() -> LuaCameraRenderGraph

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
bevy_core_pipeline::clear_color::ClearColorConfig : Value
AutoMethods			(
				try_from()

				///Returns the argument unchanged.
				from()

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_owned(&self)

				clone_into(&self)

				from_world()

				path(<invalid: &''r self><invalid: &''p str>)

				path_mut(<invalid: &''r mut self><invalid: &''p str>)

				clone_type_data(&self)

				into_any_arc()

				into_any()

				into_any()

				into_any_rc()

				as_any(&self)

				as_any(&self)

				as_any_mut(<invalid: &mut self>)

				as_any_mut(<invalid: &mut self>)

				erased_serialize(&self)

				as_bind_group_shader_type(&self)

				vzip(self)

				downcast(&self)

				upcast(&self)

				get_type_registration()

				type_info()

				// Exclusion reason: 
				// type_name(&self) -> &str

				get_type_info(&self)

				as_reflect(&self)

				as_reflect_mut(<invalid: &mut self>)

				clone_value(&self)

				apply(<invalid: &mut self>)

				set(<invalid: &mut self>)

				reflect_ref(&self)

				reflect_mut(<invalid: &mut self>)

				serialize(&self)

				deserialize()

				// Exclusion reason: 
				// clone(&self) -> LuaClearColorConfig

				fmt(&self)

				// Exclusion reason: 
				// default() -> LuaClearColorConfig

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
			///A unique, stable asset id
bevy_asset::HandleId : Value
AutoMethods			(
				random() -> LuaHandleId

				default() -> LuaHandleId

				new(u64) -> LuaHandleId

				try_from()

				///Returns the argument unchanged.
				from()

				from() -> LuaHandleId

				from() -> LuaHandleId

				from() -> LuaHandleId

				from() -> LuaHandleId

				from(<invalid: &str>) -> LuaHandleId

				from() -> LuaHandleId

				from() -> LuaHandleId

				from() -> LuaHandleId

				from() -> LuaHandleId

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_owned(&self)

				clone_into(&self)

				path(<invalid: &''r self><invalid: &''p str>)

				path_mut(<invalid: &''r mut self><invalid: &''p str>)

				clone_type_data(&self)

				as_dyn_eq(&self)

				dyn_hash(&self)

				as_any(&self)

				as_any(&self)

				as_any(&self)

				dyn_eq(&self) -> bool

				get_hash() -> u64

				into_any_arc()

				into_any()

				into_any()

				into_any_rc()

				as_any_mut(<invalid: &mut self>)

				as_any_mut(<invalid: &mut self>)

				erased_serialize(&self)

				vzip(self)

				fmt(&self)

				// Exclusion reason: 
				// clone(&self) -> LuaHandleId

				// Exclusion reason: 
				// eq(&self&LuaHandleId) -> bool

				// Exclusion reason: 
				// ne(&self&LuaHandleId) -> bool

				hash(&self)<invalid: ()>

				cmp(&self&LuaHandleId)

				partial_cmp(&self&LuaHandleId)

				serialize(&self)

				deserialize()

				get_type_registration()

				type_info()

				// Exclusion reason: 
				// type_name(&self) -> &str

				get_type_info(&self)

				as_reflect(&self)

				as_reflect_mut(<invalid: &mut self>)

				clone_value(&self)

				apply(<invalid: &mut self>)

				set(<invalid: &mut self>)

				reflect_ref(&self)

				reflect_mut(<invalid: &mut self>)

				reflect_hash(&self)

				reflect_partial_eq(&self)

				from_reflect()

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
			///A 2-dimensional vector.
glam::f32::vec2::Vec2 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(f32f32) -> LuaVec2

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(f32) -> LuaVec2

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaVec2LuaVec2) -> LuaVec2

				///Creates a new vector from an array.
				from_array(<invalid: [f32;2]>) -> LuaVec2

				///`[x, y]`
				to_array(&self)<invalid: [f32;2]>

				///Creates a vector from the first 2 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 2 elements long.
				from_slice(<invalid: &[f32]>) -> LuaVec2

				///Writes the elements of `self` to the first 2 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 2 elements long.
				write_to_slice(self<invalid: &mut [f32]>)

				// Exclusion reason: 
				// ///Creates a 3D vector from `self` and the given `z` value.
				// extend(selff32) -> LuaVec3

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaVec2) -> f32

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaVec2LuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> f32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> f32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaVec2)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaVec2)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaVec2)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaVec2)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaVec2)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaVec2)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaVec2

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.  If any element is either
				// ///`NaN`, positive or negative infinity, this will return `false`.
				// is_finite(self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(self) -> bool

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self)

				// Exclusion reason: 
				// ///Computes the length of `self`.
				// length(self) -> f32

				// Exclusion reason: 
				// ///Computes the squared length of `self`.
				// ///
				// ///This is faster than `length()` as it avoids a square root operation.
				// length_squared(self) -> f32

				// Exclusion reason: 
				// ///Computes `1.0 / length()`.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// length_recip(self) -> f32

				// Exclusion reason: 
				// ///Computes the Euclidean distance between two points in space.
				// distance(selfLuaVec2) -> f32

				// Exclusion reason: 
				// ///Compute the squared euclidean distance between two points in space.
				// distance_squared(selfLuaVec2) -> f32

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0.
				// ///
				// ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				// ///
				// ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				// ///
				// ///Panics
				// ///
				// ///Will panic if `self` is zero length when `glam_assert` is enabled.
				// normalize(self) -> LuaVec2

				///Returns `self` normalized to length 1.0 if possible, else returns `None`.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be `None`.
				///
				///See also [`Self::normalize_or_zero`].
				try_normalize(self)

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0 if possible, else returns zero.
				// ///
				// ///In particular, if the input is zero (or very close to zero), or non-finite,
				// ///the result of this operation will be zero.
				// ///
				// ///See also [`Self::try_normalize`].
				// normalize_or_zero(self) -> LuaVec2

				// Exclusion reason: 
				// ///Returns whether `self` is length `1.0` or not.
				// ///
				// ///Uses a precision threshold of `1e-6`.
				// is_normalized(self) -> bool

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				// project_onto(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				// reject_from(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// project_onto_normalized(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// reject_from_normalized(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector containing the nearest integer to a number for each element of `self`.
				// ///Round half-way cases away from 0.0.
				// round(self) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector containing the largest integer less than or equal to a number for each
				// ///element of `self`.
				// floor(self) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector containing the smallest integer greater than or equal to a number for
				// ///each element of `self`.
				// ceil(self) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector containing the fractional part of the vector, e.g. `self -
				// ///self.floor()`.
				// ///
				// ///Note that this is fast but not precise for large numbers.
				// fract(self) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector containing `e^self` (the exponential function) for each element of
				// ///`self`.
				// exp(self) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector containing each element of `self` raised to the power of `n`.
				// powf(selff32) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				// recip(self) -> LuaVec2

				// Exclusion reason: 
				// ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				// ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				// ///extrapolated.
				// lerp(selfLuaVec2f32) -> LuaVec2

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs` is
				// ///less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two vectors contain similar elements. It works best when
				// ///comparing with a known value. The `max_abs_diff` that should be used used depends on
				// ///the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(selfLuaVec2f32) -> bool

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min` and no more than `max`
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp_length(selff32f32) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector with a length no more than `max`
				// clamp_length_max(selff32) -> LuaVec2

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min`
				// clamp_length_min(selff32) -> LuaVec2

				// Exclusion reason: 
				// ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				// ///error, yielding a more accurate result than an unfused multiply-add.
				// ///
				// ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				// ///architecture has a dedicated fma CPU instruction. However, this is not always true,
				// ///and will be heavily dependant on designing algorithms with specific target hardware in
				// ///mind.
				// mul_add(selfLuaVec2LuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
				// ///conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will
				// ///create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.
				// from_angle(f32) -> LuaVec2

				// Exclusion reason: 
				// ///Returns the angle (in radians) between `self` and `rhs`.
				// ///
				// ///The input vectors do not need to be unit length however they must be non-zero.
				// angle_between(selfLuaVec2) -> f32

				// Exclusion reason: 
				// ///Returns a vector that is equal to `self` rotated by 90 degrees.
				// perp(self) -> LuaVec2

				// Exclusion reason: 
				// ///The perpendicular dot product of `self` and `rhs`.
				// ///Also known as the wedge product, 2D cross product, and determinant.
				// perp_dot(selfLuaVec2) -> f32

				// Exclusion reason: 
				// ///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
				// ///then this just rotation. This is what you usually want. Otherwise,
				// ///it will be like a rotation with a multiplication by `self`'s length.
				// rotate(selfLuaVec2) -> LuaVec2

				///Casts all elements of `self` to `f64`.
				as_dvec2(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec2(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec2(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [f32;2]>) -> LuaVec2

				// Exclusion reason: 
				// from(LuaVec2) -> LuaVec2

				from(<invalid: (f32,f32)>) -> LuaVec2

				// Exclusion reason: 
				// from(LuaVec2) -> LuaVec2

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				// Exclusion reason: 
				// clone(&self) -> LuaVec2

				// Exclusion reason: 
				// default() -> LuaVec2

				// Exclusion reason: 
				// eq(&self&LuaVec2) -> bool

				// Exclusion reason: 
				// div(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// div(selff32) -> LuaVec2

				// Exclusion reason: 
				// div(selfLuaVec2) -> LuaVec2

				div_assign(<invalid: &mut self>LuaVec2)

				div_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// mul(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// mul(selff32) -> LuaVec2

				// Exclusion reason: 
				// mul(selfLuaVec2) -> LuaVec2

				mul(selfLuaVec2)

				mul_assign(<invalid: &mut self>LuaVec2)

				mul_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// add(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// add(selff32) -> LuaVec2

				// Exclusion reason: 
				// add(selfLuaVec2) -> LuaVec2

				add_assign(<invalid: &mut self>LuaVec2)

				add_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// sub(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// sub(selff32) -> LuaVec2

				// Exclusion reason: 
				// sub(selfLuaVec2) -> LuaVec2

				sub_assign(<invalid: &mut self>LuaVec2)

				sub_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// rem(selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// rem(selff32) -> LuaVec2

				// Exclusion reason: 
				// rem(selfLuaVec2) -> LuaVec2

				rem_assign(<invalid: &mut self>LuaVec2)

				rem_assign(<invalid: &mut self>f32)

				as_ref(&self)<invalid: &[f32;2]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f32;2]>

				sum() -> LuaVec2

				product() -> LuaVec2

				// Exclusion reason: 
				// neg(self) -> LuaVec2

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaVec2

				// Exclusion reason: 
				// xy(self) -> LuaVec2

				// Exclusion reason: 
				// yx(self) -> LuaVec2

				// Exclusion reason: 
				// yy(self) -> LuaVec2

				// Exclusion reason: 
				// xxx(self) -> LuaVec3

				// Exclusion reason: 
				// xxy(self) -> LuaVec3

				// Exclusion reason: 
				// xyx(self) -> LuaVec3

				// Exclusion reason: 
				// xyy(self) -> LuaVec3

				// Exclusion reason: 
				// yxx(self) -> LuaVec3

				// Exclusion reason: 
				// yxy(self) -> LuaVec3

				// Exclusion reason: 
				// yyx(self) -> LuaVec3

				// Exclusion reason: 
				// yyy(self) -> LuaVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaVec4

			)
+ BinaryOps			(
self Add LuaVec2 -> LuaVec2 -> LuaVec2
self Add f32 -> LuaVec2 -> LuaVec2
f32 Add self -> LuaVec2 -> LuaVec2
self Sub LuaVec2 -> LuaVec2 -> LuaVec2
self Sub f32 -> LuaVec2 -> LuaVec2
f32 Sub self -> LuaVec2 -> LuaVec2
self Div LuaVec2 -> LuaVec2 -> LuaVec2
self Div f32 -> LuaVec2 -> LuaVec2
f32 Div self -> LuaVec2 -> LuaVec2
self Mul LuaVec2 -> LuaVec2 -> LuaVec2
self Mul f32 -> LuaVec2 -> LuaVec2
f32 Mul self -> LuaVec2 -> LuaVec2
self Rem LuaVec2 -> LuaVec2 -> LuaVec2
self Rem f32 -> LuaVec2 -> LuaVec2
f32 Rem self -> LuaVec2 -> LuaVec2
			)
+ UnaryOps			(
			)
impl			{
				(MetaMethod::Index) (s=LuaVec2)=> {|_,s,idx: usize| {Ok(s.clone()[idx-1])}};
				mut (MetaMethod::NewIndex) (n=f32) => {|_,s,(idx,val): (usize,($n))| {Ok(s.val_mut(|s| s[idx-1] = val))}};
			}
		}
		{
			///A 3-dimensional vector.
glam::f32::vec3::Vec3 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(f32f32f32) -> LuaVec3

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(f32) -> LuaVec3

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaVec3LuaVec3) -> LuaVec3

				///Creates a new vector from an array.
				from_array(<invalid: [f32;3]>) -> LuaVec3

				///`[x, y, z]`
				to_array(&self)<invalid: [f32;3]>

				///Creates a vector from the first 3 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 3 elements long.
				from_slice(<invalid: &[f32]>) -> LuaVec3

				///Writes the elements of `self` to the first 3 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 3 elements long.
				write_to_slice(self<invalid: &mut [f32]>)

				// Exclusion reason: 
				// ///Creates a 4D vector from `self` and the given `w` value.
				// extend(selff32) -> LuaVec4

				// Exclusion reason: 
				// ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				// ///
				// ///Truncation may also be performed by using `self.xy()` or `Vec2::from()`.
				// truncate(self) -> LuaVec2

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaVec3) -> f32

				// Exclusion reason: 
				// ///Computes the cross product of `self` and `rhs`.
				// cross(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaVec3LuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> f32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> f32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaVec3)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaVec3)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaVec3)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaVec3)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaVec3)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaVec3)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.  If any element is either
				// ///`NaN`, positive or negative infinity, this will return `false`.
				// is_finite(self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(self) -> bool

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self)

				// Exclusion reason: 
				// ///Computes the length of `self`.
				// length(self) -> f32

				// Exclusion reason: 
				// ///Computes the squared length of `self`.
				// ///
				// ///This is faster than `length()` as it avoids a square root operation.
				// length_squared(self) -> f32

				// Exclusion reason: 
				// ///Computes `1.0 / length()`.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// length_recip(self) -> f32

				// Exclusion reason: 
				// ///Computes the Euclidean distance between two points in space.
				// distance(selfLuaVec3) -> f32

				// Exclusion reason: 
				// ///Compute the squared euclidean distance between two points in space.
				// distance_squared(selfLuaVec3) -> f32

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0.
				// ///
				// ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				// ///
				// ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				// ///
				// ///Panics
				// ///
				// ///Will panic if `self` is zero length when `glam_assert` is enabled.
				// normalize(self) -> LuaVec3

				///Returns `self` normalized to length 1.0 if possible, else returns `None`.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be `None`.
				///
				///See also [`Self::normalize_or_zero`].
				try_normalize(self)

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0 if possible, else returns zero.
				// ///
				// ///In particular, if the input is zero (or very close to zero), or non-finite,
				// ///the result of this operation will be zero.
				// ///
				// ///See also [`Self::try_normalize`].
				// normalize_or_zero(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns whether `self` is length `1.0` or not.
				// ///
				// ///Uses a precision threshold of `1e-6`.
				// is_normalized(self) -> bool

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				// project_onto(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				// reject_from(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// project_onto_normalized(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// reject_from_normalized(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing the nearest integer to a number for each element of `self`.
				// ///Round half-way cases away from 0.0.
				// round(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing the largest integer less than or equal to a number for each
				// ///element of `self`.
				// floor(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing the smallest integer greater than or equal to a number for
				// ///each element of `self`.
				// ceil(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing the fractional part of the vector, e.g. `self -
				// ///self.floor()`.
				// ///
				// ///Note that this is fast but not precise for large numbers.
				// fract(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing `e^self` (the exponential function) for each element of
				// ///`self`.
				// exp(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing each element of `self` raised to the power of `n`.
				// powf(selff32) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				// recip(self) -> LuaVec3

				// Exclusion reason: 
				// ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				// ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				// ///extrapolated.
				// lerp(selfLuaVec3f32) -> LuaVec3

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs` is
				// ///less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two vectors contain similar elements. It works best when
				// ///comparing with a known value. The `max_abs_diff` that should be used used depends on
				// ///the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(selfLuaVec3f32) -> bool

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min` and no more than `max`
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp_length(selff32f32) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector with a length no more than `max`
				// clamp_length_max(selff32) -> LuaVec3

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min`
				// clamp_length_min(selff32) -> LuaVec3

				// Exclusion reason: 
				// ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				// ///error, yielding a more accurate result than an unfused multiply-add.
				// ///
				// ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				// ///architecture has a dedicated fma CPU instruction. However, this is not always true,
				// ///and will be heavily dependant on designing algorithms with specific target hardware in
				// ///mind.
				// mul_add(selfLuaVec3LuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Returns the angle (in radians) between two vectors.
				// ///
				// ///The input vectors do not need to be unit length however they must be non-zero.
				// angle_between(selfLuaVec3) -> f32

				// Exclusion reason: 
				// ///Returns some vector that is orthogonal to the given one.
				// ///
				// ///The input vector must be finite and non-zero.
				// ///
				// ///The output vector is not necessarily unit-length.
				// ///For that use [`Self::any_orthonormal_vector`] instead.
				// any_orthogonal_vector(&self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns any unit-length vector that is orthogonal to the given one.
				// ///The input vector must be finite and non-zero.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` is not normalized when `glam_assert` is enabled.
				// any_orthonormal_vector(&self) -> LuaVec3

				///Given a unit-length vector return two other vectors that together form an orthonormal
				///basis.  That is, all three vectors are orthogonal to each other and are normalized.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				any_orthonormal_pair(&self)<invalid: (LuaVec3,LuaVec3)>

				///Casts all elements of `self` to `f64`.
				as_dvec3(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec3(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec3(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [f32;3]>) -> LuaVec3

				// Exclusion reason: 
				// from(LuaVec3) -> LuaVec3

				from(<invalid: (f32,f32,f32)>) -> LuaVec3

				// Exclusion reason: 
				// from(LuaVec3) -> LuaVec3

				from(<invalid: (LuaVec2,f32)>) -> LuaVec3

				// Exclusion reason: 
				// from(LuaVec3) -> LuaVec3

				from() -> LuaVec3

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaVec3)

				// Exclusion reason: 
				// mul(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// mul(selff32) -> LuaVec3

				// Exclusion reason: 
				// mul(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// mul(selfLuaVec3) -> LuaVec3

				///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				mul(selfLuaVec3)

				// Exclusion reason: 
				// clone(&self) -> LuaVec3

				// Exclusion reason: 
				// default() -> LuaVec3

				// Exclusion reason: 
				// eq(&self&LuaVec3) -> bool

				// Exclusion reason: 
				// div(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// div(selff32) -> LuaVec3

				// Exclusion reason: 
				// div(selfLuaVec3) -> LuaVec3

				div_assign(<invalid: &mut self>LuaVec3)

				div_assign(<invalid: &mut self>f32)

				mul_assign(<invalid: &mut self>LuaVec3)

				mul_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// add(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// add(selff32) -> LuaVec3

				// Exclusion reason: 
				// add(selfLuaVec3) -> LuaVec3

				add_assign(<invalid: &mut self>LuaVec3)

				add_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// sub(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// sub(selff32) -> LuaVec3

				// Exclusion reason: 
				// sub(selfLuaVec3) -> LuaVec3

				sub_assign(<invalid: &mut self>LuaVec3)

				sub_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// rem(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// rem(selff32) -> LuaVec3

				// Exclusion reason: 
				// rem(selfLuaVec3) -> LuaVec3

				rem_assign(<invalid: &mut self>LuaVec3)

				rem_assign(<invalid: &mut self>f32)

				as_ref(&self)<invalid: &[f32;3]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f32;3]>

				sum() -> LuaVec3

				product() -> LuaVec3

				// Exclusion reason: 
				// neg(self) -> LuaVec3

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaVec2

				// Exclusion reason: 
				// xy(self) -> LuaVec2

				// Exclusion reason: 
				// xz(self) -> LuaVec2

				// Exclusion reason: 
				// yx(self) -> LuaVec2

				// Exclusion reason: 
				// yy(self) -> LuaVec2

				// Exclusion reason: 
				// yz(self) -> LuaVec2

				// Exclusion reason: 
				// zx(self) -> LuaVec2

				// Exclusion reason: 
				// zy(self) -> LuaVec2

				// Exclusion reason: 
				// zz(self) -> LuaVec2

				// Exclusion reason: 
				// xxx(self) -> LuaVec3

				// Exclusion reason: 
				// xxy(self) -> LuaVec3

				// Exclusion reason: 
				// xxz(self) -> LuaVec3

				// Exclusion reason: 
				// xyx(self) -> LuaVec3

				// Exclusion reason: 
				// xyy(self) -> LuaVec3

				// Exclusion reason: 
				// xyz(self) -> LuaVec3

				// Exclusion reason: 
				// xzx(self) -> LuaVec3

				// Exclusion reason: 
				// xzy(self) -> LuaVec3

				// Exclusion reason: 
				// xzz(self) -> LuaVec3

				// Exclusion reason: 
				// yxx(self) -> LuaVec3

				// Exclusion reason: 
				// yxy(self) -> LuaVec3

				// Exclusion reason: 
				// yxz(self) -> LuaVec3

				// Exclusion reason: 
				// yyx(self) -> LuaVec3

				// Exclusion reason: 
				// yyy(self) -> LuaVec3

				// Exclusion reason: 
				// yyz(self) -> LuaVec3

				// Exclusion reason: 
				// yzx(self) -> LuaVec3

				// Exclusion reason: 
				// yzy(self) -> LuaVec3

				// Exclusion reason: 
				// yzz(self) -> LuaVec3

				// Exclusion reason: 
				// zxx(self) -> LuaVec3

				// Exclusion reason: 
				// zxy(self) -> LuaVec3

				// Exclusion reason: 
				// zxz(self) -> LuaVec3

				// Exclusion reason: 
				// zyx(self) -> LuaVec3

				// Exclusion reason: 
				// zyy(self) -> LuaVec3

				// Exclusion reason: 
				// zyz(self) -> LuaVec3

				// Exclusion reason: 
				// zzx(self) -> LuaVec3

				// Exclusion reason: 
				// zzy(self) -> LuaVec3

				// Exclusion reason: 
				// zzz(self) -> LuaVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaVec4

				// Exclusion reason: 
				// xxxz(self) -> LuaVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaVec4

				// Exclusion reason: 
				// xxyz(self) -> LuaVec4

				// Exclusion reason: 
				// xxzx(self) -> LuaVec4

				// Exclusion reason: 
				// xxzy(self) -> LuaVec4

				// Exclusion reason: 
				// xxzz(self) -> LuaVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaVec4

				// Exclusion reason: 
				// xyxz(self) -> LuaVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaVec4

				// Exclusion reason: 
				// xyyz(self) -> LuaVec4

				// Exclusion reason: 
				// xyzx(self) -> LuaVec4

				// Exclusion reason: 
				// xyzy(self) -> LuaVec4

				// Exclusion reason: 
				// xyzz(self) -> LuaVec4

				// Exclusion reason: 
				// xzxx(self) -> LuaVec4

				// Exclusion reason: 
				// xzxy(self) -> LuaVec4

				// Exclusion reason: 
				// xzxz(self) -> LuaVec4

				// Exclusion reason: 
				// xzyx(self) -> LuaVec4

				// Exclusion reason: 
				// xzyy(self) -> LuaVec4

				// Exclusion reason: 
				// xzyz(self) -> LuaVec4

				// Exclusion reason: 
				// xzzx(self) -> LuaVec4

				// Exclusion reason: 
				// xzzy(self) -> LuaVec4

				// Exclusion reason: 
				// xzzz(self) -> LuaVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaVec4

				// Exclusion reason: 
				// yxxz(self) -> LuaVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaVec4

				// Exclusion reason: 
				// yxyz(self) -> LuaVec4

				// Exclusion reason: 
				// yxzx(self) -> LuaVec4

				// Exclusion reason: 
				// yxzy(self) -> LuaVec4

				// Exclusion reason: 
				// yxzz(self) -> LuaVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaVec4

				// Exclusion reason: 
				// yyxz(self) -> LuaVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaVec4

				// Exclusion reason: 
				// yyyz(self) -> LuaVec4

				// Exclusion reason: 
				// yyzx(self) -> LuaVec4

				// Exclusion reason: 
				// yyzy(self) -> LuaVec4

				// Exclusion reason: 
				// yyzz(self) -> LuaVec4

				// Exclusion reason: 
				// yzxx(self) -> LuaVec4

				// Exclusion reason: 
				// yzxy(self) -> LuaVec4

				// Exclusion reason: 
				// yzxz(self) -> LuaVec4

				// Exclusion reason: 
				// yzyx(self) -> LuaVec4

				// Exclusion reason: 
				// yzyy(self) -> LuaVec4

				// Exclusion reason: 
				// yzyz(self) -> LuaVec4

				// Exclusion reason: 
				// yzzx(self) -> LuaVec4

				// Exclusion reason: 
				// yzzy(self) -> LuaVec4

				// Exclusion reason: 
				// yzzz(self) -> LuaVec4

				// Exclusion reason: 
				// zxxx(self) -> LuaVec4

				// Exclusion reason: 
				// zxxy(self) -> LuaVec4

				// Exclusion reason: 
				// zxxz(self) -> LuaVec4

				// Exclusion reason: 
				// zxyx(self) -> LuaVec4

				// Exclusion reason: 
				// zxyy(self) -> LuaVec4

				// Exclusion reason: 
				// zxyz(self) -> LuaVec4

				// Exclusion reason: 
				// zxzx(self) -> LuaVec4

				// Exclusion reason: 
				// zxzy(self) -> LuaVec4

				// Exclusion reason: 
				// zxzz(self) -> LuaVec4

				// Exclusion reason: 
				// zyxx(self) -> LuaVec4

				// Exclusion reason: 
				// zyxy(self) -> LuaVec4

				// Exclusion reason: 
				// zyxz(self) -> LuaVec4

				// Exclusion reason: 
				// zyyx(self) -> LuaVec4

				// Exclusion reason: 
				// zyyy(self) -> LuaVec4

				// Exclusion reason: 
				// zyyz(self) -> LuaVec4

				// Exclusion reason: 
				// zyzx(self) -> LuaVec4

				// Exclusion reason: 
				// zyzy(self) -> LuaVec4

				// Exclusion reason: 
				// zyzz(self) -> LuaVec4

				// Exclusion reason: 
				// zzxx(self) -> LuaVec4

				// Exclusion reason: 
				// zzxy(self) -> LuaVec4

				// Exclusion reason: 
				// zzxz(self) -> LuaVec4

				// Exclusion reason: 
				// zzyx(self) -> LuaVec4

				// Exclusion reason: 
				// zzyy(self) -> LuaVec4

				// Exclusion reason: 
				// zzyz(self) -> LuaVec4

				// Exclusion reason: 
				// zzzx(self) -> LuaVec4

				// Exclusion reason: 
				// zzzy(self) -> LuaVec4

				// Exclusion reason: 
				// zzzz(self) -> LuaVec4

			)
+ BinaryOps			(
self Add LuaVec3 -> LuaVec3 -> LuaVec3
self Add f32 -> LuaVec3 -> LuaVec3
f32 Add self -> LuaVec3 -> LuaVec3
self Sub LuaVec3 -> LuaVec3 -> LuaVec3
self Sub f32 -> LuaVec3 -> LuaVec3
f32 Sub self -> LuaVec3 -> LuaVec3
self Div LuaVec3 -> LuaVec3 -> LuaVec3
self Div f32 -> LuaVec3 -> LuaVec3
f32 Div self -> LuaVec3 -> LuaVec3
self Mul LuaVec3 -> LuaVec3 -> LuaVec3
self Mul f32 -> LuaVec3 -> LuaVec3
f32 Mul self -> LuaVec3 -> LuaVec3
self Rem LuaVec3 -> LuaVec3 -> LuaVec3
self Rem f32 -> LuaVec3 -> LuaVec3
f32 Rem self -> LuaVec3 -> LuaVec3
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaVec3),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f32))
			    
impl			{
			}
		}
		{
			///A 4-dimensional vector with SIMD support.
			///
			///This type uses 16 byte aligned SIMD vector type for storage.
glam::f32::sse2::vec4::Vec4 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(f32f32f32f32) -> LuaVec4

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(f32) -> LuaVec4

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaVec4LuaVec4) -> LuaVec4

				///Creates a new vector from an array.
				from_array(<invalid: [f32;4]>) -> LuaVec4

				///`[x, y, z, w]`
				to_array(&self)<invalid: [f32;4]>

				///Creates a vector from the first 4 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 4 elements long.
				from_slice(<invalid: &[f32]>) -> LuaVec4

				///Writes the elements of `self` to the first 4 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 4 elements long.
				write_to_slice(self<invalid: &mut [f32]>)

				// Exclusion reason: 
				// ///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
				// ///
				// ///Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.
				// ///
				// ///To truncate to `Vec3A` use `Vec3A::from()`.
				// truncate(self) -> LuaVec3

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaVec4) -> f32

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaVec4LuaVec4) -> LuaVec4

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> f32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> f32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaVec4)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaVec4)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaVec4)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaVec4)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaVec4)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaVec4)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaVec4

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.  If any element is either
				// ///`NaN`, positive or negative infinity, this will return `false`.
				// is_finite(self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(self) -> bool

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self)

				// Exclusion reason: 
				// ///Computes the length of `self`.
				// length(self) -> f32

				// Exclusion reason: 
				// ///Computes the squared length of `self`.
				// ///
				// ///This is faster than `length()` as it avoids a square root operation.
				// length_squared(self) -> f32

				// Exclusion reason: 
				// ///Computes `1.0 / length()`.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// length_recip(self) -> f32

				// Exclusion reason: 
				// ///Computes the Euclidean distance between two points in space.
				// distance(selfLuaVec4) -> f32

				// Exclusion reason: 
				// ///Compute the squared euclidean distance between two points in space.
				// distance_squared(selfLuaVec4) -> f32

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0.
				// ///
				// ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				// ///
				// ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				// ///
				// ///Panics
				// ///
				// ///Will panic if `self` is zero length when `glam_assert` is enabled.
				// normalize(self) -> LuaVec4

				///Returns `self` normalized to length 1.0 if possible, else returns `None`.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be `None`.
				///
				///See also [`Self::normalize_or_zero`].
				try_normalize(self)

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0 if possible, else returns zero.
				// ///
				// ///In particular, if the input is zero (or very close to zero), or non-finite,
				// ///the result of this operation will be zero.
				// ///
				// ///See also [`Self::try_normalize`].
				// normalize_or_zero(self) -> LuaVec4

				// Exclusion reason: 
				// ///Returns whether `self` is length `1.0` or not.
				// ///
				// ///Uses a precision threshold of `1e-6`.
				// is_normalized(self) -> bool

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				// project_onto(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				// reject_from(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// project_onto_normalized(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// reject_from_normalized(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector containing the nearest integer to a number for each element of `self`.
				// ///Round half-way cases away from 0.0.
				// round(self) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector containing the largest integer less than or equal to a number for each
				// ///element of `self`.
				// floor(self) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector containing the smallest integer greater than or equal to a number for
				// ///each element of `self`.
				// ceil(self) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector containing the fractional part of the vector, e.g. `self -
				// ///self.floor()`.
				// ///
				// ///Note that this is fast but not precise for large numbers.
				// fract(self) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector containing `e^self` (the exponential function) for each element of
				// ///`self`.
				// exp(self) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector containing each element of `self` raised to the power of `n`.
				// powf(selff32) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				// recip(self) -> LuaVec4

				// Exclusion reason: 
				// ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				// ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				// ///extrapolated.
				// lerp(selfLuaVec4f32) -> LuaVec4

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs` is
				// ///less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two vectors contain similar elements. It works best when
				// ///comparing with a known value. The `max_abs_diff` that should be used used depends on
				// ///the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(selfLuaVec4f32) -> bool

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min` and no more than `max`
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp_length(selff32f32) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector with a length no more than `max`
				// clamp_length_max(selff32) -> LuaVec4

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min`
				// clamp_length_min(selff32) -> LuaVec4

				// Exclusion reason: 
				// ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				// ///error, yielding a more accurate result than an unfused multiply-add.
				// ///
				// ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				// ///architecture has a dedicated fma CPU instruction. However, this is not always true,
				// ///and will be heavily dependant on designing algorithms with specific target hardware in
				// ///mind.
				// mul_add(selfLuaVec4LuaVec4) -> LuaVec4

				///Casts all elements of `self` to `f64`.
				as_dvec4(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec4(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec4(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				// Exclusion reason: 
				// from(LuaQuat) -> LuaVec4

				// Exclusion reason: 
				// ///Creates a `Vec3A` from the `x`, `y` and `z` elements of `self` discarding `w`.
				// ///
				// ///On architectures where SIMD is supported such as SSE2 on `x86_64` this conversion is a noop.
				// from(LuaVec4) -> LuaVec4

				// Exclusion reason: 
				// from(LuaVec4) -> LuaVec4

				from() -> LuaVec4

				from(<invalid: [f32;4]>) -> LuaVec4

				// Exclusion reason: 
				// from(LuaVec4) -> LuaVec4

				from(<invalid: (f32,f32,f32,f32)>) -> LuaVec4

				// Exclusion reason: 
				// from(LuaVec4) -> LuaVec4

				from() -> LuaVec4

				from() -> LuaVec4

				from(<invalid: (LuaVec3,f32)>) -> LuaVec4

				from(<invalid: (f32,LuaVec3)>) -> LuaVec4

				from(<invalid: (LuaVec2,f32,f32)>) -> LuaVec4

				from(<invalid: (LuaVec2,LuaVec2)>) -> LuaVec4

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaVec4)

				// Exclusion reason: 
				// mul(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// mul(selff32) -> LuaVec4

				// Exclusion reason: 
				// mul(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// clone(&self) -> LuaVec4

				// Exclusion reason: 
				// default() -> LuaVec4

				// Exclusion reason: 
				// eq(&self&LuaVec4) -> bool

				// Exclusion reason: 
				// div(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// div(selff32) -> LuaVec4

				// Exclusion reason: 
				// div(selfLuaVec4) -> LuaVec4

				div_assign(<invalid: &mut self>LuaVec4)

				div_assign(<invalid: &mut self>f32)

				mul_assign(<invalid: &mut self>LuaVec4)

				mul_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// add(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// add(selff32) -> LuaVec4

				// Exclusion reason: 
				// add(selfLuaVec4) -> LuaVec4

				add_assign(<invalid: &mut self>LuaVec4)

				add_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// sub(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// sub(selff32) -> LuaVec4

				// Exclusion reason: 
				// sub(selfLuaVec4) -> LuaVec4

				sub_assign(<invalid: &mut self>LuaVec4)

				sub_assign(<invalid: &mut self>f32)

				// Exclusion reason: 
				// rem(selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// rem(selff32) -> LuaVec4

				// Exclusion reason: 
				// rem(selfLuaVec4) -> LuaVec4

				rem_assign(<invalid: &mut self>LuaVec4)

				rem_assign(<invalid: &mut self>f32)

				as_ref(&self)<invalid: &[f32;4]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f32;4]>

				sum() -> LuaVec4

				product() -> LuaVec4

				// Exclusion reason: 
				// neg(self) -> LuaVec4

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				deref(&self)

				deref_mut(<invalid: &mut self>)

				// Exclusion reason: 
				// xx(self) -> LuaVec2

				// Exclusion reason: 
				// xy(self) -> LuaVec2

				// Exclusion reason: 
				// xz(self) -> LuaVec2

				// Exclusion reason: 
				// xw(self) -> LuaVec2

				// Exclusion reason: 
				// yx(self) -> LuaVec2

				// Exclusion reason: 
				// yy(self) -> LuaVec2

				// Exclusion reason: 
				// yz(self) -> LuaVec2

				// Exclusion reason: 
				// yw(self) -> LuaVec2

				// Exclusion reason: 
				// zx(self) -> LuaVec2

				// Exclusion reason: 
				// zy(self) -> LuaVec2

				// Exclusion reason: 
				// zz(self) -> LuaVec2

				// Exclusion reason: 
				// zw(self) -> LuaVec2

				// Exclusion reason: 
				// wx(self) -> LuaVec2

				// Exclusion reason: 
				// wy(self) -> LuaVec2

				// Exclusion reason: 
				// wz(self) -> LuaVec2

				// Exclusion reason: 
				// ww(self) -> LuaVec2

				// Exclusion reason: 
				// xxx(self) -> LuaVec3

				// Exclusion reason: 
				// xxy(self) -> LuaVec3

				// Exclusion reason: 
				// xxz(self) -> LuaVec3

				// Exclusion reason: 
				// xxw(self) -> LuaVec3

				// Exclusion reason: 
				// xyx(self) -> LuaVec3

				// Exclusion reason: 
				// xyy(self) -> LuaVec3

				// Exclusion reason: 
				// xyz(self) -> LuaVec3

				// Exclusion reason: 
				// xyw(self) -> LuaVec3

				// Exclusion reason: 
				// xzx(self) -> LuaVec3

				// Exclusion reason: 
				// xzy(self) -> LuaVec3

				// Exclusion reason: 
				// xzz(self) -> LuaVec3

				// Exclusion reason: 
				// xzw(self) -> LuaVec3

				// Exclusion reason: 
				// xwx(self) -> LuaVec3

				// Exclusion reason: 
				// xwy(self) -> LuaVec3

				// Exclusion reason: 
				// xwz(self) -> LuaVec3

				// Exclusion reason: 
				// xww(self) -> LuaVec3

				// Exclusion reason: 
				// yxx(self) -> LuaVec3

				// Exclusion reason: 
				// yxy(self) -> LuaVec3

				// Exclusion reason: 
				// yxz(self) -> LuaVec3

				// Exclusion reason: 
				// yxw(self) -> LuaVec3

				// Exclusion reason: 
				// yyx(self) -> LuaVec3

				// Exclusion reason: 
				// yyy(self) -> LuaVec3

				// Exclusion reason: 
				// yyz(self) -> LuaVec3

				// Exclusion reason: 
				// yyw(self) -> LuaVec3

				// Exclusion reason: 
				// yzx(self) -> LuaVec3

				// Exclusion reason: 
				// yzy(self) -> LuaVec3

				// Exclusion reason: 
				// yzz(self) -> LuaVec3

				// Exclusion reason: 
				// yzw(self) -> LuaVec3

				// Exclusion reason: 
				// ywx(self) -> LuaVec3

				// Exclusion reason: 
				// ywy(self) -> LuaVec3

				// Exclusion reason: 
				// ywz(self) -> LuaVec3

				// Exclusion reason: 
				// yww(self) -> LuaVec3

				// Exclusion reason: 
				// zxx(self) -> LuaVec3

				// Exclusion reason: 
				// zxy(self) -> LuaVec3

				// Exclusion reason: 
				// zxz(self) -> LuaVec3

				// Exclusion reason: 
				// zxw(self) -> LuaVec3

				// Exclusion reason: 
				// zyx(self) -> LuaVec3

				// Exclusion reason: 
				// zyy(self) -> LuaVec3

				// Exclusion reason: 
				// zyz(self) -> LuaVec3

				// Exclusion reason: 
				// zyw(self) -> LuaVec3

				// Exclusion reason: 
				// zzx(self) -> LuaVec3

				// Exclusion reason: 
				// zzy(self) -> LuaVec3

				// Exclusion reason: 
				// zzz(self) -> LuaVec3

				// Exclusion reason: 
				// zzw(self) -> LuaVec3

				// Exclusion reason: 
				// zwx(self) -> LuaVec3

				// Exclusion reason: 
				// zwy(self) -> LuaVec3

				// Exclusion reason: 
				// zwz(self) -> LuaVec3

				// Exclusion reason: 
				// zww(self) -> LuaVec3

				// Exclusion reason: 
				// wxx(self) -> LuaVec3

				// Exclusion reason: 
				// wxy(self) -> LuaVec3

				// Exclusion reason: 
				// wxz(self) -> LuaVec3

				// Exclusion reason: 
				// wxw(self) -> LuaVec3

				// Exclusion reason: 
				// wyx(self) -> LuaVec3

				// Exclusion reason: 
				// wyy(self) -> LuaVec3

				// Exclusion reason: 
				// wyz(self) -> LuaVec3

				// Exclusion reason: 
				// wyw(self) -> LuaVec3

				// Exclusion reason: 
				// wzx(self) -> LuaVec3

				// Exclusion reason: 
				// wzy(self) -> LuaVec3

				// Exclusion reason: 
				// wzz(self) -> LuaVec3

				// Exclusion reason: 
				// wzw(self) -> LuaVec3

				// Exclusion reason: 
				// wwx(self) -> LuaVec3

				// Exclusion reason: 
				// wwy(self) -> LuaVec3

				// Exclusion reason: 
				// wwz(self) -> LuaVec3

				// Exclusion reason: 
				// www(self) -> LuaVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaVec4

				// Exclusion reason: 
				// xxxz(self) -> LuaVec4

				// Exclusion reason: 
				// xxxw(self) -> LuaVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaVec4

				// Exclusion reason: 
				// xxyz(self) -> LuaVec4

				// Exclusion reason: 
				// xxyw(self) -> LuaVec4

				// Exclusion reason: 
				// xxzx(self) -> LuaVec4

				// Exclusion reason: 
				// xxzy(self) -> LuaVec4

				// Exclusion reason: 
				// xxzz(self) -> LuaVec4

				// Exclusion reason: 
				// xxzw(self) -> LuaVec4

				// Exclusion reason: 
				// xxwx(self) -> LuaVec4

				// Exclusion reason: 
				// xxwy(self) -> LuaVec4

				// Exclusion reason: 
				// xxwz(self) -> LuaVec4

				// Exclusion reason: 
				// xxww(self) -> LuaVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaVec4

				// Exclusion reason: 
				// xyxz(self) -> LuaVec4

				// Exclusion reason: 
				// xyxw(self) -> LuaVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaVec4

				// Exclusion reason: 
				// xyyz(self) -> LuaVec4

				// Exclusion reason: 
				// xyyw(self) -> LuaVec4

				// Exclusion reason: 
				// xyzx(self) -> LuaVec4

				// Exclusion reason: 
				// xyzy(self) -> LuaVec4

				// Exclusion reason: 
				// xyzz(self) -> LuaVec4

				// Exclusion reason: 
				// xyzw(self) -> LuaVec4

				// Exclusion reason: 
				// xywx(self) -> LuaVec4

				// Exclusion reason: 
				// xywy(self) -> LuaVec4

				// Exclusion reason: 
				// xywz(self) -> LuaVec4

				// Exclusion reason: 
				// xyww(self) -> LuaVec4

				// Exclusion reason: 
				// xzxx(self) -> LuaVec4

				// Exclusion reason: 
				// xzxy(self) -> LuaVec4

				// Exclusion reason: 
				// xzxz(self) -> LuaVec4

				// Exclusion reason: 
				// xzxw(self) -> LuaVec4

				// Exclusion reason: 
				// xzyx(self) -> LuaVec4

				// Exclusion reason: 
				// xzyy(self) -> LuaVec4

				// Exclusion reason: 
				// xzyz(self) -> LuaVec4

				// Exclusion reason: 
				// xzyw(self) -> LuaVec4

				// Exclusion reason: 
				// xzzx(self) -> LuaVec4

				// Exclusion reason: 
				// xzzy(self) -> LuaVec4

				// Exclusion reason: 
				// xzzz(self) -> LuaVec4

				// Exclusion reason: 
				// xzzw(self) -> LuaVec4

				// Exclusion reason: 
				// xzwx(self) -> LuaVec4

				// Exclusion reason: 
				// xzwy(self) -> LuaVec4

				// Exclusion reason: 
				// xzwz(self) -> LuaVec4

				// Exclusion reason: 
				// xzww(self) -> LuaVec4

				// Exclusion reason: 
				// xwxx(self) -> LuaVec4

				// Exclusion reason: 
				// xwxy(self) -> LuaVec4

				// Exclusion reason: 
				// xwxz(self) -> LuaVec4

				// Exclusion reason: 
				// xwxw(self) -> LuaVec4

				// Exclusion reason: 
				// xwyx(self) -> LuaVec4

				// Exclusion reason: 
				// xwyy(self) -> LuaVec4

				// Exclusion reason: 
				// xwyz(self) -> LuaVec4

				// Exclusion reason: 
				// xwyw(self) -> LuaVec4

				// Exclusion reason: 
				// xwzx(self) -> LuaVec4

				// Exclusion reason: 
				// xwzy(self) -> LuaVec4

				// Exclusion reason: 
				// xwzz(self) -> LuaVec4

				// Exclusion reason: 
				// xwzw(self) -> LuaVec4

				// Exclusion reason: 
				// xwwx(self) -> LuaVec4

				// Exclusion reason: 
				// xwwy(self) -> LuaVec4

				// Exclusion reason: 
				// xwwz(self) -> LuaVec4

				// Exclusion reason: 
				// xwww(self) -> LuaVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaVec4

				// Exclusion reason: 
				// yxxz(self) -> LuaVec4

				// Exclusion reason: 
				// yxxw(self) -> LuaVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaVec4

				// Exclusion reason: 
				// yxyz(self) -> LuaVec4

				// Exclusion reason: 
				// yxyw(self) -> LuaVec4

				// Exclusion reason: 
				// yxzx(self) -> LuaVec4

				// Exclusion reason: 
				// yxzy(self) -> LuaVec4

				// Exclusion reason: 
				// yxzz(self) -> LuaVec4

				// Exclusion reason: 
				// yxzw(self) -> LuaVec4

				// Exclusion reason: 
				// yxwx(self) -> LuaVec4

				// Exclusion reason: 
				// yxwy(self) -> LuaVec4

				// Exclusion reason: 
				// yxwz(self) -> LuaVec4

				// Exclusion reason: 
				// yxww(self) -> LuaVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaVec4

				// Exclusion reason: 
				// yyxz(self) -> LuaVec4

				// Exclusion reason: 
				// yyxw(self) -> LuaVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaVec4

				// Exclusion reason: 
				// yyyz(self) -> LuaVec4

				// Exclusion reason: 
				// yyyw(self) -> LuaVec4

				// Exclusion reason: 
				// yyzx(self) -> LuaVec4

				// Exclusion reason: 
				// yyzy(self) -> LuaVec4

				// Exclusion reason: 
				// yyzz(self) -> LuaVec4

				// Exclusion reason: 
				// yyzw(self) -> LuaVec4

				// Exclusion reason: 
				// yywx(self) -> LuaVec4

				// Exclusion reason: 
				// yywy(self) -> LuaVec4

				// Exclusion reason: 
				// yywz(self) -> LuaVec4

				// Exclusion reason: 
				// yyww(self) -> LuaVec4

				// Exclusion reason: 
				// yzxx(self) -> LuaVec4

				// Exclusion reason: 
				// yzxy(self) -> LuaVec4

				// Exclusion reason: 
				// yzxz(self) -> LuaVec4

				// Exclusion reason: 
				// yzxw(self) -> LuaVec4

				// Exclusion reason: 
				// yzyx(self) -> LuaVec4

				// Exclusion reason: 
				// yzyy(self) -> LuaVec4

				// Exclusion reason: 
				// yzyz(self) -> LuaVec4

				// Exclusion reason: 
				// yzyw(self) -> LuaVec4

				// Exclusion reason: 
				// yzzx(self) -> LuaVec4

				// Exclusion reason: 
				// yzzy(self) -> LuaVec4

				// Exclusion reason: 
				// yzzz(self) -> LuaVec4

				// Exclusion reason: 
				// yzzw(self) -> LuaVec4

				// Exclusion reason: 
				// yzwx(self) -> LuaVec4

				// Exclusion reason: 
				// yzwy(self) -> LuaVec4

				// Exclusion reason: 
				// yzwz(self) -> LuaVec4

				// Exclusion reason: 
				// yzww(self) -> LuaVec4

				// Exclusion reason: 
				// ywxx(self) -> LuaVec4

				// Exclusion reason: 
				// ywxy(self) -> LuaVec4

				// Exclusion reason: 
				// ywxz(self) -> LuaVec4

				// Exclusion reason: 
				// ywxw(self) -> LuaVec4

				// Exclusion reason: 
				// ywyx(self) -> LuaVec4

				// Exclusion reason: 
				// ywyy(self) -> LuaVec4

				// Exclusion reason: 
				// ywyz(self) -> LuaVec4

				// Exclusion reason: 
				// ywyw(self) -> LuaVec4

				// Exclusion reason: 
				// ywzx(self) -> LuaVec4

				// Exclusion reason: 
				// ywzy(self) -> LuaVec4

				// Exclusion reason: 
				// ywzz(self) -> LuaVec4

				// Exclusion reason: 
				// ywzw(self) -> LuaVec4

				// Exclusion reason: 
				// ywwx(self) -> LuaVec4

				// Exclusion reason: 
				// ywwy(self) -> LuaVec4

				// Exclusion reason: 
				// ywwz(self) -> LuaVec4

				// Exclusion reason: 
				// ywww(self) -> LuaVec4

				// Exclusion reason: 
				// zxxx(self) -> LuaVec4

				// Exclusion reason: 
				// zxxy(self) -> LuaVec4

				// Exclusion reason: 
				// zxxz(self) -> LuaVec4

				// Exclusion reason: 
				// zxxw(self) -> LuaVec4

				// Exclusion reason: 
				// zxyx(self) -> LuaVec4

				// Exclusion reason: 
				// zxyy(self) -> LuaVec4

				// Exclusion reason: 
				// zxyz(self) -> LuaVec4

				// Exclusion reason: 
				// zxyw(self) -> LuaVec4

				// Exclusion reason: 
				// zxzx(self) -> LuaVec4

				// Exclusion reason: 
				// zxzy(self) -> LuaVec4

				// Exclusion reason: 
				// zxzz(self) -> LuaVec4

				// Exclusion reason: 
				// zxzw(self) -> LuaVec4

				// Exclusion reason: 
				// zxwx(self) -> LuaVec4

				// Exclusion reason: 
				// zxwy(self) -> LuaVec4

				// Exclusion reason: 
				// zxwz(self) -> LuaVec4

				// Exclusion reason: 
				// zxww(self) -> LuaVec4

				// Exclusion reason: 
				// zyxx(self) -> LuaVec4

				// Exclusion reason: 
				// zyxy(self) -> LuaVec4

				// Exclusion reason: 
				// zyxz(self) -> LuaVec4

				// Exclusion reason: 
				// zyxw(self) -> LuaVec4

				// Exclusion reason: 
				// zyyx(self) -> LuaVec4

				// Exclusion reason: 
				// zyyy(self) -> LuaVec4

				// Exclusion reason: 
				// zyyz(self) -> LuaVec4

				// Exclusion reason: 
				// zyyw(self) -> LuaVec4

				// Exclusion reason: 
				// zyzx(self) -> LuaVec4

				// Exclusion reason: 
				// zyzy(self) -> LuaVec4

				// Exclusion reason: 
				// zyzz(self) -> LuaVec4

				// Exclusion reason: 
				// zyzw(self) -> LuaVec4

				// Exclusion reason: 
				// zywx(self) -> LuaVec4

				// Exclusion reason: 
				// zywy(self) -> LuaVec4

				// Exclusion reason: 
				// zywz(self) -> LuaVec4

				// Exclusion reason: 
				// zyww(self) -> LuaVec4

				// Exclusion reason: 
				// zzxx(self) -> LuaVec4

				// Exclusion reason: 
				// zzxy(self) -> LuaVec4

				// Exclusion reason: 
				// zzxz(self) -> LuaVec4

				// Exclusion reason: 
				// zzxw(self) -> LuaVec4

				// Exclusion reason: 
				// zzyx(self) -> LuaVec4

				// Exclusion reason: 
				// zzyy(self) -> LuaVec4

				// Exclusion reason: 
				// zzyz(self) -> LuaVec4

				// Exclusion reason: 
				// zzyw(self) -> LuaVec4

				// Exclusion reason: 
				// zzzx(self) -> LuaVec4

				// Exclusion reason: 
				// zzzy(self) -> LuaVec4

				// Exclusion reason: 
				// zzzz(self) -> LuaVec4

				// Exclusion reason: 
				// zzzw(self) -> LuaVec4

				// Exclusion reason: 
				// zzwx(self) -> LuaVec4

				// Exclusion reason: 
				// zzwy(self) -> LuaVec4

				// Exclusion reason: 
				// zzwz(self) -> LuaVec4

				// Exclusion reason: 
				// zzww(self) -> LuaVec4

				// Exclusion reason: 
				// zwxx(self) -> LuaVec4

				// Exclusion reason: 
				// zwxy(self) -> LuaVec4

				// Exclusion reason: 
				// zwxz(self) -> LuaVec4

				// Exclusion reason: 
				// zwxw(self) -> LuaVec4

				// Exclusion reason: 
				// zwyx(self) -> LuaVec4

				// Exclusion reason: 
				// zwyy(self) -> LuaVec4

				// Exclusion reason: 
				// zwyz(self) -> LuaVec4

				// Exclusion reason: 
				// zwyw(self) -> LuaVec4

				// Exclusion reason: 
				// zwzx(self) -> LuaVec4

				// Exclusion reason: 
				// zwzy(self) -> LuaVec4

				// Exclusion reason: 
				// zwzz(self) -> LuaVec4

				// Exclusion reason: 
				// zwzw(self) -> LuaVec4

				// Exclusion reason: 
				// zwwx(self) -> LuaVec4

				// Exclusion reason: 
				// zwwy(self) -> LuaVec4

				// Exclusion reason: 
				// zwwz(self) -> LuaVec4

				// Exclusion reason: 
				// zwww(self) -> LuaVec4

				// Exclusion reason: 
				// wxxx(self) -> LuaVec4

				// Exclusion reason: 
				// wxxy(self) -> LuaVec4

				// Exclusion reason: 
				// wxxz(self) -> LuaVec4

				// Exclusion reason: 
				// wxxw(self) -> LuaVec4

				// Exclusion reason: 
				// wxyx(self) -> LuaVec4

				// Exclusion reason: 
				// wxyy(self) -> LuaVec4

				// Exclusion reason: 
				// wxyz(self) -> LuaVec4

				// Exclusion reason: 
				// wxyw(self) -> LuaVec4

				// Exclusion reason: 
				// wxzx(self) -> LuaVec4

				// Exclusion reason: 
				// wxzy(self) -> LuaVec4

				// Exclusion reason: 
				// wxzz(self) -> LuaVec4

				// Exclusion reason: 
				// wxzw(self) -> LuaVec4

				// Exclusion reason: 
				// wxwx(self) -> LuaVec4

				// Exclusion reason: 
				// wxwy(self) -> LuaVec4

				// Exclusion reason: 
				// wxwz(self) -> LuaVec4

				// Exclusion reason: 
				// wxww(self) -> LuaVec4

				// Exclusion reason: 
				// wyxx(self) -> LuaVec4

				// Exclusion reason: 
				// wyxy(self) -> LuaVec4

				// Exclusion reason: 
				// wyxz(self) -> LuaVec4

				// Exclusion reason: 
				// wyxw(self) -> LuaVec4

				// Exclusion reason: 
				// wyyx(self) -> LuaVec4

				// Exclusion reason: 
				// wyyy(self) -> LuaVec4

				// Exclusion reason: 
				// wyyz(self) -> LuaVec4

				// Exclusion reason: 
				// wyyw(self) -> LuaVec4

				// Exclusion reason: 
				// wyzx(self) -> LuaVec4

				// Exclusion reason: 
				// wyzy(self) -> LuaVec4

				// Exclusion reason: 
				// wyzz(self) -> LuaVec4

				// Exclusion reason: 
				// wyzw(self) -> LuaVec4

				// Exclusion reason: 
				// wywx(self) -> LuaVec4

				// Exclusion reason: 
				// wywy(self) -> LuaVec4

				// Exclusion reason: 
				// wywz(self) -> LuaVec4

				// Exclusion reason: 
				// wyww(self) -> LuaVec4

				// Exclusion reason: 
				// wzxx(self) -> LuaVec4

				// Exclusion reason: 
				// wzxy(self) -> LuaVec4

				// Exclusion reason: 
				// wzxz(self) -> LuaVec4

				// Exclusion reason: 
				// wzxw(self) -> LuaVec4

				// Exclusion reason: 
				// wzyx(self) -> LuaVec4

				// Exclusion reason: 
				// wzyy(self) -> LuaVec4

				// Exclusion reason: 
				// wzyz(self) -> LuaVec4

				// Exclusion reason: 
				// wzyw(self) -> LuaVec4

				// Exclusion reason: 
				// wzzx(self) -> LuaVec4

				// Exclusion reason: 
				// wzzy(self) -> LuaVec4

				// Exclusion reason: 
				// wzzz(self) -> LuaVec4

				// Exclusion reason: 
				// wzzw(self) -> LuaVec4

				// Exclusion reason: 
				// wzwx(self) -> LuaVec4

				// Exclusion reason: 
				// wzwy(self) -> LuaVec4

				// Exclusion reason: 
				// wzwz(self) -> LuaVec4

				// Exclusion reason: 
				// wzww(self) -> LuaVec4

				// Exclusion reason: 
				// wwxx(self) -> LuaVec4

				// Exclusion reason: 
				// wwxy(self) -> LuaVec4

				// Exclusion reason: 
				// wwxz(self) -> LuaVec4

				// Exclusion reason: 
				// wwxw(self) -> LuaVec4

				// Exclusion reason: 
				// wwyx(self) -> LuaVec4

				// Exclusion reason: 
				// wwyy(self) -> LuaVec4

				// Exclusion reason: 
				// wwyz(self) -> LuaVec4

				// Exclusion reason: 
				// wwyw(self) -> LuaVec4

				// Exclusion reason: 
				// wwzx(self) -> LuaVec4

				// Exclusion reason: 
				// wwzy(self) -> LuaVec4

				// Exclusion reason: 
				// wwzz(self) -> LuaVec4

				// Exclusion reason: 
				// wwzw(self) -> LuaVec4

				// Exclusion reason: 
				// wwwx(self) -> LuaVec4

				// Exclusion reason: 
				// wwwy(self) -> LuaVec4

				// Exclusion reason: 
				// wwwz(self) -> LuaVec4

				// Exclusion reason: 
				// wwww(self) -> LuaVec4

			)
+ BinaryOps			(
self Add LuaVec4 -> LuaVec4 -> LuaVec4
self Add f32 -> LuaVec4 -> LuaVec4
f32 Add self -> LuaVec4 -> LuaVec4
self Sub LuaVec4 -> LuaVec4 -> LuaVec4
self Sub f32 -> LuaVec4 -> LuaVec4
f32 Sub self -> LuaVec4 -> LuaVec4
self Div LuaVec4 -> LuaVec4 -> LuaVec4
self Div f32 -> LuaVec4 -> LuaVec4
f32 Div self -> LuaVec4 -> LuaVec4
self Mul LuaVec4 -> LuaVec4 -> LuaVec4
self Mul f32 -> LuaVec4 -> LuaVec4
f32 Mul self -> LuaVec4 -> LuaVec4
self Rem LuaVec4 -> LuaVec4 -> LuaVec4
self Rem f32 -> LuaVec4 -> LuaVec4
f32 Rem self -> LuaVec4 -> LuaVec4
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaVec4),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f32))
			    
impl			{
			}
		}
		{
			///A 2-dimensional vector.
glam::f64::dvec2::DVec2 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(f64f64) -> LuaDVec2

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(f64) -> LuaDVec2

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaDVec2LuaDVec2) -> LuaDVec2

				///Creates a new vector from an array.
				from_array(<invalid: [f64;2]>) -> LuaDVec2

				///`[x, y]`
				to_array(&self)<invalid: [f64;2]>

				///Creates a vector from the first 2 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 2 elements long.
				from_slice(<invalid: &[f64]>) -> LuaDVec2

				///Writes the elements of `self` to the first 2 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 2 elements long.
				write_to_slice(self<invalid: &mut [f64]>)

				// Exclusion reason: 
				// ///Creates a 3D vector from `self` and the given `z` value.
				// extend(selff64) -> LuaDVec3

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaDVec2) -> f64

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaDVec2LuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> f64

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> f64

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaDVec2)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaDVec2)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaDVec2)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaDVec2)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaDVec2)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaDVec2)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.  If any element is either
				// ///`NaN`, positive or negative infinity, this will return `false`.
				// is_finite(self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(self) -> bool

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self)

				// Exclusion reason: 
				// ///Computes the length of `self`.
				// length(self) -> f64

				// Exclusion reason: 
				// ///Computes the squared length of `self`.
				// ///
				// ///This is faster than `length()` as it avoids a square root operation.
				// length_squared(self) -> f64

				// Exclusion reason: 
				// ///Computes `1.0 / length()`.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// length_recip(self) -> f64

				// Exclusion reason: 
				// ///Computes the Euclidean distance between two points in space.
				// distance(selfLuaDVec2) -> f64

				// Exclusion reason: 
				// ///Compute the squared euclidean distance between two points in space.
				// distance_squared(selfLuaDVec2) -> f64

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0.
				// ///
				// ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				// ///
				// ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				// ///
				// ///Panics
				// ///
				// ///Will panic if `self` is zero length when `glam_assert` is enabled.
				// normalize(self) -> LuaDVec2

				///Returns `self` normalized to length 1.0 if possible, else returns `None`.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be `None`.
				///
				///See also [`Self::normalize_or_zero`].
				try_normalize(self)

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0 if possible, else returns zero.
				// ///
				// ///In particular, if the input is zero (or very close to zero), or non-finite,
				// ///the result of this operation will be zero.
				// ///
				// ///See also [`Self::try_normalize`].
				// normalize_or_zero(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns whether `self` is length `1.0` or not.
				// ///
				// ///Uses a precision threshold of `1e-6`.
				// is_normalized(self) -> bool

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				// project_onto(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				// reject_from(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// project_onto_normalized(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// reject_from_normalized(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector containing the nearest integer to a number for each element of `self`.
				// ///Round half-way cases away from 0.0.
				// round(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector containing the largest integer less than or equal to a number for each
				// ///element of `self`.
				// floor(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector containing the smallest integer greater than or equal to a number for
				// ///each element of `self`.
				// ceil(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector containing the fractional part of the vector, e.g. `self -
				// ///self.floor()`.
				// ///
				// ///Note that this is fast but not precise for large numbers.
				// fract(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector containing `e^self` (the exponential function) for each element of
				// ///`self`.
				// exp(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector containing each element of `self` raised to the power of `n`.
				// powf(selff64) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				// recip(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				// ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				// ///extrapolated.
				// lerp(selfLuaDVec2f64) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs` is
				// ///less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two vectors contain similar elements. It works best when
				// ///comparing with a known value. The `max_abs_diff` that should be used used depends on
				// ///the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(selfLuaDVec2f64) -> bool

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min` and no more than `max`
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp_length(selff64f64) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector with a length no more than `max`
				// clamp_length_max(selff64) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min`
				// clamp_length_min(selff64) -> LuaDVec2

				// Exclusion reason: 
				// ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				// ///error, yielding a more accurate result than an unfused multiply-add.
				// ///
				// ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				// ///architecture has a dedicated fma CPU instruction. However, this is not always true,
				// ///and will be heavily dependant on designing algorithms with specific target hardware in
				// ///mind.
				// mul_add(selfLuaDVec2LuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
				// ///conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will
				// ///create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.
				// from_angle(f64) -> LuaDVec2

				// Exclusion reason: 
				// ///Returns the angle (in radians) between `self` and `rhs`.
				// ///
				// ///The input vectors do not need to be unit length however they must be non-zero.
				// angle_between(selfLuaDVec2) -> f64

				// Exclusion reason: 
				// ///Returns a vector that is equal to `self` rotated by 90 degrees.
				// perp(self) -> LuaDVec2

				// Exclusion reason: 
				// ///The perpendicular dot product of `self` and `rhs`.
				// ///Also known as the wedge product, 2D cross product, and determinant.
				// perp_dot(selfLuaDVec2) -> f64

				// Exclusion reason: 
				// ///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
				// ///then this just rotation. This is what you usually want. Otherwise,
				// ///it will be like a rotation with a multiplication by `self`'s length.
				// rotate(selfLuaDVec2) -> LuaDVec2

				///Casts all elements of `self` to `f32`.
				as_vec2(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec2(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec2(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [f64;2]>) -> LuaDVec2

				// Exclusion reason: 
				// from(LuaDVec2) -> LuaDVec2

				from(<invalid: (f64,f64)>) -> LuaDVec2

				// Exclusion reason: 
				// from(LuaDVec2) -> LuaDVec2

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaDVec2)

				// Exclusion reason: 
				// mul(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// mul(selff64) -> LuaDVec2

				// Exclusion reason: 
				// mul(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// clone(&self) -> LuaDVec2

				// Exclusion reason: 
				// default() -> LuaDVec2

				// Exclusion reason: 
				// eq(&self&LuaDVec2) -> bool

				// Exclusion reason: 
				// div(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// div(selff64) -> LuaDVec2

				// Exclusion reason: 
				// div(selfLuaDVec2) -> LuaDVec2

				div_assign(<invalid: &mut self>LuaDVec2)

				div_assign(<invalid: &mut self>f64)

				mul_assign(<invalid: &mut self>LuaDVec2)

				mul_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// add(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// add(selff64) -> LuaDVec2

				// Exclusion reason: 
				// add(selfLuaDVec2) -> LuaDVec2

				add_assign(<invalid: &mut self>LuaDVec2)

				add_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// sub(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// sub(selff64) -> LuaDVec2

				// Exclusion reason: 
				// sub(selfLuaDVec2) -> LuaDVec2

				sub_assign(<invalid: &mut self>LuaDVec2)

				sub_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// rem(selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// rem(selff64) -> LuaDVec2

				// Exclusion reason: 
				// rem(selfLuaDVec2) -> LuaDVec2

				rem_assign(<invalid: &mut self>LuaDVec2)

				rem_assign(<invalid: &mut self>f64)

				as_ref(&self)<invalid: &[f64;2]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f64;2]>

				sum() -> LuaDVec2

				product() -> LuaDVec2

				// Exclusion reason: 
				// neg(self) -> LuaDVec2

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaDVec2

				// Exclusion reason: 
				// xy(self) -> LuaDVec2

				// Exclusion reason: 
				// yx(self) -> LuaDVec2

				// Exclusion reason: 
				// yy(self) -> LuaDVec2

				// Exclusion reason: 
				// xxx(self) -> LuaDVec3

				// Exclusion reason: 
				// xxy(self) -> LuaDVec3

				// Exclusion reason: 
				// xyx(self) -> LuaDVec3

				// Exclusion reason: 
				// xyy(self) -> LuaDVec3

				// Exclusion reason: 
				// yxx(self) -> LuaDVec3

				// Exclusion reason: 
				// yxy(self) -> LuaDVec3

				// Exclusion reason: 
				// yyx(self) -> LuaDVec3

				// Exclusion reason: 
				// yyy(self) -> LuaDVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaDVec4

			)
+ BinaryOps			(
self Add LuaDVec2 -> LuaDVec2 -> LuaDVec2
self Add f64 -> LuaDVec2 -> LuaDVec2
f64 Add self -> LuaDVec2 -> LuaDVec2
self Sub LuaDVec2 -> LuaDVec2 -> LuaDVec2
self Sub f64 -> LuaDVec2 -> LuaDVec2
f64 Sub self -> LuaDVec2 -> LuaDVec2
self Div LuaDVec2 -> LuaDVec2 -> LuaDVec2
self Div f64 -> LuaDVec2 -> LuaDVec2
f64 Div self -> LuaDVec2 -> LuaDVec2
self Mul LuaDVec2 -> LuaDVec2 -> LuaDVec2
self Mul f64 -> LuaDVec2 -> LuaDVec2
f64 Mul self -> LuaDVec2 -> LuaDVec2
self Rem LuaDVec2 -> LuaDVec2 -> LuaDVec2
self Rem f64 -> LuaDVec2 -> LuaDVec2
f64 Rem self -> LuaDVec2 -> LuaDVec2
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaDVec2),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f64))
			    
impl			{
			}
		}
		{
			///A 3-dimensional vector.
glam::f64::dvec3::DVec3 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(f64f64f64) -> LuaDVec3

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(f64) -> LuaDVec3

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaDVec3LuaDVec3) -> LuaDVec3

				///Creates a new vector from an array.
				from_array(<invalid: [f64;3]>) -> LuaDVec3

				///`[x, y, z]`
				to_array(&self)<invalid: [f64;3]>

				///Creates a vector from the first 3 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 3 elements long.
				from_slice(<invalid: &[f64]>) -> LuaDVec3

				///Writes the elements of `self` to the first 3 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 3 elements long.
				write_to_slice(self<invalid: &mut [f64]>)

				// Exclusion reason: 
				// ///Creates a 4D vector from `self` and the given `w` value.
				// extend(selff64) -> LuaDVec4

				// Exclusion reason: 
				// ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				// ///
				// ///Truncation may also be performed by using `self.xy()` or `DVec2::from()`.
				// truncate(self) -> LuaDVec2

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaDVec3) -> f64

				// Exclusion reason: 
				// ///Computes the cross product of `self` and `rhs`.
				// cross(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaDVec3LuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> f64

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> f64

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaDVec3)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaDVec3)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaDVec3)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaDVec3)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaDVec3)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaDVec3)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.  If any element is either
				// ///`NaN`, positive or negative infinity, this will return `false`.
				// is_finite(self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(self) -> bool

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self)

				// Exclusion reason: 
				// ///Computes the length of `self`.
				// length(self) -> f64

				// Exclusion reason: 
				// ///Computes the squared length of `self`.
				// ///
				// ///This is faster than `length()` as it avoids a square root operation.
				// length_squared(self) -> f64

				// Exclusion reason: 
				// ///Computes `1.0 / length()`.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// length_recip(self) -> f64

				// Exclusion reason: 
				// ///Computes the Euclidean distance between two points in space.
				// distance(selfLuaDVec3) -> f64

				// Exclusion reason: 
				// ///Compute the squared euclidean distance between two points in space.
				// distance_squared(selfLuaDVec3) -> f64

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0.
				// ///
				// ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				// ///
				// ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				// ///
				// ///Panics
				// ///
				// ///Will panic if `self` is zero length when `glam_assert` is enabled.
				// normalize(self) -> LuaDVec3

				///Returns `self` normalized to length 1.0 if possible, else returns `None`.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be `None`.
				///
				///See also [`Self::normalize_or_zero`].
				try_normalize(self)

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0 if possible, else returns zero.
				// ///
				// ///In particular, if the input is zero (or very close to zero), or non-finite,
				// ///the result of this operation will be zero.
				// ///
				// ///See also [`Self::try_normalize`].
				// normalize_or_zero(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns whether `self` is length `1.0` or not.
				// ///
				// ///Uses a precision threshold of `1e-6`.
				// is_normalized(self) -> bool

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				// project_onto(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				// reject_from(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// project_onto_normalized(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// reject_from_normalized(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing the nearest integer to a number for each element of `self`.
				// ///Round half-way cases away from 0.0.
				// round(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing the largest integer less than or equal to a number for each
				// ///element of `self`.
				// floor(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing the smallest integer greater than or equal to a number for
				// ///each element of `self`.
				// ceil(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing the fractional part of the vector, e.g. `self -
				// ///self.floor()`.
				// ///
				// ///Note that this is fast but not precise for large numbers.
				// fract(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing `e^self` (the exponential function) for each element of
				// ///`self`.
				// exp(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing each element of `self` raised to the power of `n`.
				// powf(selff64) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				// recip(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				// ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				// ///extrapolated.
				// lerp(selfLuaDVec3f64) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs` is
				// ///less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two vectors contain similar elements. It works best when
				// ///comparing with a known value. The `max_abs_diff` that should be used used depends on
				// ///the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(selfLuaDVec3f64) -> bool

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min` and no more than `max`
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp_length(selff64f64) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector with a length no more than `max`
				// clamp_length_max(selff64) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min`
				// clamp_length_min(selff64) -> LuaDVec3

				// Exclusion reason: 
				// ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				// ///error, yielding a more accurate result than an unfused multiply-add.
				// ///
				// ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				// ///architecture has a dedicated fma CPU instruction. However, this is not always true,
				// ///and will be heavily dependant on designing algorithms with specific target hardware in
				// ///mind.
				// mul_add(selfLuaDVec3LuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns the angle (in radians) between two vectors.
				// ///
				// ///The input vectors do not need to be unit length however they must be non-zero.
				// angle_between(selfLuaDVec3) -> f64

				// Exclusion reason: 
				// ///Returns some vector that is orthogonal to the given one.
				// ///
				// ///The input vector must be finite and non-zero.
				// ///
				// ///The output vector is not necessarily unit-length.
				// ///For that use [`Self::any_orthonormal_vector`] instead.
				// any_orthogonal_vector(&self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns any unit-length vector that is orthogonal to the given one.
				// ///The input vector must be finite and non-zero.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` is not normalized when `glam_assert` is enabled.
				// any_orthonormal_vector(&self) -> LuaDVec3

				///Given a unit-length vector return two other vectors that together form an orthonormal
				///basis.  That is, all three vectors are orthogonal to each other and are normalized.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				any_orthonormal_pair(&self)<invalid: (LuaDVec3,LuaDVec3)>

				///Casts all elements of `self` to `f32`.
				as_vec3(&self)

				///Casts all elements of `self` to `f32`.
				as_vec3a(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec3(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec3(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [f64;3]>) -> LuaDVec3

				// Exclusion reason: 
				// from(LuaDVec3) -> LuaDVec3

				from(<invalid: (f64,f64,f64)>) -> LuaDVec3

				// Exclusion reason: 
				// from(LuaDVec3) -> LuaDVec3

				from(<invalid: (LuaDVec2,f64)>) -> LuaDVec3

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaDVec3)

				///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				mul(selfLuaDVec3)

				// Exclusion reason: 
				// mul(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// mul(selff64) -> LuaDVec3

				// Exclusion reason: 
				// mul(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// clone(&self) -> LuaDVec3

				// Exclusion reason: 
				// default() -> LuaDVec3

				// Exclusion reason: 
				// eq(&self&LuaDVec3) -> bool

				// Exclusion reason: 
				// div(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// div(selff64) -> LuaDVec3

				// Exclusion reason: 
				// div(selfLuaDVec3) -> LuaDVec3

				div_assign(<invalid: &mut self>LuaDVec3)

				div_assign(<invalid: &mut self>f64)

				mul_assign(<invalid: &mut self>LuaDVec3)

				mul_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// add(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// add(selff64) -> LuaDVec3

				// Exclusion reason: 
				// add(selfLuaDVec3) -> LuaDVec3

				add_assign(<invalid: &mut self>LuaDVec3)

				add_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// sub(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// sub(selff64) -> LuaDVec3

				// Exclusion reason: 
				// sub(selfLuaDVec3) -> LuaDVec3

				sub_assign(<invalid: &mut self>LuaDVec3)

				sub_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// rem(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// rem(selff64) -> LuaDVec3

				// Exclusion reason: 
				// rem(selfLuaDVec3) -> LuaDVec3

				rem_assign(<invalid: &mut self>LuaDVec3)

				rem_assign(<invalid: &mut self>f64)

				as_ref(&self)<invalid: &[f64;3]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f64;3]>

				sum() -> LuaDVec3

				product() -> LuaDVec3

				// Exclusion reason: 
				// neg(self) -> LuaDVec3

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaDVec2

				// Exclusion reason: 
				// xy(self) -> LuaDVec2

				// Exclusion reason: 
				// xz(self) -> LuaDVec2

				// Exclusion reason: 
				// yx(self) -> LuaDVec2

				// Exclusion reason: 
				// yy(self) -> LuaDVec2

				// Exclusion reason: 
				// yz(self) -> LuaDVec2

				// Exclusion reason: 
				// zx(self) -> LuaDVec2

				// Exclusion reason: 
				// zy(self) -> LuaDVec2

				// Exclusion reason: 
				// zz(self) -> LuaDVec2

				// Exclusion reason: 
				// xxx(self) -> LuaDVec3

				// Exclusion reason: 
				// xxy(self) -> LuaDVec3

				// Exclusion reason: 
				// xxz(self) -> LuaDVec3

				// Exclusion reason: 
				// xyx(self) -> LuaDVec3

				// Exclusion reason: 
				// xyy(self) -> LuaDVec3

				// Exclusion reason: 
				// xyz(self) -> LuaDVec3

				// Exclusion reason: 
				// xzx(self) -> LuaDVec3

				// Exclusion reason: 
				// xzy(self) -> LuaDVec3

				// Exclusion reason: 
				// xzz(self) -> LuaDVec3

				// Exclusion reason: 
				// yxx(self) -> LuaDVec3

				// Exclusion reason: 
				// yxy(self) -> LuaDVec3

				// Exclusion reason: 
				// yxz(self) -> LuaDVec3

				// Exclusion reason: 
				// yyx(self) -> LuaDVec3

				// Exclusion reason: 
				// yyy(self) -> LuaDVec3

				// Exclusion reason: 
				// yyz(self) -> LuaDVec3

				// Exclusion reason: 
				// yzx(self) -> LuaDVec3

				// Exclusion reason: 
				// yzy(self) -> LuaDVec3

				// Exclusion reason: 
				// yzz(self) -> LuaDVec3

				// Exclusion reason: 
				// zxx(self) -> LuaDVec3

				// Exclusion reason: 
				// zxy(self) -> LuaDVec3

				// Exclusion reason: 
				// zxz(self) -> LuaDVec3

				// Exclusion reason: 
				// zyx(self) -> LuaDVec3

				// Exclusion reason: 
				// zyy(self) -> LuaDVec3

				// Exclusion reason: 
				// zyz(self) -> LuaDVec3

				// Exclusion reason: 
				// zzx(self) -> LuaDVec3

				// Exclusion reason: 
				// zzy(self) -> LuaDVec3

				// Exclusion reason: 
				// zzz(self) -> LuaDVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xxxz(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyz(self) -> LuaDVec4

				// Exclusion reason: 
				// xxzx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxzy(self) -> LuaDVec4

				// Exclusion reason: 
				// xxzz(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxz(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyz(self) -> LuaDVec4

				// Exclusion reason: 
				// xyzx(self) -> LuaDVec4

				// Exclusion reason: 
				// xyzy(self) -> LuaDVec4

				// Exclusion reason: 
				// xyzz(self) -> LuaDVec4

				// Exclusion reason: 
				// xzxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xzxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xzxz(self) -> LuaDVec4

				// Exclusion reason: 
				// xzyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xzyy(self) -> LuaDVec4

				// Exclusion reason: 
				// xzyz(self) -> LuaDVec4

				// Exclusion reason: 
				// xzzx(self) -> LuaDVec4

				// Exclusion reason: 
				// xzzy(self) -> LuaDVec4

				// Exclusion reason: 
				// xzzz(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxz(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyz(self) -> LuaDVec4

				// Exclusion reason: 
				// yxzx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxzy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxzz(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxz(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyz(self) -> LuaDVec4

				// Exclusion reason: 
				// yyzx(self) -> LuaDVec4

				// Exclusion reason: 
				// yyzy(self) -> LuaDVec4

				// Exclusion reason: 
				// yyzz(self) -> LuaDVec4

				// Exclusion reason: 
				// yzxx(self) -> LuaDVec4

				// Exclusion reason: 
				// yzxy(self) -> LuaDVec4

				// Exclusion reason: 
				// yzxz(self) -> LuaDVec4

				// Exclusion reason: 
				// yzyx(self) -> LuaDVec4

				// Exclusion reason: 
				// yzyy(self) -> LuaDVec4

				// Exclusion reason: 
				// yzyz(self) -> LuaDVec4

				// Exclusion reason: 
				// yzzx(self) -> LuaDVec4

				// Exclusion reason: 
				// yzzy(self) -> LuaDVec4

				// Exclusion reason: 
				// yzzz(self) -> LuaDVec4

				// Exclusion reason: 
				// zxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// zxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// zxxz(self) -> LuaDVec4

				// Exclusion reason: 
				// zxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// zxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// zxyz(self) -> LuaDVec4

				// Exclusion reason: 
				// zxzx(self) -> LuaDVec4

				// Exclusion reason: 
				// zxzy(self) -> LuaDVec4

				// Exclusion reason: 
				// zxzz(self) -> LuaDVec4

				// Exclusion reason: 
				// zyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// zyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// zyxz(self) -> LuaDVec4

				// Exclusion reason: 
				// zyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// zyyy(self) -> LuaDVec4

				// Exclusion reason: 
				// zyyz(self) -> LuaDVec4

				// Exclusion reason: 
				// zyzx(self) -> LuaDVec4

				// Exclusion reason: 
				// zyzy(self) -> LuaDVec4

				// Exclusion reason: 
				// zyzz(self) -> LuaDVec4

				// Exclusion reason: 
				// zzxx(self) -> LuaDVec4

				// Exclusion reason: 
				// zzxy(self) -> LuaDVec4

				// Exclusion reason: 
				// zzxz(self) -> LuaDVec4

				// Exclusion reason: 
				// zzyx(self) -> LuaDVec4

				// Exclusion reason: 
				// zzyy(self) -> LuaDVec4

				// Exclusion reason: 
				// zzyz(self) -> LuaDVec4

				// Exclusion reason: 
				// zzzx(self) -> LuaDVec4

				// Exclusion reason: 
				// zzzy(self) -> LuaDVec4

				// Exclusion reason: 
				// zzzz(self) -> LuaDVec4

			)
+ BinaryOps			(
self Add LuaDVec3 -> LuaDVec3 -> LuaDVec3
self Add f64 -> LuaDVec3 -> LuaDVec3
f64 Add self -> LuaDVec3 -> LuaDVec3
self Sub LuaDVec3 -> LuaDVec3 -> LuaDVec3
self Sub f64 -> LuaDVec3 -> LuaDVec3
f64 Sub self -> LuaDVec3 -> LuaDVec3
self Div LuaDVec3 -> LuaDVec3 -> LuaDVec3
self Div f64 -> LuaDVec3 -> LuaDVec3
f64 Div self -> LuaDVec3 -> LuaDVec3
self Mul LuaDVec3 -> LuaDVec3 -> LuaDVec3
self Mul f64 -> LuaDVec3 -> LuaDVec3
f64 Mul self -> LuaDVec3 -> LuaDVec3
self Rem LuaDVec3 -> LuaDVec3 -> LuaDVec3
self Rem f64 -> LuaDVec3 -> LuaDVec3
f64 Rem self -> LuaDVec3 -> LuaDVec3
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaDVec3),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f64))
			    
impl			{
			}
		}
		{
			///A 4-dimensional vector.
glam::f64::dvec4::DVec4 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(f64f64f64f64) -> LuaDVec4

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(f64) -> LuaDVec4

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaDVec4LuaDVec4) -> LuaDVec4

				///Creates a new vector from an array.
				from_array(<invalid: [f64;4]>) -> LuaDVec4

				///`[x, y, z, w]`
				to_array(&self)<invalid: [f64;4]>

				///Creates a vector from the first 4 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 4 elements long.
				from_slice(<invalid: &[f64]>) -> LuaDVec4

				///Writes the elements of `self` to the first 4 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 4 elements long.
				write_to_slice(self<invalid: &mut [f64]>)

				// Exclusion reason: 
				// ///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
				// ///
				// ///Truncation to `DVec3` may also be performed by using `self.xyz()` or `DVec3::from()`.
				// truncate(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaDVec4) -> f64

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaDVec4LuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> f64

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> f64

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaDVec4)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaDVec4)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaDVec4)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaDVec4)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaDVec4)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaDVec4)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.  If any element is either
				// ///`NaN`, positive or negative infinity, this will return `false`.
				// is_finite(self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(self) -> bool

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self)

				// Exclusion reason: 
				// ///Computes the length of `self`.
				// length(self) -> f64

				// Exclusion reason: 
				// ///Computes the squared length of `self`.
				// ///
				// ///This is faster than `length()` as it avoids a square root operation.
				// length_squared(self) -> f64

				// Exclusion reason: 
				// ///Computes `1.0 / length()`.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// length_recip(self) -> f64

				// Exclusion reason: 
				// ///Computes the Euclidean distance between two points in space.
				// distance(selfLuaDVec4) -> f64

				// Exclusion reason: 
				// ///Compute the squared euclidean distance between two points in space.
				// distance_squared(selfLuaDVec4) -> f64

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0.
				// ///
				// ///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				// ///
				// ///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				// ///
				// ///Panics
				// ///
				// ///Will panic if `self` is zero length when `glam_assert` is enabled.
				// normalize(self) -> LuaDVec4

				///Returns `self` normalized to length 1.0 if possible, else returns `None`.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be `None`.
				///
				///See also [`Self::normalize_or_zero`].
				try_normalize(self)

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0 if possible, else returns zero.
				// ///
				// ///In particular, if the input is zero (or very close to zero), or non-finite,
				// ///the result of this operation will be zero.
				// ///
				// ///See also [`Self::try_normalize`].
				// normalize_or_zero(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns whether `self` is length `1.0` or not.
				// ///
				// ///Uses a precision threshold of `1e-6`.
				// is_normalized(self) -> bool

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				// project_onto(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be of non-zero length.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				// reject_from(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns the vector projection of `self` onto `rhs`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// project_onto_normalized(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns the vector rejection of `self` from `rhs`.
				// ///
				// ///The vector rejection is the vector perpendicular to the projection of `self` onto
				// ///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				// ///
				// ///`rhs` must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				// reject_from_normalized(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector containing the nearest integer to a number for each element of `self`.
				// ///Round half-way cases away from 0.0.
				// round(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector containing the largest integer less than or equal to a number for each
				// ///element of `self`.
				// floor(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector containing the smallest integer greater than or equal to a number for
				// ///each element of `self`.
				// ceil(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector containing the fractional part of the vector, e.g. `self -
				// ///self.floor()`.
				// ///
				// ///Note that this is fast but not precise for large numbers.
				// fract(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector containing `e^self` (the exponential function) for each element of
				// ///`self`.
				// exp(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector containing each element of `self` raised to the power of `n`.
				// powf(selff64) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				// recip(self) -> LuaDVec4

				// Exclusion reason: 
				// ///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				// ///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				// ///extrapolated.
				// lerp(selfLuaDVec4f64) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs` is
				// ///less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two vectors contain similar elements. It works best when
				// ///comparing with a known value. The `max_abs_diff` that should be used used depends on
				// ///the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(selfLuaDVec4f64) -> bool

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min` and no more than `max`
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp_length(selff64f64) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector with a length no more than `max`
				// clamp_length_max(selff64) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns a vector with a length no less than `min`
				// clamp_length_min(selff64) -> LuaDVec4

				// Exclusion reason: 
				// ///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				// ///error, yielding a more accurate result than an unfused multiply-add.
				// ///
				// ///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				// ///architecture has a dedicated fma CPU instruction. However, this is not always true,
				// ///and will be heavily dependant on designing algorithms with specific target hardware in
				// ///mind.
				// mul_add(selfLuaDVec4LuaDVec4) -> LuaDVec4

				///Casts all elements of `self` to `f32`.
				as_vec4(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec4(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec4(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				// Exclusion reason: 
				// from(LuaDQuat) -> LuaDVec4

				from(<invalid: [f64;4]>) -> LuaDVec4

				// Exclusion reason: 
				// from(LuaDVec4) -> LuaDVec4

				from(<invalid: (f64,f64,f64,f64)>) -> LuaDVec4

				// Exclusion reason: 
				// from(LuaDVec4) -> LuaDVec4

				from(<invalid: (LuaDVec3,f64)>) -> LuaDVec4

				from(<invalid: (f64,LuaDVec3)>) -> LuaDVec4

				from(<invalid: (LuaDVec2,f64,f64)>) -> LuaDVec4

				from(<invalid: (LuaDVec2,LuaDVec2)>) -> LuaDVec4

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaDVec4)

				// Exclusion reason: 
				// mul(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// mul(selff64) -> LuaDVec4

				// Exclusion reason: 
				// mul(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// clone(&self) -> LuaDVec4

				// Exclusion reason: 
				// default() -> LuaDVec4

				// Exclusion reason: 
				// eq(&self&LuaDVec4) -> bool

				// Exclusion reason: 
				// div(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// div(selff64) -> LuaDVec4

				// Exclusion reason: 
				// div(selfLuaDVec4) -> LuaDVec4

				div_assign(<invalid: &mut self>LuaDVec4)

				div_assign(<invalid: &mut self>f64)

				mul_assign(<invalid: &mut self>LuaDVec4)

				mul_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// add(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// add(selff64) -> LuaDVec4

				// Exclusion reason: 
				// add(selfLuaDVec4) -> LuaDVec4

				add_assign(<invalid: &mut self>LuaDVec4)

				add_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// sub(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// sub(selff64) -> LuaDVec4

				// Exclusion reason: 
				// sub(selfLuaDVec4) -> LuaDVec4

				sub_assign(<invalid: &mut self>LuaDVec4)

				sub_assign(<invalid: &mut self>f64)

				// Exclusion reason: 
				// rem(selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// rem(selff64) -> LuaDVec4

				// Exclusion reason: 
				// rem(selfLuaDVec4) -> LuaDVec4

				rem_assign(<invalid: &mut self>LuaDVec4)

				rem_assign(<invalid: &mut self>f64)

				as_ref(&self)<invalid: &[f64;4]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f64;4]>

				sum() -> LuaDVec4

				product() -> LuaDVec4

				// Exclusion reason: 
				// neg(self) -> LuaDVec4

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaDVec2

				// Exclusion reason: 
				// xy(self) -> LuaDVec2

				// Exclusion reason: 
				// xz(self) -> LuaDVec2

				// Exclusion reason: 
				// xw(self) -> LuaDVec2

				// Exclusion reason: 
				// yx(self) -> LuaDVec2

				// Exclusion reason: 
				// yy(self) -> LuaDVec2

				// Exclusion reason: 
				// yz(self) -> LuaDVec2

				// Exclusion reason: 
				// yw(self) -> LuaDVec2

				// Exclusion reason: 
				// zx(self) -> LuaDVec2

				// Exclusion reason: 
				// zy(self) -> LuaDVec2

				// Exclusion reason: 
				// zz(self) -> LuaDVec2

				// Exclusion reason: 
				// zw(self) -> LuaDVec2

				// Exclusion reason: 
				// wx(self) -> LuaDVec2

				// Exclusion reason: 
				// wy(self) -> LuaDVec2

				// Exclusion reason: 
				// wz(self) -> LuaDVec2

				// Exclusion reason: 
				// ww(self) -> LuaDVec2

				// Exclusion reason: 
				// xxx(self) -> LuaDVec3

				// Exclusion reason: 
				// xxy(self) -> LuaDVec3

				// Exclusion reason: 
				// xxz(self) -> LuaDVec3

				// Exclusion reason: 
				// xxw(self) -> LuaDVec3

				// Exclusion reason: 
				// xyx(self) -> LuaDVec3

				// Exclusion reason: 
				// xyy(self) -> LuaDVec3

				// Exclusion reason: 
				// xyz(self) -> LuaDVec3

				// Exclusion reason: 
				// xyw(self) -> LuaDVec3

				// Exclusion reason: 
				// xzx(self) -> LuaDVec3

				// Exclusion reason: 
				// xzy(self) -> LuaDVec3

				// Exclusion reason: 
				// xzz(self) -> LuaDVec3

				// Exclusion reason: 
				// xzw(self) -> LuaDVec3

				// Exclusion reason: 
				// xwx(self) -> LuaDVec3

				// Exclusion reason: 
				// xwy(self) -> LuaDVec3

				// Exclusion reason: 
				// xwz(self) -> LuaDVec3

				// Exclusion reason: 
				// xww(self) -> LuaDVec3

				// Exclusion reason: 
				// yxx(self) -> LuaDVec3

				// Exclusion reason: 
				// yxy(self) -> LuaDVec3

				// Exclusion reason: 
				// yxz(self) -> LuaDVec3

				// Exclusion reason: 
				// yxw(self) -> LuaDVec3

				// Exclusion reason: 
				// yyx(self) -> LuaDVec3

				// Exclusion reason: 
				// yyy(self) -> LuaDVec3

				// Exclusion reason: 
				// yyz(self) -> LuaDVec3

				// Exclusion reason: 
				// yyw(self) -> LuaDVec3

				// Exclusion reason: 
				// yzx(self) -> LuaDVec3

				// Exclusion reason: 
				// yzy(self) -> LuaDVec3

				// Exclusion reason: 
				// yzz(self) -> LuaDVec3

				// Exclusion reason: 
				// yzw(self) -> LuaDVec3

				// Exclusion reason: 
				// ywx(self) -> LuaDVec3

				// Exclusion reason: 
				// ywy(self) -> LuaDVec3

				// Exclusion reason: 
				// ywz(self) -> LuaDVec3

				// Exclusion reason: 
				// yww(self) -> LuaDVec3

				// Exclusion reason: 
				// zxx(self) -> LuaDVec3

				// Exclusion reason: 
				// zxy(self) -> LuaDVec3

				// Exclusion reason: 
				// zxz(self) -> LuaDVec3

				// Exclusion reason: 
				// zxw(self) -> LuaDVec3

				// Exclusion reason: 
				// zyx(self) -> LuaDVec3

				// Exclusion reason: 
				// zyy(self) -> LuaDVec3

				// Exclusion reason: 
				// zyz(self) -> LuaDVec3

				// Exclusion reason: 
				// zyw(self) -> LuaDVec3

				// Exclusion reason: 
				// zzx(self) -> LuaDVec3

				// Exclusion reason: 
				// zzy(self) -> LuaDVec3

				// Exclusion reason: 
				// zzz(self) -> LuaDVec3

				// Exclusion reason: 
				// zzw(self) -> LuaDVec3

				// Exclusion reason: 
				// zwx(self) -> LuaDVec3

				// Exclusion reason: 
				// zwy(self) -> LuaDVec3

				// Exclusion reason: 
				// zwz(self) -> LuaDVec3

				// Exclusion reason: 
				// zww(self) -> LuaDVec3

				// Exclusion reason: 
				// wxx(self) -> LuaDVec3

				// Exclusion reason: 
				// wxy(self) -> LuaDVec3

				// Exclusion reason: 
				// wxz(self) -> LuaDVec3

				// Exclusion reason: 
				// wxw(self) -> LuaDVec3

				// Exclusion reason: 
				// wyx(self) -> LuaDVec3

				// Exclusion reason: 
				// wyy(self) -> LuaDVec3

				// Exclusion reason: 
				// wyz(self) -> LuaDVec3

				// Exclusion reason: 
				// wyw(self) -> LuaDVec3

				// Exclusion reason: 
				// wzx(self) -> LuaDVec3

				// Exclusion reason: 
				// wzy(self) -> LuaDVec3

				// Exclusion reason: 
				// wzz(self) -> LuaDVec3

				// Exclusion reason: 
				// wzw(self) -> LuaDVec3

				// Exclusion reason: 
				// wwx(self) -> LuaDVec3

				// Exclusion reason: 
				// wwy(self) -> LuaDVec3

				// Exclusion reason: 
				// wwz(self) -> LuaDVec3

				// Exclusion reason: 
				// www(self) -> LuaDVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xxxz(self) -> LuaDVec4

				// Exclusion reason: 
				// xxxw(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyz(self) -> LuaDVec4

				// Exclusion reason: 
				// xxyw(self) -> LuaDVec4

				// Exclusion reason: 
				// xxzx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxzy(self) -> LuaDVec4

				// Exclusion reason: 
				// xxzz(self) -> LuaDVec4

				// Exclusion reason: 
				// xxzw(self) -> LuaDVec4

				// Exclusion reason: 
				// xxwx(self) -> LuaDVec4

				// Exclusion reason: 
				// xxwy(self) -> LuaDVec4

				// Exclusion reason: 
				// xxwz(self) -> LuaDVec4

				// Exclusion reason: 
				// xxww(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxz(self) -> LuaDVec4

				// Exclusion reason: 
				// xyxw(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyz(self) -> LuaDVec4

				// Exclusion reason: 
				// xyyw(self) -> LuaDVec4

				// Exclusion reason: 
				// xyzx(self) -> LuaDVec4

				// Exclusion reason: 
				// xyzy(self) -> LuaDVec4

				// Exclusion reason: 
				// xyzz(self) -> LuaDVec4

				// Exclusion reason: 
				// xyzw(self) -> LuaDVec4

				// Exclusion reason: 
				// xywx(self) -> LuaDVec4

				// Exclusion reason: 
				// xywy(self) -> LuaDVec4

				// Exclusion reason: 
				// xywz(self) -> LuaDVec4

				// Exclusion reason: 
				// xyww(self) -> LuaDVec4

				// Exclusion reason: 
				// xzxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xzxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xzxz(self) -> LuaDVec4

				// Exclusion reason: 
				// xzxw(self) -> LuaDVec4

				// Exclusion reason: 
				// xzyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xzyy(self) -> LuaDVec4

				// Exclusion reason: 
				// xzyz(self) -> LuaDVec4

				// Exclusion reason: 
				// xzyw(self) -> LuaDVec4

				// Exclusion reason: 
				// xzzx(self) -> LuaDVec4

				// Exclusion reason: 
				// xzzy(self) -> LuaDVec4

				// Exclusion reason: 
				// xzzz(self) -> LuaDVec4

				// Exclusion reason: 
				// xzzw(self) -> LuaDVec4

				// Exclusion reason: 
				// xzwx(self) -> LuaDVec4

				// Exclusion reason: 
				// xzwy(self) -> LuaDVec4

				// Exclusion reason: 
				// xzwz(self) -> LuaDVec4

				// Exclusion reason: 
				// xzww(self) -> LuaDVec4

				// Exclusion reason: 
				// xwxx(self) -> LuaDVec4

				// Exclusion reason: 
				// xwxy(self) -> LuaDVec4

				// Exclusion reason: 
				// xwxz(self) -> LuaDVec4

				// Exclusion reason: 
				// xwxw(self) -> LuaDVec4

				// Exclusion reason: 
				// xwyx(self) -> LuaDVec4

				// Exclusion reason: 
				// xwyy(self) -> LuaDVec4

				// Exclusion reason: 
				// xwyz(self) -> LuaDVec4

				// Exclusion reason: 
				// xwyw(self) -> LuaDVec4

				// Exclusion reason: 
				// xwzx(self) -> LuaDVec4

				// Exclusion reason: 
				// xwzy(self) -> LuaDVec4

				// Exclusion reason: 
				// xwzz(self) -> LuaDVec4

				// Exclusion reason: 
				// xwzw(self) -> LuaDVec4

				// Exclusion reason: 
				// xwwx(self) -> LuaDVec4

				// Exclusion reason: 
				// xwwy(self) -> LuaDVec4

				// Exclusion reason: 
				// xwwz(self) -> LuaDVec4

				// Exclusion reason: 
				// xwww(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxz(self) -> LuaDVec4

				// Exclusion reason: 
				// yxxw(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyz(self) -> LuaDVec4

				// Exclusion reason: 
				// yxyw(self) -> LuaDVec4

				// Exclusion reason: 
				// yxzx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxzy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxzz(self) -> LuaDVec4

				// Exclusion reason: 
				// yxzw(self) -> LuaDVec4

				// Exclusion reason: 
				// yxwx(self) -> LuaDVec4

				// Exclusion reason: 
				// yxwy(self) -> LuaDVec4

				// Exclusion reason: 
				// yxwz(self) -> LuaDVec4

				// Exclusion reason: 
				// yxww(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxz(self) -> LuaDVec4

				// Exclusion reason: 
				// yyxw(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyz(self) -> LuaDVec4

				// Exclusion reason: 
				// yyyw(self) -> LuaDVec4

				// Exclusion reason: 
				// yyzx(self) -> LuaDVec4

				// Exclusion reason: 
				// yyzy(self) -> LuaDVec4

				// Exclusion reason: 
				// yyzz(self) -> LuaDVec4

				// Exclusion reason: 
				// yyzw(self) -> LuaDVec4

				// Exclusion reason: 
				// yywx(self) -> LuaDVec4

				// Exclusion reason: 
				// yywy(self) -> LuaDVec4

				// Exclusion reason: 
				// yywz(self) -> LuaDVec4

				// Exclusion reason: 
				// yyww(self) -> LuaDVec4

				// Exclusion reason: 
				// yzxx(self) -> LuaDVec4

				// Exclusion reason: 
				// yzxy(self) -> LuaDVec4

				// Exclusion reason: 
				// yzxz(self) -> LuaDVec4

				// Exclusion reason: 
				// yzxw(self) -> LuaDVec4

				// Exclusion reason: 
				// yzyx(self) -> LuaDVec4

				// Exclusion reason: 
				// yzyy(self) -> LuaDVec4

				// Exclusion reason: 
				// yzyz(self) -> LuaDVec4

				// Exclusion reason: 
				// yzyw(self) -> LuaDVec4

				// Exclusion reason: 
				// yzzx(self) -> LuaDVec4

				// Exclusion reason: 
				// yzzy(self) -> LuaDVec4

				// Exclusion reason: 
				// yzzz(self) -> LuaDVec4

				// Exclusion reason: 
				// yzzw(self) -> LuaDVec4

				// Exclusion reason: 
				// yzwx(self) -> LuaDVec4

				// Exclusion reason: 
				// yzwy(self) -> LuaDVec4

				// Exclusion reason: 
				// yzwz(self) -> LuaDVec4

				// Exclusion reason: 
				// yzww(self) -> LuaDVec4

				// Exclusion reason: 
				// ywxx(self) -> LuaDVec4

				// Exclusion reason: 
				// ywxy(self) -> LuaDVec4

				// Exclusion reason: 
				// ywxz(self) -> LuaDVec4

				// Exclusion reason: 
				// ywxw(self) -> LuaDVec4

				// Exclusion reason: 
				// ywyx(self) -> LuaDVec4

				// Exclusion reason: 
				// ywyy(self) -> LuaDVec4

				// Exclusion reason: 
				// ywyz(self) -> LuaDVec4

				// Exclusion reason: 
				// ywyw(self) -> LuaDVec4

				// Exclusion reason: 
				// ywzx(self) -> LuaDVec4

				// Exclusion reason: 
				// ywzy(self) -> LuaDVec4

				// Exclusion reason: 
				// ywzz(self) -> LuaDVec4

				// Exclusion reason: 
				// ywzw(self) -> LuaDVec4

				// Exclusion reason: 
				// ywwx(self) -> LuaDVec4

				// Exclusion reason: 
				// ywwy(self) -> LuaDVec4

				// Exclusion reason: 
				// ywwz(self) -> LuaDVec4

				// Exclusion reason: 
				// ywww(self) -> LuaDVec4

				// Exclusion reason: 
				// zxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// zxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// zxxz(self) -> LuaDVec4

				// Exclusion reason: 
				// zxxw(self) -> LuaDVec4

				// Exclusion reason: 
				// zxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// zxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// zxyz(self) -> LuaDVec4

				// Exclusion reason: 
				// zxyw(self) -> LuaDVec4

				// Exclusion reason: 
				// zxzx(self) -> LuaDVec4

				// Exclusion reason: 
				// zxzy(self) -> LuaDVec4

				// Exclusion reason: 
				// zxzz(self) -> LuaDVec4

				// Exclusion reason: 
				// zxzw(self) -> LuaDVec4

				// Exclusion reason: 
				// zxwx(self) -> LuaDVec4

				// Exclusion reason: 
				// zxwy(self) -> LuaDVec4

				// Exclusion reason: 
				// zxwz(self) -> LuaDVec4

				// Exclusion reason: 
				// zxww(self) -> LuaDVec4

				// Exclusion reason: 
				// zyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// zyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// zyxz(self) -> LuaDVec4

				// Exclusion reason: 
				// zyxw(self) -> LuaDVec4

				// Exclusion reason: 
				// zyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// zyyy(self) -> LuaDVec4

				// Exclusion reason: 
				// zyyz(self) -> LuaDVec4

				// Exclusion reason: 
				// zyyw(self) -> LuaDVec4

				// Exclusion reason: 
				// zyzx(self) -> LuaDVec4

				// Exclusion reason: 
				// zyzy(self) -> LuaDVec4

				// Exclusion reason: 
				// zyzz(self) -> LuaDVec4

				// Exclusion reason: 
				// zyzw(self) -> LuaDVec4

				// Exclusion reason: 
				// zywx(self) -> LuaDVec4

				// Exclusion reason: 
				// zywy(self) -> LuaDVec4

				// Exclusion reason: 
				// zywz(self) -> LuaDVec4

				// Exclusion reason: 
				// zyww(self) -> LuaDVec4

				// Exclusion reason: 
				// zzxx(self) -> LuaDVec4

				// Exclusion reason: 
				// zzxy(self) -> LuaDVec4

				// Exclusion reason: 
				// zzxz(self) -> LuaDVec4

				// Exclusion reason: 
				// zzxw(self) -> LuaDVec4

				// Exclusion reason: 
				// zzyx(self) -> LuaDVec4

				// Exclusion reason: 
				// zzyy(self) -> LuaDVec4

				// Exclusion reason: 
				// zzyz(self) -> LuaDVec4

				// Exclusion reason: 
				// zzyw(self) -> LuaDVec4

				// Exclusion reason: 
				// zzzx(self) -> LuaDVec4

				// Exclusion reason: 
				// zzzy(self) -> LuaDVec4

				// Exclusion reason: 
				// zzzz(self) -> LuaDVec4

				// Exclusion reason: 
				// zzzw(self) -> LuaDVec4

				// Exclusion reason: 
				// zzwx(self) -> LuaDVec4

				// Exclusion reason: 
				// zzwy(self) -> LuaDVec4

				// Exclusion reason: 
				// zzwz(self) -> LuaDVec4

				// Exclusion reason: 
				// zzww(self) -> LuaDVec4

				// Exclusion reason: 
				// zwxx(self) -> LuaDVec4

				// Exclusion reason: 
				// zwxy(self) -> LuaDVec4

				// Exclusion reason: 
				// zwxz(self) -> LuaDVec4

				// Exclusion reason: 
				// zwxw(self) -> LuaDVec4

				// Exclusion reason: 
				// zwyx(self) -> LuaDVec4

				// Exclusion reason: 
				// zwyy(self) -> LuaDVec4

				// Exclusion reason: 
				// zwyz(self) -> LuaDVec4

				// Exclusion reason: 
				// zwyw(self) -> LuaDVec4

				// Exclusion reason: 
				// zwzx(self) -> LuaDVec4

				// Exclusion reason: 
				// zwzy(self) -> LuaDVec4

				// Exclusion reason: 
				// zwzz(self) -> LuaDVec4

				// Exclusion reason: 
				// zwzw(self) -> LuaDVec4

				// Exclusion reason: 
				// zwwx(self) -> LuaDVec4

				// Exclusion reason: 
				// zwwy(self) -> LuaDVec4

				// Exclusion reason: 
				// zwwz(self) -> LuaDVec4

				// Exclusion reason: 
				// zwww(self) -> LuaDVec4

				// Exclusion reason: 
				// wxxx(self) -> LuaDVec4

				// Exclusion reason: 
				// wxxy(self) -> LuaDVec4

				// Exclusion reason: 
				// wxxz(self) -> LuaDVec4

				// Exclusion reason: 
				// wxxw(self) -> LuaDVec4

				// Exclusion reason: 
				// wxyx(self) -> LuaDVec4

				// Exclusion reason: 
				// wxyy(self) -> LuaDVec4

				// Exclusion reason: 
				// wxyz(self) -> LuaDVec4

				// Exclusion reason: 
				// wxyw(self) -> LuaDVec4

				// Exclusion reason: 
				// wxzx(self) -> LuaDVec4

				// Exclusion reason: 
				// wxzy(self) -> LuaDVec4

				// Exclusion reason: 
				// wxzz(self) -> LuaDVec4

				// Exclusion reason: 
				// wxzw(self) -> LuaDVec4

				// Exclusion reason: 
				// wxwx(self) -> LuaDVec4

				// Exclusion reason: 
				// wxwy(self) -> LuaDVec4

				// Exclusion reason: 
				// wxwz(self) -> LuaDVec4

				// Exclusion reason: 
				// wxww(self) -> LuaDVec4

				// Exclusion reason: 
				// wyxx(self) -> LuaDVec4

				// Exclusion reason: 
				// wyxy(self) -> LuaDVec4

				// Exclusion reason: 
				// wyxz(self) -> LuaDVec4

				// Exclusion reason: 
				// wyxw(self) -> LuaDVec4

				// Exclusion reason: 
				// wyyx(self) -> LuaDVec4

				// Exclusion reason: 
				// wyyy(self) -> LuaDVec4

				// Exclusion reason: 
				// wyyz(self) -> LuaDVec4

				// Exclusion reason: 
				// wyyw(self) -> LuaDVec4

				// Exclusion reason: 
				// wyzx(self) -> LuaDVec4

				// Exclusion reason: 
				// wyzy(self) -> LuaDVec4

				// Exclusion reason: 
				// wyzz(self) -> LuaDVec4

				// Exclusion reason: 
				// wyzw(self) -> LuaDVec4

				// Exclusion reason: 
				// wywx(self) -> LuaDVec4

				// Exclusion reason: 
				// wywy(self) -> LuaDVec4

				// Exclusion reason: 
				// wywz(self) -> LuaDVec4

				// Exclusion reason: 
				// wyww(self) -> LuaDVec4

				// Exclusion reason: 
				// wzxx(self) -> LuaDVec4

				// Exclusion reason: 
				// wzxy(self) -> LuaDVec4

				// Exclusion reason: 
				// wzxz(self) -> LuaDVec4

				// Exclusion reason: 
				// wzxw(self) -> LuaDVec4

				// Exclusion reason: 
				// wzyx(self) -> LuaDVec4

				// Exclusion reason: 
				// wzyy(self) -> LuaDVec4

				// Exclusion reason: 
				// wzyz(self) -> LuaDVec4

				// Exclusion reason: 
				// wzyw(self) -> LuaDVec4

				// Exclusion reason: 
				// wzzx(self) -> LuaDVec4

				// Exclusion reason: 
				// wzzy(self) -> LuaDVec4

				// Exclusion reason: 
				// wzzz(self) -> LuaDVec4

				// Exclusion reason: 
				// wzzw(self) -> LuaDVec4

				// Exclusion reason: 
				// wzwx(self) -> LuaDVec4

				// Exclusion reason: 
				// wzwy(self) -> LuaDVec4

				// Exclusion reason: 
				// wzwz(self) -> LuaDVec4

				// Exclusion reason: 
				// wzww(self) -> LuaDVec4

				// Exclusion reason: 
				// wwxx(self) -> LuaDVec4

				// Exclusion reason: 
				// wwxy(self) -> LuaDVec4

				// Exclusion reason: 
				// wwxz(self) -> LuaDVec4

				// Exclusion reason: 
				// wwxw(self) -> LuaDVec4

				// Exclusion reason: 
				// wwyx(self) -> LuaDVec4

				// Exclusion reason: 
				// wwyy(self) -> LuaDVec4

				// Exclusion reason: 
				// wwyz(self) -> LuaDVec4

				// Exclusion reason: 
				// wwyw(self) -> LuaDVec4

				// Exclusion reason: 
				// wwzx(self) -> LuaDVec4

				// Exclusion reason: 
				// wwzy(self) -> LuaDVec4

				// Exclusion reason: 
				// wwzz(self) -> LuaDVec4

				// Exclusion reason: 
				// wwzw(self) -> LuaDVec4

				// Exclusion reason: 
				// wwwx(self) -> LuaDVec4

				// Exclusion reason: 
				// wwwy(self) -> LuaDVec4

				// Exclusion reason: 
				// wwwz(self) -> LuaDVec4

				// Exclusion reason: 
				// wwww(self) -> LuaDVec4

			)
+ BinaryOps			(
self Add LuaDVec4 -> LuaDVec4 -> LuaDVec4
self Add f64 -> LuaDVec4 -> LuaDVec4
f64 Add self -> LuaDVec4 -> LuaDVec4
self Sub LuaDVec4 -> LuaDVec4 -> LuaDVec4
self Sub f64 -> LuaDVec4 -> LuaDVec4
f64 Sub self -> LuaDVec4 -> LuaDVec4
self Div LuaDVec4 -> LuaDVec4 -> LuaDVec4
self Div f64 -> LuaDVec4 -> LuaDVec4
f64 Div self -> LuaDVec4 -> LuaDVec4
self Mul LuaDVec4 -> LuaDVec4 -> LuaDVec4
self Mul f64 -> LuaDVec4 -> LuaDVec4
f64 Mul self -> LuaDVec4 -> LuaDVec4
self Rem LuaDVec4 -> LuaDVec4 -> LuaDVec4
self Rem f64 -> LuaDVec4 -> LuaDVec4
f64 Rem self -> LuaDVec4 -> LuaDVec4
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaDVec4),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f64))
			    
impl			{
			}
		}
		{
			///A 2-dimensional vector.
glam::i32::ivec2::IVec2 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(i32i32) -> LuaIVec2

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(i32) -> LuaIVec2

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaIVec2LuaIVec2) -> LuaIVec2

				///Creates a new vector from an array.
				from_array(<invalid: [i32;2]>) -> LuaIVec2

				///`[x, y]`
				to_array(&self)<invalid: [i32;2]>

				///Creates a vector from the first 2 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 2 elements long.
				from_slice(<invalid: &[i32]>) -> LuaIVec2

				///Writes the elements of `self` to the first 2 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 2 elements long.
				write_to_slice(self<invalid: &mut [i32]>)

				// Exclusion reason: 
				// ///Creates a 3D vector from `self` and the given `z` value.
				// extend(selfi32) -> LuaIVec3

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaIVec2) -> i32

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaIVec2) -> LuaIVec2

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaIVec2) -> LuaIVec2

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaIVec2LuaIVec2) -> LuaIVec2

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> i32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> i32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaIVec2)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaIVec2)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaIVec2)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaIVec2)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaIVec2)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaIVec2)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaIVec2

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaIVec2

				// Exclusion reason: 
				// ///Returns a vector that is equal to `self` rotated by 90 degrees.
				// perp(self) -> LuaIVec2

				// Exclusion reason: 
				// ///The perpendicular dot product of `self` and `rhs`.
				// ///Also known as the wedge product, 2D cross product, and determinant.
				// perp_dot(selfLuaIVec2) -> i32

				// Exclusion reason: 
				// ///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
				// ///then this just rotation. This is what you usually want. Otherwise,
				// ///it will be like a rotation with a multiplication by `self`'s length.
				// rotate(selfLuaIVec2) -> LuaIVec2

				///Casts all elements of `self` to `f32`.
				as_vec2(&self)

				///Casts all elements of `self` to `f64`.
				as_dvec2(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec2(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [i32;2]>) -> LuaIVec2

				// Exclusion reason: 
				// from(LuaIVec2) -> LuaIVec2

				from(<invalid: (i32,i32)>) -> LuaIVec2

				// Exclusion reason: 
				// from(LuaIVec2) -> LuaIVec2

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				// Exclusion reason: 
				// clone(&self) -> LuaIVec2

				// Exclusion reason: 
				// default() -> LuaIVec2

				// Exclusion reason: 
				// eq(&self&LuaIVec2) -> bool

				// Exclusion reason: 
				// div(selfLuaIVec2) -> LuaIVec2

				// Exclusion reason: 
				// div(selfi32) -> LuaIVec2

				// Exclusion reason: 
				// div(selfLuaIVec2) -> LuaIVec2

				div_assign(<invalid: &mut self>LuaIVec2)

				div_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// mul(selfLuaIVec2) -> LuaIVec2

				// Exclusion reason: 
				// mul(selfi32) -> LuaIVec2

				// Exclusion reason: 
				// mul(selfLuaIVec2) -> LuaIVec2

				mul_assign(<invalid: &mut self>LuaIVec2)

				mul_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// add(selfLuaIVec2) -> LuaIVec2

				// Exclusion reason: 
				// add(selfi32) -> LuaIVec2

				// Exclusion reason: 
				// add(selfLuaIVec2) -> LuaIVec2

				add_assign(<invalid: &mut self>LuaIVec2)

				add_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// sub(selfLuaIVec2) -> LuaIVec2

				// Exclusion reason: 
				// sub(selfi32) -> LuaIVec2

				// Exclusion reason: 
				// sub(selfLuaIVec2) -> LuaIVec2

				sub_assign(<invalid: &mut self>LuaIVec2)

				sub_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// rem(selfLuaIVec2) -> LuaIVec2

				// Exclusion reason: 
				// rem(selfi32) -> LuaIVec2

				// Exclusion reason: 
				// rem(selfLuaIVec2) -> LuaIVec2

				rem_assign(<invalid: &mut self>LuaIVec2)

				rem_assign(<invalid: &mut self>i32)

				as_ref(&self)<invalid: &[i32;2]>

				as_mut(<invalid: &mut self>)<invalid: &mut [i32;2]>

				sum() -> LuaIVec2

				product() -> LuaIVec2

				// Exclusion reason: 
				// neg(self) -> LuaIVec2

				hash(&self)

				not(self)

				bitand(selfLuaIVec2)

				bitand(selfi32)

				bitor(selfLuaIVec2)

				bitor(selfi32)

				bitxor(selfLuaIVec2)

				bitxor(selfi32)

				shl(selfi8)

				shl(selfi16)

				shl(selfi32)

				shl(selfu8)

				shl(selfu16)

				shl(selfu32)

				shl(self)

				shl(self)

				shl(self)

				shr(selfi8)

				shr(selfi16)

				shr(selfi32)

				shr(selfu8)

				shr(selfu16)

				shr(selfu32)

				shr(self)

				shr(self)

				shr(self)

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaIVec2

				// Exclusion reason: 
				// xy(self) -> LuaIVec2

				// Exclusion reason: 
				// yx(self) -> LuaIVec2

				// Exclusion reason: 
				// yy(self) -> LuaIVec2

				// Exclusion reason: 
				// xxx(self) -> LuaIVec3

				// Exclusion reason: 
				// xxy(self) -> LuaIVec3

				// Exclusion reason: 
				// xyx(self) -> LuaIVec3

				// Exclusion reason: 
				// xyy(self) -> LuaIVec3

				// Exclusion reason: 
				// yxx(self) -> LuaIVec3

				// Exclusion reason: 
				// yxy(self) -> LuaIVec3

				// Exclusion reason: 
				// yyx(self) -> LuaIVec3

				// Exclusion reason: 
				// yyy(self) -> LuaIVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaIVec4

			)
+ BinaryOps			(
self Add LuaIVec2 -> LuaIVec2 -> LuaIVec2
self Add i32 -> LuaIVec2 -> LuaIVec2
i32 Add self -> LuaIVec2 -> LuaIVec2
self Sub LuaIVec2 -> LuaIVec2 -> LuaIVec2
self Sub i32 -> LuaIVec2 -> LuaIVec2
i32 Sub self -> LuaIVec2 -> LuaIVec2
self Div LuaIVec2 -> LuaIVec2 -> LuaIVec2
self Div i32 -> LuaIVec2 -> LuaIVec2
i32 Div self -> LuaIVec2 -> LuaIVec2
self Mul LuaIVec2 -> LuaIVec2 -> LuaIVec2
self Mul i32 -> LuaIVec2 -> LuaIVec2
i32 Mul self -> LuaIVec2 -> LuaIVec2
self Rem LuaIVec2 -> LuaIVec2 -> LuaIVec2
self Rem i32 -> LuaIVec2 -> LuaIVec2
i32 Rem self -> LuaIVec2 -> LuaIVec2
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaIVec2),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=i32))
			    
impl			{
			}
		}
		{
			///A 3-dimensional vector.
glam::i32::ivec3::IVec3 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(i32i32i32) -> LuaIVec3

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(i32) -> LuaIVec3

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaIVec3LuaIVec3) -> LuaIVec3

				///Creates a new vector from an array.
				from_array(<invalid: [i32;3]>) -> LuaIVec3

				///`[x, y, z]`
				to_array(&self)<invalid: [i32;3]>

				///Creates a vector from the first 3 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 3 elements long.
				from_slice(<invalid: &[i32]>) -> LuaIVec3

				///Writes the elements of `self` to the first 3 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 3 elements long.
				write_to_slice(self<invalid: &mut [i32]>)

				// Exclusion reason: 
				// ///Creates a 4D vector from `self` and the given `w` value.
				// extend(selfi32) -> LuaIVec4

				// Exclusion reason: 
				// ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				// ///
				// ///Truncation may also be performed by using `self.xy()` or `IVec2::from()`.
				// truncate(self) -> LuaIVec2

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaIVec3) -> i32

				// Exclusion reason: 
				// ///Computes the cross product of `self` and `rhs`.
				// cross(selfLuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaIVec3LuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> i32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> i32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaIVec3)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaIVec3)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaIVec3)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaIVec3)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaIVec3)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaIVec3)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaIVec3

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaIVec3

				///Casts all elements of `self` to `f32`.
				as_vec3(&self)

				///Casts all elements of `self` to `f32`.
				as_vec3a(&self)

				///Casts all elements of `self` to `f64`.
				as_dvec3(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec3(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [i32;3]>) -> LuaIVec3

				// Exclusion reason: 
				// from(LuaIVec3) -> LuaIVec3

				from(<invalid: (i32,i32,i32)>) -> LuaIVec3

				// Exclusion reason: 
				// from(LuaIVec3) -> LuaIVec3

				from(<invalid: (LuaIVec2,i32)>) -> LuaIVec3

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				// Exclusion reason: 
				// clone(&self) -> LuaIVec3

				// Exclusion reason: 
				// default() -> LuaIVec3

				// Exclusion reason: 
				// eq(&self&LuaIVec3) -> bool

				// Exclusion reason: 
				// div(selfLuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// div(selfi32) -> LuaIVec3

				// Exclusion reason: 
				// div(selfLuaIVec3) -> LuaIVec3

				div_assign(<invalid: &mut self>LuaIVec3)

				div_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// mul(selfLuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// mul(selfi32) -> LuaIVec3

				// Exclusion reason: 
				// mul(selfLuaIVec3) -> LuaIVec3

				mul_assign(<invalid: &mut self>LuaIVec3)

				mul_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// add(selfLuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// add(selfi32) -> LuaIVec3

				// Exclusion reason: 
				// add(selfLuaIVec3) -> LuaIVec3

				add_assign(<invalid: &mut self>LuaIVec3)

				add_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// sub(selfLuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// sub(selfi32) -> LuaIVec3

				// Exclusion reason: 
				// sub(selfLuaIVec3) -> LuaIVec3

				sub_assign(<invalid: &mut self>LuaIVec3)

				sub_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// rem(selfLuaIVec3) -> LuaIVec3

				// Exclusion reason: 
				// rem(selfi32) -> LuaIVec3

				// Exclusion reason: 
				// rem(selfLuaIVec3) -> LuaIVec3

				rem_assign(<invalid: &mut self>LuaIVec3)

				rem_assign(<invalid: &mut self>i32)

				as_ref(&self)<invalid: &[i32;3]>

				as_mut(<invalid: &mut self>)<invalid: &mut [i32;3]>

				sum() -> LuaIVec3

				product() -> LuaIVec3

				// Exclusion reason: 
				// neg(self) -> LuaIVec3

				hash(&self)

				not(self)

				bitand(selfLuaIVec3)

				bitand(selfi32)

				bitor(selfLuaIVec3)

				bitor(selfi32)

				bitxor(selfLuaIVec3)

				bitxor(selfi32)

				shl(selfi8)

				shl(selfi16)

				shl(selfi32)

				shl(selfu8)

				shl(selfu16)

				shl(selfu32)

				shl(self)

				shl(self)

				shl(self)

				shr(selfi8)

				shr(selfi16)

				shr(selfi32)

				shr(selfu8)

				shr(selfu16)

				shr(selfu32)

				shr(self)

				shr(self)

				shr(self)

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaIVec2

				// Exclusion reason: 
				// xy(self) -> LuaIVec2

				// Exclusion reason: 
				// xz(self) -> LuaIVec2

				// Exclusion reason: 
				// yx(self) -> LuaIVec2

				// Exclusion reason: 
				// yy(self) -> LuaIVec2

				// Exclusion reason: 
				// yz(self) -> LuaIVec2

				// Exclusion reason: 
				// zx(self) -> LuaIVec2

				// Exclusion reason: 
				// zy(self) -> LuaIVec2

				// Exclusion reason: 
				// zz(self) -> LuaIVec2

				// Exclusion reason: 
				// xxx(self) -> LuaIVec3

				// Exclusion reason: 
				// xxy(self) -> LuaIVec3

				// Exclusion reason: 
				// xxz(self) -> LuaIVec3

				// Exclusion reason: 
				// xyx(self) -> LuaIVec3

				// Exclusion reason: 
				// xyy(self) -> LuaIVec3

				// Exclusion reason: 
				// xyz(self) -> LuaIVec3

				// Exclusion reason: 
				// xzx(self) -> LuaIVec3

				// Exclusion reason: 
				// xzy(self) -> LuaIVec3

				// Exclusion reason: 
				// xzz(self) -> LuaIVec3

				// Exclusion reason: 
				// yxx(self) -> LuaIVec3

				// Exclusion reason: 
				// yxy(self) -> LuaIVec3

				// Exclusion reason: 
				// yxz(self) -> LuaIVec3

				// Exclusion reason: 
				// yyx(self) -> LuaIVec3

				// Exclusion reason: 
				// yyy(self) -> LuaIVec3

				// Exclusion reason: 
				// yyz(self) -> LuaIVec3

				// Exclusion reason: 
				// yzx(self) -> LuaIVec3

				// Exclusion reason: 
				// yzy(self) -> LuaIVec3

				// Exclusion reason: 
				// yzz(self) -> LuaIVec3

				// Exclusion reason: 
				// zxx(self) -> LuaIVec3

				// Exclusion reason: 
				// zxy(self) -> LuaIVec3

				// Exclusion reason: 
				// zxz(self) -> LuaIVec3

				// Exclusion reason: 
				// zyx(self) -> LuaIVec3

				// Exclusion reason: 
				// zyy(self) -> LuaIVec3

				// Exclusion reason: 
				// zyz(self) -> LuaIVec3

				// Exclusion reason: 
				// zzx(self) -> LuaIVec3

				// Exclusion reason: 
				// zzy(self) -> LuaIVec3

				// Exclusion reason: 
				// zzz(self) -> LuaIVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xxxz(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyz(self) -> LuaIVec4

				// Exclusion reason: 
				// xxzx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxzy(self) -> LuaIVec4

				// Exclusion reason: 
				// xxzz(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxz(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyz(self) -> LuaIVec4

				// Exclusion reason: 
				// xyzx(self) -> LuaIVec4

				// Exclusion reason: 
				// xyzy(self) -> LuaIVec4

				// Exclusion reason: 
				// xyzz(self) -> LuaIVec4

				// Exclusion reason: 
				// xzxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xzxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xzxz(self) -> LuaIVec4

				// Exclusion reason: 
				// xzyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xzyy(self) -> LuaIVec4

				// Exclusion reason: 
				// xzyz(self) -> LuaIVec4

				// Exclusion reason: 
				// xzzx(self) -> LuaIVec4

				// Exclusion reason: 
				// xzzy(self) -> LuaIVec4

				// Exclusion reason: 
				// xzzz(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxz(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyz(self) -> LuaIVec4

				// Exclusion reason: 
				// yxzx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxzy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxzz(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxz(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyz(self) -> LuaIVec4

				// Exclusion reason: 
				// yyzx(self) -> LuaIVec4

				// Exclusion reason: 
				// yyzy(self) -> LuaIVec4

				// Exclusion reason: 
				// yyzz(self) -> LuaIVec4

				// Exclusion reason: 
				// yzxx(self) -> LuaIVec4

				// Exclusion reason: 
				// yzxy(self) -> LuaIVec4

				// Exclusion reason: 
				// yzxz(self) -> LuaIVec4

				// Exclusion reason: 
				// yzyx(self) -> LuaIVec4

				// Exclusion reason: 
				// yzyy(self) -> LuaIVec4

				// Exclusion reason: 
				// yzyz(self) -> LuaIVec4

				// Exclusion reason: 
				// yzzx(self) -> LuaIVec4

				// Exclusion reason: 
				// yzzy(self) -> LuaIVec4

				// Exclusion reason: 
				// yzzz(self) -> LuaIVec4

				// Exclusion reason: 
				// zxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// zxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// zxxz(self) -> LuaIVec4

				// Exclusion reason: 
				// zxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// zxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// zxyz(self) -> LuaIVec4

				// Exclusion reason: 
				// zxzx(self) -> LuaIVec4

				// Exclusion reason: 
				// zxzy(self) -> LuaIVec4

				// Exclusion reason: 
				// zxzz(self) -> LuaIVec4

				// Exclusion reason: 
				// zyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// zyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// zyxz(self) -> LuaIVec4

				// Exclusion reason: 
				// zyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// zyyy(self) -> LuaIVec4

				// Exclusion reason: 
				// zyyz(self) -> LuaIVec4

				// Exclusion reason: 
				// zyzx(self) -> LuaIVec4

				// Exclusion reason: 
				// zyzy(self) -> LuaIVec4

				// Exclusion reason: 
				// zyzz(self) -> LuaIVec4

				// Exclusion reason: 
				// zzxx(self) -> LuaIVec4

				// Exclusion reason: 
				// zzxy(self) -> LuaIVec4

				// Exclusion reason: 
				// zzxz(self) -> LuaIVec4

				// Exclusion reason: 
				// zzyx(self) -> LuaIVec4

				// Exclusion reason: 
				// zzyy(self) -> LuaIVec4

				// Exclusion reason: 
				// zzyz(self) -> LuaIVec4

				// Exclusion reason: 
				// zzzx(self) -> LuaIVec4

				// Exclusion reason: 
				// zzzy(self) -> LuaIVec4

				// Exclusion reason: 
				// zzzz(self) -> LuaIVec4

			)
+ BinaryOps			(
self Add LuaIVec3 -> LuaIVec3 -> LuaIVec3
self Add i32 -> LuaIVec3 -> LuaIVec3
i32 Add self -> LuaIVec3 -> LuaIVec3
self Sub LuaIVec3 -> LuaIVec3 -> LuaIVec3
self Sub i32 -> LuaIVec3 -> LuaIVec3
i32 Sub self -> LuaIVec3 -> LuaIVec3
self Div LuaIVec3 -> LuaIVec3 -> LuaIVec3
self Div i32 -> LuaIVec3 -> LuaIVec3
i32 Div self -> LuaIVec3 -> LuaIVec3
self Mul LuaIVec3 -> LuaIVec3 -> LuaIVec3
self Mul i32 -> LuaIVec3 -> LuaIVec3
i32 Mul self -> LuaIVec3 -> LuaIVec3
self Rem LuaIVec3 -> LuaIVec3 -> LuaIVec3
self Rem i32 -> LuaIVec3 -> LuaIVec3
i32 Rem self -> LuaIVec3 -> LuaIVec3
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaIVec3),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=i32))
			    
impl			{
			}
		}
		{
			///A 4-dimensional vector.
glam::i32::ivec4::IVec4 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(i32i32i32i32) -> LuaIVec4

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(i32) -> LuaIVec4

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaIVec4LuaIVec4) -> LuaIVec4

				///Creates a new vector from an array.
				from_array(<invalid: [i32;4]>) -> LuaIVec4

				///`[x, y, z, w]`
				to_array(&self)<invalid: [i32;4]>

				///Creates a vector from the first 4 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 4 elements long.
				from_slice(<invalid: &[i32]>) -> LuaIVec4

				///Writes the elements of `self` to the first 4 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 4 elements long.
				write_to_slice(self<invalid: &mut [i32]>)

				// Exclusion reason: 
				// ///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
				// ///
				// ///Truncation to `IVec3` may also be performed by using `self.xyz()` or `IVec3::from()`.
				// truncate(self) -> LuaIVec3

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaIVec4) -> i32

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaIVec4) -> LuaIVec4

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaIVec4) -> LuaIVec4

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaIVec4LuaIVec4) -> LuaIVec4

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> i32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> i32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaIVec4)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaIVec4)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaIVec4)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaIVec4)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaIVec4)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaIVec4)

				// Exclusion reason: 
				// ///Returns a vector containing the absolute value of each element of `self`.
				// abs(self) -> LuaIVec4

				// Exclusion reason: 
				// ///Returns a vector with elements representing the sign of `self`.
				// ///
				// ///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				// ///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				// ///- `NAN` if the number is `NAN`
				// signum(self) -> LuaIVec4

				///Casts all elements of `self` to `f32`.
				as_vec4(&self)

				///Casts all elements of `self` to `f64`.
				as_dvec4(&self)

				///Casts all elements of `self` to `u32`.
				as_uvec4(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [i32;4]>) -> LuaIVec4

				// Exclusion reason: 
				// from(LuaIVec4) -> LuaIVec4

				from(<invalid: (i32,i32,i32,i32)>) -> LuaIVec4

				// Exclusion reason: 
				// from(LuaIVec4) -> LuaIVec4

				from(<invalid: (LuaIVec3,i32)>) -> LuaIVec4

				from(<invalid: (i32,LuaIVec3)>) -> LuaIVec4

				from(<invalid: (LuaIVec2,i32,i32)>) -> LuaIVec4

				from(<invalid: (LuaIVec2,LuaIVec2)>) -> LuaIVec4

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				// Exclusion reason: 
				// clone(&self) -> LuaIVec4

				// Exclusion reason: 
				// default() -> LuaIVec4

				// Exclusion reason: 
				// eq(&self&LuaIVec4) -> bool

				// Exclusion reason: 
				// div(selfLuaIVec4) -> LuaIVec4

				// Exclusion reason: 
				// div(selfi32) -> LuaIVec4

				// Exclusion reason: 
				// div(selfLuaIVec4) -> LuaIVec4

				div_assign(<invalid: &mut self>LuaIVec4)

				div_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// mul(selfLuaIVec4) -> LuaIVec4

				// Exclusion reason: 
				// mul(selfi32) -> LuaIVec4

				// Exclusion reason: 
				// mul(selfLuaIVec4) -> LuaIVec4

				mul_assign(<invalid: &mut self>LuaIVec4)

				mul_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// add(selfLuaIVec4) -> LuaIVec4

				// Exclusion reason: 
				// add(selfi32) -> LuaIVec4

				// Exclusion reason: 
				// add(selfLuaIVec4) -> LuaIVec4

				add_assign(<invalid: &mut self>LuaIVec4)

				add_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// sub(selfLuaIVec4) -> LuaIVec4

				// Exclusion reason: 
				// sub(selfi32) -> LuaIVec4

				// Exclusion reason: 
				// sub(selfLuaIVec4) -> LuaIVec4

				sub_assign(<invalid: &mut self>LuaIVec4)

				sub_assign(<invalid: &mut self>i32)

				// Exclusion reason: 
				// rem(selfLuaIVec4) -> LuaIVec4

				// Exclusion reason: 
				// rem(selfi32) -> LuaIVec4

				// Exclusion reason: 
				// rem(selfLuaIVec4) -> LuaIVec4

				rem_assign(<invalid: &mut self>LuaIVec4)

				rem_assign(<invalid: &mut self>i32)

				as_ref(&self)<invalid: &[i32;4]>

				as_mut(<invalid: &mut self>)<invalid: &mut [i32;4]>

				sum() -> LuaIVec4

				product() -> LuaIVec4

				// Exclusion reason: 
				// neg(self) -> LuaIVec4

				hash(&self)

				not(self)

				bitand(selfLuaIVec4)

				bitand(selfi32)

				bitor(selfLuaIVec4)

				bitor(selfi32)

				bitxor(selfLuaIVec4)

				bitxor(selfi32)

				shl(selfi8)

				shl(selfi16)

				shl(selfi32)

				shl(selfu8)

				shl(selfu16)

				shl(selfu32)

				shl(self)

				shl(self)

				shl(self)

				shr(selfi8)

				shr(selfi16)

				shr(selfi32)

				shr(selfu8)

				shr(selfu16)

				shr(selfu32)

				shr(self)

				shr(self)

				shr(self)

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaIVec2

				// Exclusion reason: 
				// xy(self) -> LuaIVec2

				// Exclusion reason: 
				// xz(self) -> LuaIVec2

				// Exclusion reason: 
				// xw(self) -> LuaIVec2

				// Exclusion reason: 
				// yx(self) -> LuaIVec2

				// Exclusion reason: 
				// yy(self) -> LuaIVec2

				// Exclusion reason: 
				// yz(self) -> LuaIVec2

				// Exclusion reason: 
				// yw(self) -> LuaIVec2

				// Exclusion reason: 
				// zx(self) -> LuaIVec2

				// Exclusion reason: 
				// zy(self) -> LuaIVec2

				// Exclusion reason: 
				// zz(self) -> LuaIVec2

				// Exclusion reason: 
				// zw(self) -> LuaIVec2

				// Exclusion reason: 
				// wx(self) -> LuaIVec2

				// Exclusion reason: 
				// wy(self) -> LuaIVec2

				// Exclusion reason: 
				// wz(self) -> LuaIVec2

				// Exclusion reason: 
				// ww(self) -> LuaIVec2

				// Exclusion reason: 
				// xxx(self) -> LuaIVec3

				// Exclusion reason: 
				// xxy(self) -> LuaIVec3

				// Exclusion reason: 
				// xxz(self) -> LuaIVec3

				// Exclusion reason: 
				// xxw(self) -> LuaIVec3

				// Exclusion reason: 
				// xyx(self) -> LuaIVec3

				// Exclusion reason: 
				// xyy(self) -> LuaIVec3

				// Exclusion reason: 
				// xyz(self) -> LuaIVec3

				// Exclusion reason: 
				// xyw(self) -> LuaIVec3

				// Exclusion reason: 
				// xzx(self) -> LuaIVec3

				// Exclusion reason: 
				// xzy(self) -> LuaIVec3

				// Exclusion reason: 
				// xzz(self) -> LuaIVec3

				// Exclusion reason: 
				// xzw(self) -> LuaIVec3

				// Exclusion reason: 
				// xwx(self) -> LuaIVec3

				// Exclusion reason: 
				// xwy(self) -> LuaIVec3

				// Exclusion reason: 
				// xwz(self) -> LuaIVec3

				// Exclusion reason: 
				// xww(self) -> LuaIVec3

				// Exclusion reason: 
				// yxx(self) -> LuaIVec3

				// Exclusion reason: 
				// yxy(self) -> LuaIVec3

				// Exclusion reason: 
				// yxz(self) -> LuaIVec3

				// Exclusion reason: 
				// yxw(self) -> LuaIVec3

				// Exclusion reason: 
				// yyx(self) -> LuaIVec3

				// Exclusion reason: 
				// yyy(self) -> LuaIVec3

				// Exclusion reason: 
				// yyz(self) -> LuaIVec3

				// Exclusion reason: 
				// yyw(self) -> LuaIVec3

				// Exclusion reason: 
				// yzx(self) -> LuaIVec3

				// Exclusion reason: 
				// yzy(self) -> LuaIVec3

				// Exclusion reason: 
				// yzz(self) -> LuaIVec3

				// Exclusion reason: 
				// yzw(self) -> LuaIVec3

				// Exclusion reason: 
				// ywx(self) -> LuaIVec3

				// Exclusion reason: 
				// ywy(self) -> LuaIVec3

				// Exclusion reason: 
				// ywz(self) -> LuaIVec3

				// Exclusion reason: 
				// yww(self) -> LuaIVec3

				// Exclusion reason: 
				// zxx(self) -> LuaIVec3

				// Exclusion reason: 
				// zxy(self) -> LuaIVec3

				// Exclusion reason: 
				// zxz(self) -> LuaIVec3

				// Exclusion reason: 
				// zxw(self) -> LuaIVec3

				// Exclusion reason: 
				// zyx(self) -> LuaIVec3

				// Exclusion reason: 
				// zyy(self) -> LuaIVec3

				// Exclusion reason: 
				// zyz(self) -> LuaIVec3

				// Exclusion reason: 
				// zyw(self) -> LuaIVec3

				// Exclusion reason: 
				// zzx(self) -> LuaIVec3

				// Exclusion reason: 
				// zzy(self) -> LuaIVec3

				// Exclusion reason: 
				// zzz(self) -> LuaIVec3

				// Exclusion reason: 
				// zzw(self) -> LuaIVec3

				// Exclusion reason: 
				// zwx(self) -> LuaIVec3

				// Exclusion reason: 
				// zwy(self) -> LuaIVec3

				// Exclusion reason: 
				// zwz(self) -> LuaIVec3

				// Exclusion reason: 
				// zww(self) -> LuaIVec3

				// Exclusion reason: 
				// wxx(self) -> LuaIVec3

				// Exclusion reason: 
				// wxy(self) -> LuaIVec3

				// Exclusion reason: 
				// wxz(self) -> LuaIVec3

				// Exclusion reason: 
				// wxw(self) -> LuaIVec3

				// Exclusion reason: 
				// wyx(self) -> LuaIVec3

				// Exclusion reason: 
				// wyy(self) -> LuaIVec3

				// Exclusion reason: 
				// wyz(self) -> LuaIVec3

				// Exclusion reason: 
				// wyw(self) -> LuaIVec3

				// Exclusion reason: 
				// wzx(self) -> LuaIVec3

				// Exclusion reason: 
				// wzy(self) -> LuaIVec3

				// Exclusion reason: 
				// wzz(self) -> LuaIVec3

				// Exclusion reason: 
				// wzw(self) -> LuaIVec3

				// Exclusion reason: 
				// wwx(self) -> LuaIVec3

				// Exclusion reason: 
				// wwy(self) -> LuaIVec3

				// Exclusion reason: 
				// wwz(self) -> LuaIVec3

				// Exclusion reason: 
				// www(self) -> LuaIVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xxxz(self) -> LuaIVec4

				// Exclusion reason: 
				// xxxw(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyz(self) -> LuaIVec4

				// Exclusion reason: 
				// xxyw(self) -> LuaIVec4

				// Exclusion reason: 
				// xxzx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxzy(self) -> LuaIVec4

				// Exclusion reason: 
				// xxzz(self) -> LuaIVec4

				// Exclusion reason: 
				// xxzw(self) -> LuaIVec4

				// Exclusion reason: 
				// xxwx(self) -> LuaIVec4

				// Exclusion reason: 
				// xxwy(self) -> LuaIVec4

				// Exclusion reason: 
				// xxwz(self) -> LuaIVec4

				// Exclusion reason: 
				// xxww(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxz(self) -> LuaIVec4

				// Exclusion reason: 
				// xyxw(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyz(self) -> LuaIVec4

				// Exclusion reason: 
				// xyyw(self) -> LuaIVec4

				// Exclusion reason: 
				// xyzx(self) -> LuaIVec4

				// Exclusion reason: 
				// xyzy(self) -> LuaIVec4

				// Exclusion reason: 
				// xyzz(self) -> LuaIVec4

				// Exclusion reason: 
				// xyzw(self) -> LuaIVec4

				// Exclusion reason: 
				// xywx(self) -> LuaIVec4

				// Exclusion reason: 
				// xywy(self) -> LuaIVec4

				// Exclusion reason: 
				// xywz(self) -> LuaIVec4

				// Exclusion reason: 
				// xyww(self) -> LuaIVec4

				// Exclusion reason: 
				// xzxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xzxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xzxz(self) -> LuaIVec4

				// Exclusion reason: 
				// xzxw(self) -> LuaIVec4

				// Exclusion reason: 
				// xzyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xzyy(self) -> LuaIVec4

				// Exclusion reason: 
				// xzyz(self) -> LuaIVec4

				// Exclusion reason: 
				// xzyw(self) -> LuaIVec4

				// Exclusion reason: 
				// xzzx(self) -> LuaIVec4

				// Exclusion reason: 
				// xzzy(self) -> LuaIVec4

				// Exclusion reason: 
				// xzzz(self) -> LuaIVec4

				// Exclusion reason: 
				// xzzw(self) -> LuaIVec4

				// Exclusion reason: 
				// xzwx(self) -> LuaIVec4

				// Exclusion reason: 
				// xzwy(self) -> LuaIVec4

				// Exclusion reason: 
				// xzwz(self) -> LuaIVec4

				// Exclusion reason: 
				// xzww(self) -> LuaIVec4

				// Exclusion reason: 
				// xwxx(self) -> LuaIVec4

				// Exclusion reason: 
				// xwxy(self) -> LuaIVec4

				// Exclusion reason: 
				// xwxz(self) -> LuaIVec4

				// Exclusion reason: 
				// xwxw(self) -> LuaIVec4

				// Exclusion reason: 
				// xwyx(self) -> LuaIVec4

				// Exclusion reason: 
				// xwyy(self) -> LuaIVec4

				// Exclusion reason: 
				// xwyz(self) -> LuaIVec4

				// Exclusion reason: 
				// xwyw(self) -> LuaIVec4

				// Exclusion reason: 
				// xwzx(self) -> LuaIVec4

				// Exclusion reason: 
				// xwzy(self) -> LuaIVec4

				// Exclusion reason: 
				// xwzz(self) -> LuaIVec4

				// Exclusion reason: 
				// xwzw(self) -> LuaIVec4

				// Exclusion reason: 
				// xwwx(self) -> LuaIVec4

				// Exclusion reason: 
				// xwwy(self) -> LuaIVec4

				// Exclusion reason: 
				// xwwz(self) -> LuaIVec4

				// Exclusion reason: 
				// xwww(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxz(self) -> LuaIVec4

				// Exclusion reason: 
				// yxxw(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyz(self) -> LuaIVec4

				// Exclusion reason: 
				// yxyw(self) -> LuaIVec4

				// Exclusion reason: 
				// yxzx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxzy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxzz(self) -> LuaIVec4

				// Exclusion reason: 
				// yxzw(self) -> LuaIVec4

				// Exclusion reason: 
				// yxwx(self) -> LuaIVec4

				// Exclusion reason: 
				// yxwy(self) -> LuaIVec4

				// Exclusion reason: 
				// yxwz(self) -> LuaIVec4

				// Exclusion reason: 
				// yxww(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxz(self) -> LuaIVec4

				// Exclusion reason: 
				// yyxw(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyz(self) -> LuaIVec4

				// Exclusion reason: 
				// yyyw(self) -> LuaIVec4

				// Exclusion reason: 
				// yyzx(self) -> LuaIVec4

				// Exclusion reason: 
				// yyzy(self) -> LuaIVec4

				// Exclusion reason: 
				// yyzz(self) -> LuaIVec4

				// Exclusion reason: 
				// yyzw(self) -> LuaIVec4

				// Exclusion reason: 
				// yywx(self) -> LuaIVec4

				// Exclusion reason: 
				// yywy(self) -> LuaIVec4

				// Exclusion reason: 
				// yywz(self) -> LuaIVec4

				// Exclusion reason: 
				// yyww(self) -> LuaIVec4

				// Exclusion reason: 
				// yzxx(self) -> LuaIVec4

				// Exclusion reason: 
				// yzxy(self) -> LuaIVec4

				// Exclusion reason: 
				// yzxz(self) -> LuaIVec4

				// Exclusion reason: 
				// yzxw(self) -> LuaIVec4

				// Exclusion reason: 
				// yzyx(self) -> LuaIVec4

				// Exclusion reason: 
				// yzyy(self) -> LuaIVec4

				// Exclusion reason: 
				// yzyz(self) -> LuaIVec4

				// Exclusion reason: 
				// yzyw(self) -> LuaIVec4

				// Exclusion reason: 
				// yzzx(self) -> LuaIVec4

				// Exclusion reason: 
				// yzzy(self) -> LuaIVec4

				// Exclusion reason: 
				// yzzz(self) -> LuaIVec4

				// Exclusion reason: 
				// yzzw(self) -> LuaIVec4

				// Exclusion reason: 
				// yzwx(self) -> LuaIVec4

				// Exclusion reason: 
				// yzwy(self) -> LuaIVec4

				// Exclusion reason: 
				// yzwz(self) -> LuaIVec4

				// Exclusion reason: 
				// yzww(self) -> LuaIVec4

				// Exclusion reason: 
				// ywxx(self) -> LuaIVec4

				// Exclusion reason: 
				// ywxy(self) -> LuaIVec4

				// Exclusion reason: 
				// ywxz(self) -> LuaIVec4

				// Exclusion reason: 
				// ywxw(self) -> LuaIVec4

				// Exclusion reason: 
				// ywyx(self) -> LuaIVec4

				// Exclusion reason: 
				// ywyy(self) -> LuaIVec4

				// Exclusion reason: 
				// ywyz(self) -> LuaIVec4

				// Exclusion reason: 
				// ywyw(self) -> LuaIVec4

				// Exclusion reason: 
				// ywzx(self) -> LuaIVec4

				// Exclusion reason: 
				// ywzy(self) -> LuaIVec4

				// Exclusion reason: 
				// ywzz(self) -> LuaIVec4

				// Exclusion reason: 
				// ywzw(self) -> LuaIVec4

				// Exclusion reason: 
				// ywwx(self) -> LuaIVec4

				// Exclusion reason: 
				// ywwy(self) -> LuaIVec4

				// Exclusion reason: 
				// ywwz(self) -> LuaIVec4

				// Exclusion reason: 
				// ywww(self) -> LuaIVec4

				// Exclusion reason: 
				// zxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// zxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// zxxz(self) -> LuaIVec4

				// Exclusion reason: 
				// zxxw(self) -> LuaIVec4

				// Exclusion reason: 
				// zxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// zxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// zxyz(self) -> LuaIVec4

				// Exclusion reason: 
				// zxyw(self) -> LuaIVec4

				// Exclusion reason: 
				// zxzx(self) -> LuaIVec4

				// Exclusion reason: 
				// zxzy(self) -> LuaIVec4

				// Exclusion reason: 
				// zxzz(self) -> LuaIVec4

				// Exclusion reason: 
				// zxzw(self) -> LuaIVec4

				// Exclusion reason: 
				// zxwx(self) -> LuaIVec4

				// Exclusion reason: 
				// zxwy(self) -> LuaIVec4

				// Exclusion reason: 
				// zxwz(self) -> LuaIVec4

				// Exclusion reason: 
				// zxww(self) -> LuaIVec4

				// Exclusion reason: 
				// zyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// zyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// zyxz(self) -> LuaIVec4

				// Exclusion reason: 
				// zyxw(self) -> LuaIVec4

				// Exclusion reason: 
				// zyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// zyyy(self) -> LuaIVec4

				// Exclusion reason: 
				// zyyz(self) -> LuaIVec4

				// Exclusion reason: 
				// zyyw(self) -> LuaIVec4

				// Exclusion reason: 
				// zyzx(self) -> LuaIVec4

				// Exclusion reason: 
				// zyzy(self) -> LuaIVec4

				// Exclusion reason: 
				// zyzz(self) -> LuaIVec4

				// Exclusion reason: 
				// zyzw(self) -> LuaIVec4

				// Exclusion reason: 
				// zywx(self) -> LuaIVec4

				// Exclusion reason: 
				// zywy(self) -> LuaIVec4

				// Exclusion reason: 
				// zywz(self) -> LuaIVec4

				// Exclusion reason: 
				// zyww(self) -> LuaIVec4

				// Exclusion reason: 
				// zzxx(self) -> LuaIVec4

				// Exclusion reason: 
				// zzxy(self) -> LuaIVec4

				// Exclusion reason: 
				// zzxz(self) -> LuaIVec4

				// Exclusion reason: 
				// zzxw(self) -> LuaIVec4

				// Exclusion reason: 
				// zzyx(self) -> LuaIVec4

				// Exclusion reason: 
				// zzyy(self) -> LuaIVec4

				// Exclusion reason: 
				// zzyz(self) -> LuaIVec4

				// Exclusion reason: 
				// zzyw(self) -> LuaIVec4

				// Exclusion reason: 
				// zzzx(self) -> LuaIVec4

				// Exclusion reason: 
				// zzzy(self) -> LuaIVec4

				// Exclusion reason: 
				// zzzz(self) -> LuaIVec4

				// Exclusion reason: 
				// zzzw(self) -> LuaIVec4

				// Exclusion reason: 
				// zzwx(self) -> LuaIVec4

				// Exclusion reason: 
				// zzwy(self) -> LuaIVec4

				// Exclusion reason: 
				// zzwz(self) -> LuaIVec4

				// Exclusion reason: 
				// zzww(self) -> LuaIVec4

				// Exclusion reason: 
				// zwxx(self) -> LuaIVec4

				// Exclusion reason: 
				// zwxy(self) -> LuaIVec4

				// Exclusion reason: 
				// zwxz(self) -> LuaIVec4

				// Exclusion reason: 
				// zwxw(self) -> LuaIVec4

				// Exclusion reason: 
				// zwyx(self) -> LuaIVec4

				// Exclusion reason: 
				// zwyy(self) -> LuaIVec4

				// Exclusion reason: 
				// zwyz(self) -> LuaIVec4

				// Exclusion reason: 
				// zwyw(self) -> LuaIVec4

				// Exclusion reason: 
				// zwzx(self) -> LuaIVec4

				// Exclusion reason: 
				// zwzy(self) -> LuaIVec4

				// Exclusion reason: 
				// zwzz(self) -> LuaIVec4

				// Exclusion reason: 
				// zwzw(self) -> LuaIVec4

				// Exclusion reason: 
				// zwwx(self) -> LuaIVec4

				// Exclusion reason: 
				// zwwy(self) -> LuaIVec4

				// Exclusion reason: 
				// zwwz(self) -> LuaIVec4

				// Exclusion reason: 
				// zwww(self) -> LuaIVec4

				// Exclusion reason: 
				// wxxx(self) -> LuaIVec4

				// Exclusion reason: 
				// wxxy(self) -> LuaIVec4

				// Exclusion reason: 
				// wxxz(self) -> LuaIVec4

				// Exclusion reason: 
				// wxxw(self) -> LuaIVec4

				// Exclusion reason: 
				// wxyx(self) -> LuaIVec4

				// Exclusion reason: 
				// wxyy(self) -> LuaIVec4

				// Exclusion reason: 
				// wxyz(self) -> LuaIVec4

				// Exclusion reason: 
				// wxyw(self) -> LuaIVec4

				// Exclusion reason: 
				// wxzx(self) -> LuaIVec4

				// Exclusion reason: 
				// wxzy(self) -> LuaIVec4

				// Exclusion reason: 
				// wxzz(self) -> LuaIVec4

				// Exclusion reason: 
				// wxzw(self) -> LuaIVec4

				// Exclusion reason: 
				// wxwx(self) -> LuaIVec4

				// Exclusion reason: 
				// wxwy(self) -> LuaIVec4

				// Exclusion reason: 
				// wxwz(self) -> LuaIVec4

				// Exclusion reason: 
				// wxww(self) -> LuaIVec4

				// Exclusion reason: 
				// wyxx(self) -> LuaIVec4

				// Exclusion reason: 
				// wyxy(self) -> LuaIVec4

				// Exclusion reason: 
				// wyxz(self) -> LuaIVec4

				// Exclusion reason: 
				// wyxw(self) -> LuaIVec4

				// Exclusion reason: 
				// wyyx(self) -> LuaIVec4

				// Exclusion reason: 
				// wyyy(self) -> LuaIVec4

				// Exclusion reason: 
				// wyyz(self) -> LuaIVec4

				// Exclusion reason: 
				// wyyw(self) -> LuaIVec4

				// Exclusion reason: 
				// wyzx(self) -> LuaIVec4

				// Exclusion reason: 
				// wyzy(self) -> LuaIVec4

				// Exclusion reason: 
				// wyzz(self) -> LuaIVec4

				// Exclusion reason: 
				// wyzw(self) -> LuaIVec4

				// Exclusion reason: 
				// wywx(self) -> LuaIVec4

				// Exclusion reason: 
				// wywy(self) -> LuaIVec4

				// Exclusion reason: 
				// wywz(self) -> LuaIVec4

				// Exclusion reason: 
				// wyww(self) -> LuaIVec4

				// Exclusion reason: 
				// wzxx(self) -> LuaIVec4

				// Exclusion reason: 
				// wzxy(self) -> LuaIVec4

				// Exclusion reason: 
				// wzxz(self) -> LuaIVec4

				// Exclusion reason: 
				// wzxw(self) -> LuaIVec4

				// Exclusion reason: 
				// wzyx(self) -> LuaIVec4

				// Exclusion reason: 
				// wzyy(self) -> LuaIVec4

				// Exclusion reason: 
				// wzyz(self) -> LuaIVec4

				// Exclusion reason: 
				// wzyw(self) -> LuaIVec4

				// Exclusion reason: 
				// wzzx(self) -> LuaIVec4

				// Exclusion reason: 
				// wzzy(self) -> LuaIVec4

				// Exclusion reason: 
				// wzzz(self) -> LuaIVec4

				// Exclusion reason: 
				// wzzw(self) -> LuaIVec4

				// Exclusion reason: 
				// wzwx(self) -> LuaIVec4

				// Exclusion reason: 
				// wzwy(self) -> LuaIVec4

				// Exclusion reason: 
				// wzwz(self) -> LuaIVec4

				// Exclusion reason: 
				// wzww(self) -> LuaIVec4

				// Exclusion reason: 
				// wwxx(self) -> LuaIVec4

				// Exclusion reason: 
				// wwxy(self) -> LuaIVec4

				// Exclusion reason: 
				// wwxz(self) -> LuaIVec4

				// Exclusion reason: 
				// wwxw(self) -> LuaIVec4

				// Exclusion reason: 
				// wwyx(self) -> LuaIVec4

				// Exclusion reason: 
				// wwyy(self) -> LuaIVec4

				// Exclusion reason: 
				// wwyz(self) -> LuaIVec4

				// Exclusion reason: 
				// wwyw(self) -> LuaIVec4

				// Exclusion reason: 
				// wwzx(self) -> LuaIVec4

				// Exclusion reason: 
				// wwzy(self) -> LuaIVec4

				// Exclusion reason: 
				// wwzz(self) -> LuaIVec4

				// Exclusion reason: 
				// wwzw(self) -> LuaIVec4

				// Exclusion reason: 
				// wwwx(self) -> LuaIVec4

				// Exclusion reason: 
				// wwwy(self) -> LuaIVec4

				// Exclusion reason: 
				// wwwz(self) -> LuaIVec4

				// Exclusion reason: 
				// wwww(self) -> LuaIVec4

			)
+ BinaryOps			(
self Add LuaIVec4 -> LuaIVec4 -> LuaIVec4
self Add i32 -> LuaIVec4 -> LuaIVec4
i32 Add self -> LuaIVec4 -> LuaIVec4
self Sub LuaIVec4 -> LuaIVec4 -> LuaIVec4
self Sub i32 -> LuaIVec4 -> LuaIVec4
i32 Sub self -> LuaIVec4 -> LuaIVec4
self Div LuaIVec4 -> LuaIVec4 -> LuaIVec4
self Div i32 -> LuaIVec4 -> LuaIVec4
i32 Div self -> LuaIVec4 -> LuaIVec4
self Mul LuaIVec4 -> LuaIVec4 -> LuaIVec4
self Mul i32 -> LuaIVec4 -> LuaIVec4
i32 Mul self -> LuaIVec4 -> LuaIVec4
self Rem LuaIVec4 -> LuaIVec4 -> LuaIVec4
self Rem i32 -> LuaIVec4 -> LuaIVec4
i32 Rem self -> LuaIVec4 -> LuaIVec4
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaIVec4),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=i32))
			    
impl			{
			}
		}
		{
			///A 2-dimensional vector.
glam::u32::uvec2::UVec2 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(u32u32) -> LuaUVec2

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(u32) -> LuaUVec2

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaUVec2LuaUVec2) -> LuaUVec2

				///Creates a new vector from an array.
				from_array(<invalid: [u32;2]>) -> LuaUVec2

				///`[x, y]`
				to_array(&self)<invalid: [u32;2]>

				///Creates a vector from the first 2 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 2 elements long.
				from_slice(<invalid: &[u32]>) -> LuaUVec2

				///Writes the elements of `self` to the first 2 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 2 elements long.
				write_to_slice(self<invalid: &mut [u32]>)

				// Exclusion reason: 
				// ///Creates a 3D vector from `self` and the given `z` value.
				// extend(selfu32) -> LuaUVec3

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaUVec2) -> u32

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaUVec2) -> LuaUVec2

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaUVec2) -> LuaUVec2

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaUVec2LuaUVec2) -> LuaUVec2

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> u32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> u32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaUVec2)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaUVec2)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaUVec2)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaUVec2)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaUVec2)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaUVec2)

				///Casts all elements of `self` to `f32`.
				as_vec2(&self)

				///Casts all elements of `self` to `f64`.
				as_dvec2(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec2(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [u32;2]>) -> LuaUVec2

				// Exclusion reason: 
				// from(LuaUVec2) -> LuaUVec2

				from(<invalid: (u32,u32)>) -> LuaUVec2

				// Exclusion reason: 
				// from(LuaUVec2) -> LuaUVec2

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				shl(self)

				shl(selfi8)

				shl(selfi16)

				shl(selfi32)

				shl(selfu8)

				shl(selfu16)

				shl(selfu32)

				shl(self)

				shl(self)

				shr(self)

				shr(selfi8)

				shr(selfi16)

				shr(selfi32)

				shr(selfu8)

				shr(selfu16)

				shr(selfu32)

				shr(self)

				shr(self)

				// Exclusion reason: 
				// clone(&self) -> LuaUVec2

				// Exclusion reason: 
				// default() -> LuaUVec2

				// Exclusion reason: 
				// eq(&self&LuaUVec2) -> bool

				// Exclusion reason: 
				// div(selfLuaUVec2) -> LuaUVec2

				// Exclusion reason: 
				// div(selfu32) -> LuaUVec2

				// Exclusion reason: 
				// div(selfLuaUVec2) -> LuaUVec2

				div_assign(<invalid: &mut self>LuaUVec2)

				div_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// mul(selfLuaUVec2) -> LuaUVec2

				// Exclusion reason: 
				// mul(selfu32) -> LuaUVec2

				// Exclusion reason: 
				// mul(selfLuaUVec2) -> LuaUVec2

				mul_assign(<invalid: &mut self>LuaUVec2)

				mul_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// add(selfLuaUVec2) -> LuaUVec2

				// Exclusion reason: 
				// add(selfu32) -> LuaUVec2

				// Exclusion reason: 
				// add(selfLuaUVec2) -> LuaUVec2

				add_assign(<invalid: &mut self>LuaUVec2)

				add_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// sub(selfLuaUVec2) -> LuaUVec2

				// Exclusion reason: 
				// sub(selfu32) -> LuaUVec2

				// Exclusion reason: 
				// sub(selfLuaUVec2) -> LuaUVec2

				sub_assign(<invalid: &mut self>LuaUVec2)

				sub_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// rem(selfLuaUVec2) -> LuaUVec2

				// Exclusion reason: 
				// rem(selfu32) -> LuaUVec2

				// Exclusion reason: 
				// rem(selfLuaUVec2) -> LuaUVec2

				rem_assign(<invalid: &mut self>LuaUVec2)

				rem_assign(<invalid: &mut self>u32)

				as_ref(&self)<invalid: &[u32;2]>

				as_mut(<invalid: &mut self>)<invalid: &mut [u32;2]>

				sum() -> LuaUVec2

				product() -> LuaUVec2

				hash(&self)

				not(self)

				bitand(selfLuaUVec2)

				bitand(selfu32)

				bitor(selfLuaUVec2)

				bitor(selfu32)

				bitxor(selfLuaUVec2)

				bitxor(selfu32)

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaUVec2

				// Exclusion reason: 
				// xy(self) -> LuaUVec2

				// Exclusion reason: 
				// yx(self) -> LuaUVec2

				// Exclusion reason: 
				// yy(self) -> LuaUVec2

				// Exclusion reason: 
				// xxx(self) -> LuaUVec3

				// Exclusion reason: 
				// xxy(self) -> LuaUVec3

				// Exclusion reason: 
				// xyx(self) -> LuaUVec3

				// Exclusion reason: 
				// xyy(self) -> LuaUVec3

				// Exclusion reason: 
				// yxx(self) -> LuaUVec3

				// Exclusion reason: 
				// yxy(self) -> LuaUVec3

				// Exclusion reason: 
				// yyx(self) -> LuaUVec3

				// Exclusion reason: 
				// yyy(self) -> LuaUVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaUVec4

			)
+ BinaryOps			(
self Add LuaUVec2 -> LuaUVec2 -> LuaUVec2
self Add u32 -> LuaUVec2 -> LuaUVec2
u32 Add self -> LuaUVec2 -> LuaUVec2
self Sub LuaUVec2 -> LuaUVec2 -> LuaUVec2
self Sub u32 -> LuaUVec2 -> LuaUVec2
u32 Sub self -> LuaUVec2 -> LuaUVec2
self Div LuaUVec2 -> LuaUVec2 -> LuaUVec2
self Div u32 -> LuaUVec2 -> LuaUVec2
u32 Div self -> LuaUVec2 -> LuaUVec2
self Mul LuaUVec2 -> LuaUVec2 -> LuaUVec2
self Mul u32 -> LuaUVec2 -> LuaUVec2
u32 Mul self -> LuaUVec2 -> LuaUVec2
self Rem LuaUVec2 -> LuaUVec2 -> LuaUVec2
self Rem u32 -> LuaUVec2 -> LuaUVec2
u32 Rem self -> LuaUVec2 -> LuaUVec2
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaUVec2),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=u32))
			    
impl			{
			}
		}
		{
			///A 3-dimensional vector.
glam::u32::uvec3::UVec3 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(u32u32u32) -> LuaUVec3

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(u32) -> LuaUVec3

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaUVec3LuaUVec3) -> LuaUVec3

				///Creates a new vector from an array.
				from_array(<invalid: [u32;3]>) -> LuaUVec3

				///`[x, y, z]`
				to_array(&self)<invalid: [u32;3]>

				///Creates a vector from the first 3 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 3 elements long.
				from_slice(<invalid: &[u32]>) -> LuaUVec3

				///Writes the elements of `self` to the first 3 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 3 elements long.
				write_to_slice(self<invalid: &mut [u32]>)

				// Exclusion reason: 
				// ///Creates a 4D vector from `self` and the given `w` value.
				// extend(selfu32) -> LuaUVec4

				// Exclusion reason: 
				// ///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				// ///
				// ///Truncation may also be performed by using `self.xy()` or `UVec2::from()`.
				// truncate(self) -> LuaUVec2

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaUVec3) -> u32

				// Exclusion reason: 
				// ///Computes the cross product of `self` and `rhs`.
				// cross(selfLuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaUVec3LuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> u32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> u32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaUVec3)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaUVec3)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaUVec3)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaUVec3)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaUVec3)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaUVec3)

				///Casts all elements of `self` to `f32`.
				as_vec3(&self)

				///Casts all elements of `self` to `f32`.
				as_vec3a(&self)

				///Casts all elements of `self` to `f64`.
				as_dvec3(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec3(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [u32;3]>) -> LuaUVec3

				// Exclusion reason: 
				// from(LuaUVec3) -> LuaUVec3

				from(<invalid: (u32,u32,u32)>) -> LuaUVec3

				// Exclusion reason: 
				// from(LuaUVec3) -> LuaUVec3

				from(<invalid: (LuaUVec2,u32)>) -> LuaUVec3

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				shl(self)

				shl(selfi8)

				shl(selfi16)

				shl(selfi32)

				shl(selfu8)

				shl(selfu16)

				shl(selfu32)

				shl(self)

				shl(self)

				shr(self)

				shr(selfi8)

				shr(selfi16)

				shr(selfi32)

				shr(selfu8)

				shr(selfu16)

				shr(selfu32)

				shr(self)

				shr(self)

				// Exclusion reason: 
				// clone(&self) -> LuaUVec3

				// Exclusion reason: 
				// default() -> LuaUVec3

				// Exclusion reason: 
				// eq(&self&LuaUVec3) -> bool

				// Exclusion reason: 
				// div(selfLuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// div(selfu32) -> LuaUVec3

				// Exclusion reason: 
				// div(selfLuaUVec3) -> LuaUVec3

				div_assign(<invalid: &mut self>LuaUVec3)

				div_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// mul(selfLuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// mul(selfu32) -> LuaUVec3

				// Exclusion reason: 
				// mul(selfLuaUVec3) -> LuaUVec3

				mul_assign(<invalid: &mut self>LuaUVec3)

				mul_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// add(selfLuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// add(selfu32) -> LuaUVec3

				// Exclusion reason: 
				// add(selfLuaUVec3) -> LuaUVec3

				add_assign(<invalid: &mut self>LuaUVec3)

				add_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// sub(selfLuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// sub(selfu32) -> LuaUVec3

				// Exclusion reason: 
				// sub(selfLuaUVec3) -> LuaUVec3

				sub_assign(<invalid: &mut self>LuaUVec3)

				sub_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// rem(selfLuaUVec3) -> LuaUVec3

				// Exclusion reason: 
				// rem(selfu32) -> LuaUVec3

				// Exclusion reason: 
				// rem(selfLuaUVec3) -> LuaUVec3

				rem_assign(<invalid: &mut self>LuaUVec3)

				rem_assign(<invalid: &mut self>u32)

				as_ref(&self)<invalid: &[u32;3]>

				as_mut(<invalid: &mut self>)<invalid: &mut [u32;3]>

				sum() -> LuaUVec3

				product() -> LuaUVec3

				hash(&self)

				not(self)

				bitand(selfLuaUVec3)

				bitand(selfu32)

				bitor(selfLuaUVec3)

				bitor(selfu32)

				bitxor(selfLuaUVec3)

				bitxor(selfu32)

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaUVec2

				// Exclusion reason: 
				// xy(self) -> LuaUVec2

				// Exclusion reason: 
				// xz(self) -> LuaUVec2

				// Exclusion reason: 
				// yx(self) -> LuaUVec2

				// Exclusion reason: 
				// yy(self) -> LuaUVec2

				// Exclusion reason: 
				// yz(self) -> LuaUVec2

				// Exclusion reason: 
				// zx(self) -> LuaUVec2

				// Exclusion reason: 
				// zy(self) -> LuaUVec2

				// Exclusion reason: 
				// zz(self) -> LuaUVec2

				// Exclusion reason: 
				// xxx(self) -> LuaUVec3

				// Exclusion reason: 
				// xxy(self) -> LuaUVec3

				// Exclusion reason: 
				// xxz(self) -> LuaUVec3

				// Exclusion reason: 
				// xyx(self) -> LuaUVec3

				// Exclusion reason: 
				// xyy(self) -> LuaUVec3

				// Exclusion reason: 
				// xyz(self) -> LuaUVec3

				// Exclusion reason: 
				// xzx(self) -> LuaUVec3

				// Exclusion reason: 
				// xzy(self) -> LuaUVec3

				// Exclusion reason: 
				// xzz(self) -> LuaUVec3

				// Exclusion reason: 
				// yxx(self) -> LuaUVec3

				// Exclusion reason: 
				// yxy(self) -> LuaUVec3

				// Exclusion reason: 
				// yxz(self) -> LuaUVec3

				// Exclusion reason: 
				// yyx(self) -> LuaUVec3

				// Exclusion reason: 
				// yyy(self) -> LuaUVec3

				// Exclusion reason: 
				// yyz(self) -> LuaUVec3

				// Exclusion reason: 
				// yzx(self) -> LuaUVec3

				// Exclusion reason: 
				// yzy(self) -> LuaUVec3

				// Exclusion reason: 
				// yzz(self) -> LuaUVec3

				// Exclusion reason: 
				// zxx(self) -> LuaUVec3

				// Exclusion reason: 
				// zxy(self) -> LuaUVec3

				// Exclusion reason: 
				// zxz(self) -> LuaUVec3

				// Exclusion reason: 
				// zyx(self) -> LuaUVec3

				// Exclusion reason: 
				// zyy(self) -> LuaUVec3

				// Exclusion reason: 
				// zyz(self) -> LuaUVec3

				// Exclusion reason: 
				// zzx(self) -> LuaUVec3

				// Exclusion reason: 
				// zzy(self) -> LuaUVec3

				// Exclusion reason: 
				// zzz(self) -> LuaUVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xxxz(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyz(self) -> LuaUVec4

				// Exclusion reason: 
				// xxzx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxzy(self) -> LuaUVec4

				// Exclusion reason: 
				// xxzz(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxz(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyz(self) -> LuaUVec4

				// Exclusion reason: 
				// xyzx(self) -> LuaUVec4

				// Exclusion reason: 
				// xyzy(self) -> LuaUVec4

				// Exclusion reason: 
				// xyzz(self) -> LuaUVec4

				// Exclusion reason: 
				// xzxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xzxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xzxz(self) -> LuaUVec4

				// Exclusion reason: 
				// xzyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xzyy(self) -> LuaUVec4

				// Exclusion reason: 
				// xzyz(self) -> LuaUVec4

				// Exclusion reason: 
				// xzzx(self) -> LuaUVec4

				// Exclusion reason: 
				// xzzy(self) -> LuaUVec4

				// Exclusion reason: 
				// xzzz(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxz(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyz(self) -> LuaUVec4

				// Exclusion reason: 
				// yxzx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxzy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxzz(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxz(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyz(self) -> LuaUVec4

				// Exclusion reason: 
				// yyzx(self) -> LuaUVec4

				// Exclusion reason: 
				// yyzy(self) -> LuaUVec4

				// Exclusion reason: 
				// yyzz(self) -> LuaUVec4

				// Exclusion reason: 
				// yzxx(self) -> LuaUVec4

				// Exclusion reason: 
				// yzxy(self) -> LuaUVec4

				// Exclusion reason: 
				// yzxz(self) -> LuaUVec4

				// Exclusion reason: 
				// yzyx(self) -> LuaUVec4

				// Exclusion reason: 
				// yzyy(self) -> LuaUVec4

				// Exclusion reason: 
				// yzyz(self) -> LuaUVec4

				// Exclusion reason: 
				// yzzx(self) -> LuaUVec4

				// Exclusion reason: 
				// yzzy(self) -> LuaUVec4

				// Exclusion reason: 
				// yzzz(self) -> LuaUVec4

				// Exclusion reason: 
				// zxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// zxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// zxxz(self) -> LuaUVec4

				// Exclusion reason: 
				// zxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// zxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// zxyz(self) -> LuaUVec4

				// Exclusion reason: 
				// zxzx(self) -> LuaUVec4

				// Exclusion reason: 
				// zxzy(self) -> LuaUVec4

				// Exclusion reason: 
				// zxzz(self) -> LuaUVec4

				// Exclusion reason: 
				// zyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// zyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// zyxz(self) -> LuaUVec4

				// Exclusion reason: 
				// zyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// zyyy(self) -> LuaUVec4

				// Exclusion reason: 
				// zyyz(self) -> LuaUVec4

				// Exclusion reason: 
				// zyzx(self) -> LuaUVec4

				// Exclusion reason: 
				// zyzy(self) -> LuaUVec4

				// Exclusion reason: 
				// zyzz(self) -> LuaUVec4

				// Exclusion reason: 
				// zzxx(self) -> LuaUVec4

				// Exclusion reason: 
				// zzxy(self) -> LuaUVec4

				// Exclusion reason: 
				// zzxz(self) -> LuaUVec4

				// Exclusion reason: 
				// zzyx(self) -> LuaUVec4

				// Exclusion reason: 
				// zzyy(self) -> LuaUVec4

				// Exclusion reason: 
				// zzyz(self) -> LuaUVec4

				// Exclusion reason: 
				// zzzx(self) -> LuaUVec4

				// Exclusion reason: 
				// zzzy(self) -> LuaUVec4

				// Exclusion reason: 
				// zzzz(self) -> LuaUVec4

			)
+ BinaryOps			(
self Add LuaUVec3 -> LuaUVec3 -> LuaUVec3
self Add u32 -> LuaUVec3 -> LuaUVec3
u32 Add self -> LuaUVec3 -> LuaUVec3
self Sub LuaUVec3 -> LuaUVec3 -> LuaUVec3
self Sub u32 -> LuaUVec3 -> LuaUVec3
u32 Sub self -> LuaUVec3 -> LuaUVec3
self Div LuaUVec3 -> LuaUVec3 -> LuaUVec3
self Div u32 -> LuaUVec3 -> LuaUVec3
u32 Div self -> LuaUVec3 -> LuaUVec3
self Mul LuaUVec3 -> LuaUVec3 -> LuaUVec3
self Mul u32 -> LuaUVec3 -> LuaUVec3
u32 Mul self -> LuaUVec3 -> LuaUVec3
self Rem LuaUVec3 -> LuaUVec3 -> LuaUVec3
self Rem u32 -> LuaUVec3 -> LuaUVec3
u32 Rem self -> LuaUVec3 -> LuaUVec3
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaUVec3),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=u32))
			    
impl			{
			}
		}
		{
			///A 4-dimensional vector.
glam::u32::uvec4::UVec4 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new vector.
				// new(u32u32u32u32) -> LuaUVec4

				// Exclusion reason: 
				// ///Creates a vector with all elements set to `v`.
				// splat(u32) -> LuaUVec4

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaUVec4LuaUVec4) -> LuaUVec4

				///Creates a new vector from an array.
				from_array(<invalid: [u32;4]>) -> LuaUVec4

				///`[x, y, z, w]`
				to_array(&self)<invalid: [u32;4]>

				///Creates a vector from the first 4 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 4 elements long.
				from_slice(<invalid: &[u32]>) -> LuaUVec4

				///Writes the elements of `self` to the first 4 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 4 elements long.
				write_to_slice(self<invalid: &mut [u32]>)

				// Exclusion reason: 
				// ///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
				// ///
				// ///Truncation to `UVec3` may also be performed by using `self.xyz()` or `UVec3::from()`.
				// truncate(self) -> LuaUVec3

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`.
				// dot(selfLuaUVec4) -> u32

				// Exclusion reason: 
				// ///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				// min(selfLuaUVec4) -> LuaUVec4

				// Exclusion reason: 
				// ///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				// ///
				// ///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				// max(selfLuaUVec4) -> LuaUVec4

				// Exclusion reason: 
				// ///Component-wise clamping of values, similar to [`f32::clamp`].
				// ///
				// ///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				// clamp(selfLuaUVec4LuaUVec4) -> LuaUVec4

				// Exclusion reason: 
				// ///Returns the horizontal minimum of `self`.
				// ///
				// ///In other words this computes `min(x, y, ..)`.
				// min_element(self) -> u32

				// Exclusion reason: 
				// ///Returns the horizontal maximum of `self`.
				// ///
				// ///In other words this computes `max(x, y, ..)`.
				// max_element(self) -> u32

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(selfLuaUVec4)

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(selfLuaUVec4)

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(selfLuaUVec4)

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(selfLuaUVec4)

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(selfLuaUVec4)

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(selfLuaUVec4)

				///Casts all elements of `self` to `f32`.
				as_vec4(&self)

				///Casts all elements of `self` to `f64`.
				as_dvec4(&self)

				///Casts all elements of `self` to `i32`.
				as_ivec4(&self)

				try_from()

				///Returns the argument unchanged.
				from()

				from(<invalid: [u32;4]>) -> LuaUVec4

				// Exclusion reason: 
				// from(LuaUVec4) -> LuaUVec4

				from(<invalid: (u32,u32,u32,u32)>) -> LuaUVec4

				// Exclusion reason: 
				// from(LuaUVec4) -> LuaUVec4

				from(<invalid: (LuaUVec3,u32)>) -> LuaUVec4

				from(<invalid: (u32,LuaUVec3)>) -> LuaUVec4

				from(<invalid: (LuaUVec2,u32,u32)>) -> LuaUVec4

				from(<invalid: (LuaUVec2,LuaUVec2)>) -> LuaUVec4

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				shl(self)

				shl(selfi8)

				shl(selfi16)

				shl(selfi32)

				shl(selfu8)

				shl(selfu16)

				shl(selfu32)

				shl(self)

				shl(self)

				shr(self)

				shr(selfi8)

				shr(selfi16)

				shr(selfi32)

				shr(selfu8)

				shr(selfu16)

				shr(selfu32)

				shr(self)

				shr(self)

				// Exclusion reason: 
				// clone(&self) -> LuaUVec4

				// Exclusion reason: 
				// default() -> LuaUVec4

				// Exclusion reason: 
				// eq(&self&LuaUVec4) -> bool

				// Exclusion reason: 
				// div(selfLuaUVec4) -> LuaUVec4

				// Exclusion reason: 
				// div(selfu32) -> LuaUVec4

				// Exclusion reason: 
				// div(selfLuaUVec4) -> LuaUVec4

				div_assign(<invalid: &mut self>LuaUVec4)

				div_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// mul(selfLuaUVec4) -> LuaUVec4

				// Exclusion reason: 
				// mul(selfu32) -> LuaUVec4

				// Exclusion reason: 
				// mul(selfLuaUVec4) -> LuaUVec4

				mul_assign(<invalid: &mut self>LuaUVec4)

				mul_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// add(selfLuaUVec4) -> LuaUVec4

				// Exclusion reason: 
				// add(selfu32) -> LuaUVec4

				// Exclusion reason: 
				// add(selfLuaUVec4) -> LuaUVec4

				add_assign(<invalid: &mut self>LuaUVec4)

				add_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// sub(selfLuaUVec4) -> LuaUVec4

				// Exclusion reason: 
				// sub(selfu32) -> LuaUVec4

				// Exclusion reason: 
				// sub(selfLuaUVec4) -> LuaUVec4

				sub_assign(<invalid: &mut self>LuaUVec4)

				sub_assign(<invalid: &mut self>u32)

				// Exclusion reason: 
				// rem(selfLuaUVec4) -> LuaUVec4

				// Exclusion reason: 
				// rem(selfu32) -> LuaUVec4

				// Exclusion reason: 
				// rem(selfLuaUVec4) -> LuaUVec4

				rem_assign(<invalid: &mut self>LuaUVec4)

				rem_assign(<invalid: &mut self>u32)

				as_ref(&self)<invalid: &[u32;4]>

				as_mut(<invalid: &mut self>)<invalid: &mut [u32;4]>

				sum() -> LuaUVec4

				product() -> LuaUVec4

				hash(&self)

				not(self)

				bitand(selfLuaUVec4)

				bitand(selfu32)

				bitor(selfLuaUVec4)

				bitor(selfu32)

				bitxor(selfLuaUVec4)

				bitxor(selfu32)

				index(&selfusize)

				index_mut(<invalid: &mut self>usize)

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// xx(self) -> LuaUVec2

				// Exclusion reason: 
				// xy(self) -> LuaUVec2

				// Exclusion reason: 
				// xz(self) -> LuaUVec2

				// Exclusion reason: 
				// xw(self) -> LuaUVec2

				// Exclusion reason: 
				// yx(self) -> LuaUVec2

				// Exclusion reason: 
				// yy(self) -> LuaUVec2

				// Exclusion reason: 
				// yz(self) -> LuaUVec2

				// Exclusion reason: 
				// yw(self) -> LuaUVec2

				// Exclusion reason: 
				// zx(self) -> LuaUVec2

				// Exclusion reason: 
				// zy(self) -> LuaUVec2

				// Exclusion reason: 
				// zz(self) -> LuaUVec2

				// Exclusion reason: 
				// zw(self) -> LuaUVec2

				// Exclusion reason: 
				// wx(self) -> LuaUVec2

				// Exclusion reason: 
				// wy(self) -> LuaUVec2

				// Exclusion reason: 
				// wz(self) -> LuaUVec2

				// Exclusion reason: 
				// ww(self) -> LuaUVec2

				// Exclusion reason: 
				// xxx(self) -> LuaUVec3

				// Exclusion reason: 
				// xxy(self) -> LuaUVec3

				// Exclusion reason: 
				// xxz(self) -> LuaUVec3

				// Exclusion reason: 
				// xxw(self) -> LuaUVec3

				// Exclusion reason: 
				// xyx(self) -> LuaUVec3

				// Exclusion reason: 
				// xyy(self) -> LuaUVec3

				// Exclusion reason: 
				// xyz(self) -> LuaUVec3

				// Exclusion reason: 
				// xyw(self) -> LuaUVec3

				// Exclusion reason: 
				// xzx(self) -> LuaUVec3

				// Exclusion reason: 
				// xzy(self) -> LuaUVec3

				// Exclusion reason: 
				// xzz(self) -> LuaUVec3

				// Exclusion reason: 
				// xzw(self) -> LuaUVec3

				// Exclusion reason: 
				// xwx(self) -> LuaUVec3

				// Exclusion reason: 
				// xwy(self) -> LuaUVec3

				// Exclusion reason: 
				// xwz(self) -> LuaUVec3

				// Exclusion reason: 
				// xww(self) -> LuaUVec3

				// Exclusion reason: 
				// yxx(self) -> LuaUVec3

				// Exclusion reason: 
				// yxy(self) -> LuaUVec3

				// Exclusion reason: 
				// yxz(self) -> LuaUVec3

				// Exclusion reason: 
				// yxw(self) -> LuaUVec3

				// Exclusion reason: 
				// yyx(self) -> LuaUVec3

				// Exclusion reason: 
				// yyy(self) -> LuaUVec3

				// Exclusion reason: 
				// yyz(self) -> LuaUVec3

				// Exclusion reason: 
				// yyw(self) -> LuaUVec3

				// Exclusion reason: 
				// yzx(self) -> LuaUVec3

				// Exclusion reason: 
				// yzy(self) -> LuaUVec3

				// Exclusion reason: 
				// yzz(self) -> LuaUVec3

				// Exclusion reason: 
				// yzw(self) -> LuaUVec3

				// Exclusion reason: 
				// ywx(self) -> LuaUVec3

				// Exclusion reason: 
				// ywy(self) -> LuaUVec3

				// Exclusion reason: 
				// ywz(self) -> LuaUVec3

				// Exclusion reason: 
				// yww(self) -> LuaUVec3

				// Exclusion reason: 
				// zxx(self) -> LuaUVec3

				// Exclusion reason: 
				// zxy(self) -> LuaUVec3

				// Exclusion reason: 
				// zxz(self) -> LuaUVec3

				// Exclusion reason: 
				// zxw(self) -> LuaUVec3

				// Exclusion reason: 
				// zyx(self) -> LuaUVec3

				// Exclusion reason: 
				// zyy(self) -> LuaUVec3

				// Exclusion reason: 
				// zyz(self) -> LuaUVec3

				// Exclusion reason: 
				// zyw(self) -> LuaUVec3

				// Exclusion reason: 
				// zzx(self) -> LuaUVec3

				// Exclusion reason: 
				// zzy(self) -> LuaUVec3

				// Exclusion reason: 
				// zzz(self) -> LuaUVec3

				// Exclusion reason: 
				// zzw(self) -> LuaUVec3

				// Exclusion reason: 
				// zwx(self) -> LuaUVec3

				// Exclusion reason: 
				// zwy(self) -> LuaUVec3

				// Exclusion reason: 
				// zwz(self) -> LuaUVec3

				// Exclusion reason: 
				// zww(self) -> LuaUVec3

				// Exclusion reason: 
				// wxx(self) -> LuaUVec3

				// Exclusion reason: 
				// wxy(self) -> LuaUVec3

				// Exclusion reason: 
				// wxz(self) -> LuaUVec3

				// Exclusion reason: 
				// wxw(self) -> LuaUVec3

				// Exclusion reason: 
				// wyx(self) -> LuaUVec3

				// Exclusion reason: 
				// wyy(self) -> LuaUVec3

				// Exclusion reason: 
				// wyz(self) -> LuaUVec3

				// Exclusion reason: 
				// wyw(self) -> LuaUVec3

				// Exclusion reason: 
				// wzx(self) -> LuaUVec3

				// Exclusion reason: 
				// wzy(self) -> LuaUVec3

				// Exclusion reason: 
				// wzz(self) -> LuaUVec3

				// Exclusion reason: 
				// wzw(self) -> LuaUVec3

				// Exclusion reason: 
				// wwx(self) -> LuaUVec3

				// Exclusion reason: 
				// wwy(self) -> LuaUVec3

				// Exclusion reason: 
				// wwz(self) -> LuaUVec3

				// Exclusion reason: 
				// www(self) -> LuaUVec3

				// Exclusion reason: 
				// xxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xxxz(self) -> LuaUVec4

				// Exclusion reason: 
				// xxxw(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyz(self) -> LuaUVec4

				// Exclusion reason: 
				// xxyw(self) -> LuaUVec4

				// Exclusion reason: 
				// xxzx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxzy(self) -> LuaUVec4

				// Exclusion reason: 
				// xxzz(self) -> LuaUVec4

				// Exclusion reason: 
				// xxzw(self) -> LuaUVec4

				// Exclusion reason: 
				// xxwx(self) -> LuaUVec4

				// Exclusion reason: 
				// xxwy(self) -> LuaUVec4

				// Exclusion reason: 
				// xxwz(self) -> LuaUVec4

				// Exclusion reason: 
				// xxww(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxz(self) -> LuaUVec4

				// Exclusion reason: 
				// xyxw(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyy(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyz(self) -> LuaUVec4

				// Exclusion reason: 
				// xyyw(self) -> LuaUVec4

				// Exclusion reason: 
				// xyzx(self) -> LuaUVec4

				// Exclusion reason: 
				// xyzy(self) -> LuaUVec4

				// Exclusion reason: 
				// xyzz(self) -> LuaUVec4

				// Exclusion reason: 
				// xyzw(self) -> LuaUVec4

				// Exclusion reason: 
				// xywx(self) -> LuaUVec4

				// Exclusion reason: 
				// xywy(self) -> LuaUVec4

				// Exclusion reason: 
				// xywz(self) -> LuaUVec4

				// Exclusion reason: 
				// xyww(self) -> LuaUVec4

				// Exclusion reason: 
				// xzxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xzxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xzxz(self) -> LuaUVec4

				// Exclusion reason: 
				// xzxw(self) -> LuaUVec4

				// Exclusion reason: 
				// xzyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xzyy(self) -> LuaUVec4

				// Exclusion reason: 
				// xzyz(self) -> LuaUVec4

				// Exclusion reason: 
				// xzyw(self) -> LuaUVec4

				// Exclusion reason: 
				// xzzx(self) -> LuaUVec4

				// Exclusion reason: 
				// xzzy(self) -> LuaUVec4

				// Exclusion reason: 
				// xzzz(self) -> LuaUVec4

				// Exclusion reason: 
				// xzzw(self) -> LuaUVec4

				// Exclusion reason: 
				// xzwx(self) -> LuaUVec4

				// Exclusion reason: 
				// xzwy(self) -> LuaUVec4

				// Exclusion reason: 
				// xzwz(self) -> LuaUVec4

				// Exclusion reason: 
				// xzww(self) -> LuaUVec4

				// Exclusion reason: 
				// xwxx(self) -> LuaUVec4

				// Exclusion reason: 
				// xwxy(self) -> LuaUVec4

				// Exclusion reason: 
				// xwxz(self) -> LuaUVec4

				// Exclusion reason: 
				// xwxw(self) -> LuaUVec4

				// Exclusion reason: 
				// xwyx(self) -> LuaUVec4

				// Exclusion reason: 
				// xwyy(self) -> LuaUVec4

				// Exclusion reason: 
				// xwyz(self) -> LuaUVec4

				// Exclusion reason: 
				// xwyw(self) -> LuaUVec4

				// Exclusion reason: 
				// xwzx(self) -> LuaUVec4

				// Exclusion reason: 
				// xwzy(self) -> LuaUVec4

				// Exclusion reason: 
				// xwzz(self) -> LuaUVec4

				// Exclusion reason: 
				// xwzw(self) -> LuaUVec4

				// Exclusion reason: 
				// xwwx(self) -> LuaUVec4

				// Exclusion reason: 
				// xwwy(self) -> LuaUVec4

				// Exclusion reason: 
				// xwwz(self) -> LuaUVec4

				// Exclusion reason: 
				// xwww(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxz(self) -> LuaUVec4

				// Exclusion reason: 
				// yxxw(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyz(self) -> LuaUVec4

				// Exclusion reason: 
				// yxyw(self) -> LuaUVec4

				// Exclusion reason: 
				// yxzx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxzy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxzz(self) -> LuaUVec4

				// Exclusion reason: 
				// yxzw(self) -> LuaUVec4

				// Exclusion reason: 
				// yxwx(self) -> LuaUVec4

				// Exclusion reason: 
				// yxwy(self) -> LuaUVec4

				// Exclusion reason: 
				// yxwz(self) -> LuaUVec4

				// Exclusion reason: 
				// yxww(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxz(self) -> LuaUVec4

				// Exclusion reason: 
				// yyxw(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyy(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyz(self) -> LuaUVec4

				// Exclusion reason: 
				// yyyw(self) -> LuaUVec4

				// Exclusion reason: 
				// yyzx(self) -> LuaUVec4

				// Exclusion reason: 
				// yyzy(self) -> LuaUVec4

				// Exclusion reason: 
				// yyzz(self) -> LuaUVec4

				// Exclusion reason: 
				// yyzw(self) -> LuaUVec4

				// Exclusion reason: 
				// yywx(self) -> LuaUVec4

				// Exclusion reason: 
				// yywy(self) -> LuaUVec4

				// Exclusion reason: 
				// yywz(self) -> LuaUVec4

				// Exclusion reason: 
				// yyww(self) -> LuaUVec4

				// Exclusion reason: 
				// yzxx(self) -> LuaUVec4

				// Exclusion reason: 
				// yzxy(self) -> LuaUVec4

				// Exclusion reason: 
				// yzxz(self) -> LuaUVec4

				// Exclusion reason: 
				// yzxw(self) -> LuaUVec4

				// Exclusion reason: 
				// yzyx(self) -> LuaUVec4

				// Exclusion reason: 
				// yzyy(self) -> LuaUVec4

				// Exclusion reason: 
				// yzyz(self) -> LuaUVec4

				// Exclusion reason: 
				// yzyw(self) -> LuaUVec4

				// Exclusion reason: 
				// yzzx(self) -> LuaUVec4

				// Exclusion reason: 
				// yzzy(self) -> LuaUVec4

				// Exclusion reason: 
				// yzzz(self) -> LuaUVec4

				// Exclusion reason: 
				// yzzw(self) -> LuaUVec4

				// Exclusion reason: 
				// yzwx(self) -> LuaUVec4

				// Exclusion reason: 
				// yzwy(self) -> LuaUVec4

				// Exclusion reason: 
				// yzwz(self) -> LuaUVec4

				// Exclusion reason: 
				// yzww(self) -> LuaUVec4

				// Exclusion reason: 
				// ywxx(self) -> LuaUVec4

				// Exclusion reason: 
				// ywxy(self) -> LuaUVec4

				// Exclusion reason: 
				// ywxz(self) -> LuaUVec4

				// Exclusion reason: 
				// ywxw(self) -> LuaUVec4

				// Exclusion reason: 
				// ywyx(self) -> LuaUVec4

				// Exclusion reason: 
				// ywyy(self) -> LuaUVec4

				// Exclusion reason: 
				// ywyz(self) -> LuaUVec4

				// Exclusion reason: 
				// ywyw(self) -> LuaUVec4

				// Exclusion reason: 
				// ywzx(self) -> LuaUVec4

				// Exclusion reason: 
				// ywzy(self) -> LuaUVec4

				// Exclusion reason: 
				// ywzz(self) -> LuaUVec4

				// Exclusion reason: 
				// ywzw(self) -> LuaUVec4

				// Exclusion reason: 
				// ywwx(self) -> LuaUVec4

				// Exclusion reason: 
				// ywwy(self) -> LuaUVec4

				// Exclusion reason: 
				// ywwz(self) -> LuaUVec4

				// Exclusion reason: 
				// ywww(self) -> LuaUVec4

				// Exclusion reason: 
				// zxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// zxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// zxxz(self) -> LuaUVec4

				// Exclusion reason: 
				// zxxw(self) -> LuaUVec4

				// Exclusion reason: 
				// zxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// zxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// zxyz(self) -> LuaUVec4

				// Exclusion reason: 
				// zxyw(self) -> LuaUVec4

				// Exclusion reason: 
				// zxzx(self) -> LuaUVec4

				// Exclusion reason: 
				// zxzy(self) -> LuaUVec4

				// Exclusion reason: 
				// zxzz(self) -> LuaUVec4

				// Exclusion reason: 
				// zxzw(self) -> LuaUVec4

				// Exclusion reason: 
				// zxwx(self) -> LuaUVec4

				// Exclusion reason: 
				// zxwy(self) -> LuaUVec4

				// Exclusion reason: 
				// zxwz(self) -> LuaUVec4

				// Exclusion reason: 
				// zxww(self) -> LuaUVec4

				// Exclusion reason: 
				// zyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// zyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// zyxz(self) -> LuaUVec4

				// Exclusion reason: 
				// zyxw(self) -> LuaUVec4

				// Exclusion reason: 
				// zyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// zyyy(self) -> LuaUVec4

				// Exclusion reason: 
				// zyyz(self) -> LuaUVec4

				// Exclusion reason: 
				// zyyw(self) -> LuaUVec4

				// Exclusion reason: 
				// zyzx(self) -> LuaUVec4

				// Exclusion reason: 
				// zyzy(self) -> LuaUVec4

				// Exclusion reason: 
				// zyzz(self) -> LuaUVec4

				// Exclusion reason: 
				// zyzw(self) -> LuaUVec4

				// Exclusion reason: 
				// zywx(self) -> LuaUVec4

				// Exclusion reason: 
				// zywy(self) -> LuaUVec4

				// Exclusion reason: 
				// zywz(self) -> LuaUVec4

				// Exclusion reason: 
				// zyww(self) -> LuaUVec4

				// Exclusion reason: 
				// zzxx(self) -> LuaUVec4

				// Exclusion reason: 
				// zzxy(self) -> LuaUVec4

				// Exclusion reason: 
				// zzxz(self) -> LuaUVec4

				// Exclusion reason: 
				// zzxw(self) -> LuaUVec4

				// Exclusion reason: 
				// zzyx(self) -> LuaUVec4

				// Exclusion reason: 
				// zzyy(self) -> LuaUVec4

				// Exclusion reason: 
				// zzyz(self) -> LuaUVec4

				// Exclusion reason: 
				// zzyw(self) -> LuaUVec4

				// Exclusion reason: 
				// zzzx(self) -> LuaUVec4

				// Exclusion reason: 
				// zzzy(self) -> LuaUVec4

				// Exclusion reason: 
				// zzzz(self) -> LuaUVec4

				// Exclusion reason: 
				// zzzw(self) -> LuaUVec4

				// Exclusion reason: 
				// zzwx(self) -> LuaUVec4

				// Exclusion reason: 
				// zzwy(self) -> LuaUVec4

				// Exclusion reason: 
				// zzwz(self) -> LuaUVec4

				// Exclusion reason: 
				// zzww(self) -> LuaUVec4

				// Exclusion reason: 
				// zwxx(self) -> LuaUVec4

				// Exclusion reason: 
				// zwxy(self) -> LuaUVec4

				// Exclusion reason: 
				// zwxz(self) -> LuaUVec4

				// Exclusion reason: 
				// zwxw(self) -> LuaUVec4

				// Exclusion reason: 
				// zwyx(self) -> LuaUVec4

				// Exclusion reason: 
				// zwyy(self) -> LuaUVec4

				// Exclusion reason: 
				// zwyz(self) -> LuaUVec4

				// Exclusion reason: 
				// zwyw(self) -> LuaUVec4

				// Exclusion reason: 
				// zwzx(self) -> LuaUVec4

				// Exclusion reason: 
				// zwzy(self) -> LuaUVec4

				// Exclusion reason: 
				// zwzz(self) -> LuaUVec4

				// Exclusion reason: 
				// zwzw(self) -> LuaUVec4

				// Exclusion reason: 
				// zwwx(self) -> LuaUVec4

				// Exclusion reason: 
				// zwwy(self) -> LuaUVec4

				// Exclusion reason: 
				// zwwz(self) -> LuaUVec4

				// Exclusion reason: 
				// zwww(self) -> LuaUVec4

				// Exclusion reason: 
				// wxxx(self) -> LuaUVec4

				// Exclusion reason: 
				// wxxy(self) -> LuaUVec4

				// Exclusion reason: 
				// wxxz(self) -> LuaUVec4

				// Exclusion reason: 
				// wxxw(self) -> LuaUVec4

				// Exclusion reason: 
				// wxyx(self) -> LuaUVec4

				// Exclusion reason: 
				// wxyy(self) -> LuaUVec4

				// Exclusion reason: 
				// wxyz(self) -> LuaUVec4

				// Exclusion reason: 
				// wxyw(self) -> LuaUVec4

				// Exclusion reason: 
				// wxzx(self) -> LuaUVec4

				// Exclusion reason: 
				// wxzy(self) -> LuaUVec4

				// Exclusion reason: 
				// wxzz(self) -> LuaUVec4

				// Exclusion reason: 
				// wxzw(self) -> LuaUVec4

				// Exclusion reason: 
				// wxwx(self) -> LuaUVec4

				// Exclusion reason: 
				// wxwy(self) -> LuaUVec4

				// Exclusion reason: 
				// wxwz(self) -> LuaUVec4

				// Exclusion reason: 
				// wxww(self) -> LuaUVec4

				// Exclusion reason: 
				// wyxx(self) -> LuaUVec4

				// Exclusion reason: 
				// wyxy(self) -> LuaUVec4

				// Exclusion reason: 
				// wyxz(self) -> LuaUVec4

				// Exclusion reason: 
				// wyxw(self) -> LuaUVec4

				// Exclusion reason: 
				// wyyx(self) -> LuaUVec4

				// Exclusion reason: 
				// wyyy(self) -> LuaUVec4

				// Exclusion reason: 
				// wyyz(self) -> LuaUVec4

				// Exclusion reason: 
				// wyyw(self) -> LuaUVec4

				// Exclusion reason: 
				// wyzx(self) -> LuaUVec4

				// Exclusion reason: 
				// wyzy(self) -> LuaUVec4

				// Exclusion reason: 
				// wyzz(self) -> LuaUVec4

				// Exclusion reason: 
				// wyzw(self) -> LuaUVec4

				// Exclusion reason: 
				// wywx(self) -> LuaUVec4

				// Exclusion reason: 
				// wywy(self) -> LuaUVec4

				// Exclusion reason: 
				// wywz(self) -> LuaUVec4

				// Exclusion reason: 
				// wyww(self) -> LuaUVec4

				// Exclusion reason: 
				// wzxx(self) -> LuaUVec4

				// Exclusion reason: 
				// wzxy(self) -> LuaUVec4

				// Exclusion reason: 
				// wzxz(self) -> LuaUVec4

				// Exclusion reason: 
				// wzxw(self) -> LuaUVec4

				// Exclusion reason: 
				// wzyx(self) -> LuaUVec4

				// Exclusion reason: 
				// wzyy(self) -> LuaUVec4

				// Exclusion reason: 
				// wzyz(self) -> LuaUVec4

				// Exclusion reason: 
				// wzyw(self) -> LuaUVec4

				// Exclusion reason: 
				// wzzx(self) -> LuaUVec4

				// Exclusion reason: 
				// wzzy(self) -> LuaUVec4

				// Exclusion reason: 
				// wzzz(self) -> LuaUVec4

				// Exclusion reason: 
				// wzzw(self) -> LuaUVec4

				// Exclusion reason: 
				// wzwx(self) -> LuaUVec4

				// Exclusion reason: 
				// wzwy(self) -> LuaUVec4

				// Exclusion reason: 
				// wzwz(self) -> LuaUVec4

				// Exclusion reason: 
				// wzww(self) -> LuaUVec4

				// Exclusion reason: 
				// wwxx(self) -> LuaUVec4

				// Exclusion reason: 
				// wwxy(self) -> LuaUVec4

				// Exclusion reason: 
				// wwxz(self) -> LuaUVec4

				// Exclusion reason: 
				// wwxw(self) -> LuaUVec4

				// Exclusion reason: 
				// wwyx(self) -> LuaUVec4

				// Exclusion reason: 
				// wwyy(self) -> LuaUVec4

				// Exclusion reason: 
				// wwyz(self) -> LuaUVec4

				// Exclusion reason: 
				// wwyw(self) -> LuaUVec4

				// Exclusion reason: 
				// wwzx(self) -> LuaUVec4

				// Exclusion reason: 
				// wwzy(self) -> LuaUVec4

				// Exclusion reason: 
				// wwzz(self) -> LuaUVec4

				// Exclusion reason: 
				// wwzw(self) -> LuaUVec4

				// Exclusion reason: 
				// wwwx(self) -> LuaUVec4

				// Exclusion reason: 
				// wwwy(self) -> LuaUVec4

				// Exclusion reason: 
				// wwwz(self) -> LuaUVec4

				// Exclusion reason: 
				// wwww(self) -> LuaUVec4

			)
+ BinaryOps			(
self Add LuaUVec4 -> LuaUVec4 -> LuaUVec4
self Add u32 -> LuaUVec4 -> LuaUVec4
u32 Add self -> LuaUVec4 -> LuaUVec4
self Sub LuaUVec4 -> LuaUVec4 -> LuaUVec4
self Sub u32 -> LuaUVec4 -> LuaUVec4
u32 Sub self -> LuaUVec4 -> LuaUVec4
self Div LuaUVec4 -> LuaUVec4 -> LuaUVec4
self Div u32 -> LuaUVec4 -> LuaUVec4
u32 Div self -> LuaUVec4 -> LuaUVec4
self Mul LuaUVec4 -> LuaUVec4 -> LuaUVec4
self Mul u32 -> LuaUVec4 -> LuaUVec4
u32 Mul self -> LuaUVec4 -> LuaUVec4
self Rem LuaUVec4 -> LuaUVec4 -> LuaUVec4
self Rem u32 -> LuaUVec4 -> LuaUVec4
u32 Rem self -> LuaUVec4 -> LuaUVec4
			)
+ UnaryOps			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaUVec4),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=u32))
			    
impl			{
			}
		}
		{
			///A 3x3 column major matrix.
			///
			///This 3x3 matrix type features convenience methods for creating and using linear and
			///affine transformations. If you are primarily dealing with 2D affine transformations the
			///[`Affine2`](crate::Affine2) type is much faster and more space efficient than
			///using a 3x3 matrix.
			///
			///Linear transformations including 3D rotation and scale can be created using methods
			///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
			///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
			///[`Self::from_rotation_z()`].
			///
			///The resulting matrices can be use to transform 3D vectors using regular vector
			///multiplication.
			///
			///Affine transformations including 2D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
			///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
			///
			///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
			///are provided for performing affine transforms on 2D vectors and points. These multiply
			///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
			///vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
glam::f32::mat3::Mat3 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a 3x3 matrix from two column vectors.
				// from_cols(LuaVec3LuaVec3LuaVec3) -> LuaMat3

				///Creates a 3x3 matrix from a `[f32; 9]` array stored in column major order.
				///If your data is stored in row major you will need to `transpose` the returned
				///matrix.
				from_cols_array(<invalid: &[f32;9]>) -> LuaMat3

				///Creates a `[f32; 9]` array storing data in column major order.
				///If you require data in row major order `transpose` the matrix first.
				to_cols_array(&self)<invalid: [f32;9]>

				///Creates a 3x3 matrix from a `[[f32; 3]; 3]` 3D array stored in column major order.
				///If your data is in row major order you will need to `transpose` the returned
				///matrix.
				from_cols_array_2d(<invalid: &[[f32;3];3]>) -> LuaMat3

				///Creates a `[[f32; 3]; 3]` 3D array storing data in column major order.
				///If you require data in row major order `transpose` the matrix first.
				to_cols_array_2d(&self)<invalid: [[f32;3];3]>

				// Exclusion reason: 
				// ///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				// from_diagonal(LuaVec3) -> LuaMat3

				// Exclusion reason: 
				// ///Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.
				// from_mat4(LuaMat4) -> LuaMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from the given quaternion.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				// from_quat(LuaQuat) -> LuaMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
				// ///radians).
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				// from_axis_angle(LuaVec3f32) -> LuaMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
				// ///radians).
				// from_euler(LuaEulerRotf32f32f32) -> LuaMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
				// from_rotation_x(f32) -> LuaMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
				// from_rotation_y(f32) -> LuaMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
				// from_rotation_z(f32) -> LuaMat3

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 2D `translation`.
				// ///
				// ///The resulting matrix can be used to transform 2D points and vectors. See
				// ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				// from_translation(LuaVec2) -> LuaMat3

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 2D rotation `angle` (in
				// ///radians).
				// ///
				// ///The resulting matrix can be used to transform 2D points and vectors. See
				// ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				// from_angle(f32) -> LuaMat3

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
				// ///radians) and `translation`.
				// ///
				// ///The resulting matrix can be used to transform 2D points and vectors. See
				// ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				// from_scale_angle_translation(LuaVec2f32LuaVec2) -> LuaMat3

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
				// ///
				// ///The resulting matrix can be used to transform 2D points and vectors. See
				// ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				// from_scale(LuaVec2) -> LuaMat3

				///Creates an affine transformation matrix from the given 2x2 matrix.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_mat2() -> LuaMat3

				///Creates a 3x3 matrix from the first 9 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 9 elements long.
				from_cols_slice(<invalid: &[f32]>) -> LuaMat3

				///Writes the columns of `self` to the first 9 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 9 elements long.
				write_cols_to_slice(self<invalid: &mut [f32]>)

				// Exclusion reason: 
				// ///Returns the matrix column for the given `index`.
				// ///
				// ///# Panics
				// ///
				// ///Panics if `index` is greater than 2.
				// col(&selfusize) -> LuaVec3

				///Returns a mutable reference to the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 2.
				col_mut(<invalid: &mut self>usize)<invalid: &mut LuaVec3>

				// Exclusion reason: 
				// ///Returns the matrix row for the given `index`.
				// ///
				// ///# Panics
				// ///
				// ///Panics if `index` is greater than 2.
				// row(&selfusize) -> LuaVec3

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.
				// ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				// is_finite(&self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(&self) -> bool

				// Exclusion reason: 
				// ///Returns the transpose of `self`.
				// transpose(&self) -> LuaMat3

				// Exclusion reason: 
				// ///Returns the determinant of `self`.
				// determinant(&self) -> f32

				// Exclusion reason: 
				// ///Returns the inverse of `self`.
				// ///
				// ///If the matrix is not invertible the returned matrix will be invalid.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				// inverse(&self) -> LuaMat3

				// Exclusion reason: 
				// ///Transforms the given 2D vector as a point.
				// ///
				// ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
				// ///
				// ///This method assumes that `self` contains a valid affine transform.
				// transform_point2(&selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Rotates the given 2D vector.
				// ///
				// ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
				// ///
				// ///This method assumes that `self` contains a valid affine transform.
				// transform_vector2(&selfLuaVec2) -> LuaVec2

				// Exclusion reason: 
				// ///Transforms a 3D vector.
				// mul_vec3(&selfLuaVec3) -> LuaVec3

				///Transforms a `Vec3A`.
				mul_vec3a(&self)

				// Exclusion reason: 
				// ///Multiplies two 3x3 matrices.
				// mul_mat3(&self&LuaMat3) -> LuaMat3

				// Exclusion reason: 
				// ///Adds two 3x3 matrices.
				// add_mat3(&self&LuaMat3) -> LuaMat3

				// Exclusion reason: 
				// ///Subtracts two 3x3 matrices.
				// sub_mat3(&self&LuaMat3) -> LuaMat3

				// Exclusion reason: 
				// ///Multiplies a 3x3 matrix by a scalar.
				// mul_scalar(&selff32) -> LuaMat3

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs`
				// ///is less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two matrices contain similar elements. It works best
				// ///when comparing with a known value. The `max_abs_diff` that should be used used
				// ///depends on the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(&selfLuaMat3f32) -> bool

				// Exclusion reason: 
				// as_dmat3(&self) -> LuaDMat3

				try_from()

				///Returns the argument unchanged.
				from()

				from() -> LuaMat3

				from() -> LuaMat3

				// Exclusion reason: 
				// from(LuaMat3) -> LuaMat3

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaMat3)

				mul(self)

				mul(selfLuaMat3)

				mul(selfLuaVec3)

				mul(selfLuaMat3)

				mul(selff32)

				mul(self)

				// Exclusion reason: 
				// clone(&self) -> LuaMat3

				// Exclusion reason: 
				// default() -> LuaMat3

				add(selfLuaMat3)

				add_assign(<invalid: &mut self>LuaMat3)

				sub(selfLuaMat3)

				sub_assign(<invalid: &mut self>LuaMat3)

				neg(self)

				mul_assign(<invalid: &mut self>LuaMat3)

				mul_assign(<invalid: &mut self>f32)

				sum() -> LuaMat3

				product() -> LuaMat3

				// Exclusion reason: 
				// eq(&self&LuaMat3) -> bool

				as_ref(&self)<invalid: &[f32;9]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f32;9]>

				fmt(&self)

				fmt(&self)

			)
+ BinaryOps			(
self Add LuaMat3 -> LuaMat3 -> LuaMat3
self Sub LuaMat3 -> LuaMat3 -> LuaMat3
self Mul LuaMat3 -> LuaMat3 -> LuaMat3
self Mul LuaVec3 -> LuaVec3 -> LuaVec3
f32 Mul self -> LuaMat3 -> LuaMat3
self Mul f32 -> LuaMat3 -> LuaMat3
			)
+ UnaryOps			(
			)
impl			{
				    
mut (MetaMethod::Index) (s=LuaMat3,b=Mat3,v=LuaVec3) => {|_,s,idx : usize| {
    match s {
        ($s)::Owned(ref mut v, ref valid) => {
            Ok(($v)::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.col_mut(idx-1)),
                path: None
            }))
        },
        ($s)::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(($v)::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<($b)>().unwrap().col_mut(idx-1)),
                    path: None
                })) 
            })
        }
    }
}}
;
			}
		}
		{
			///A 4x4 column major matrix.
			///
			///This 4x4 matrix type features convenience methods for creating and using affine transforms and
			///perspective projections. If you are primarily dealing with 3D affine transformations
			///considering using [`Affine3A`](crate::Affine3A) which is faster than a 4x4 matrix
			///for some affine operations.
			///
			///Affine transformations including 3D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_quat()`],
			///[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].
			///
			///Othographic projections can be created using the methods [`Self::orthographic_lh()`] for
			///left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed
			///systems. The resulting matrix is also an affine transformation.
			///
			///The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods
			///are provided for performing affine transformations on 3D vectors and points. These
			///multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`
			///for vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
			///
			///Perspective projections can be created using methods such as
			///[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and
			///[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and
			///[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and
			///[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.
			///
			///The resulting perspective project can be use to transform 3D vectors as points with
			///perspective correction using the [`Self::project_point3()`] convenience method.
glam::f32::sse2::mat4::Mat4 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a 4x4 matrix from two column vectors.
				// from_cols(LuaVec4LuaVec4LuaVec4LuaVec4) -> LuaMat4

				///Creates a 4x4 matrix from a `[f32; 16]` array stored in column major order.
				///If your data is stored in row major you will need to `transpose` the returned
				///matrix.
				from_cols_array(<invalid: &[f32;16]>) -> LuaMat4

				///Creates a `[f32; 16]` array storing data in column major order.
				///If you require data in row major order `transpose` the matrix first.
				to_cols_array(&self)<invalid: [f32;16]>

				///Creates a 4x4 matrix from a `[[f32; 4]; 4]` 4D array stored in column major order.
				///If your data is in row major order you will need to `transpose` the returned
				///matrix.
				from_cols_array_2d(<invalid: &[[f32;4];4]>) -> LuaMat4

				///Creates a `[[f32; 4]; 4]` 4D array storing data in column major order.
				///If you require data in row major order `transpose` the matrix first.
				to_cols_array_2d(&self)<invalid: [[f32;4];4]>

				// Exclusion reason: 
				// ///Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				// from_diagonal(LuaVec4) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
				// ///`translation`.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				// from_scale_rotation_translation(LuaVec3LuaQuatLuaVec3) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 3D `translation`.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				// from_rotation_translation(LuaQuatLuaVec3) -> LuaMat4

				///Extracts `scale`, `rotation` and `translation` from `self`. The input matrix is
				///expected to be a 3D affine transformation matrix otherwise the output will be invalid.
				///
				///# Panics
				///
				///Will panic if the determinant of `self` is zero or if the resulting scale vector
				///contains any zero elements when `glam_assert` is enabled.
				to_scale_rotation_translation(&self)<invalid: (LuaVec3,LuaQuat,LuaVec3)>

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given `rotation` quaternion.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				// from_quat(LuaQuat) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 3x3 linear transformation
				// ///matrix.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_mat3(LuaMat3) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 3D `translation`.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_translation(LuaVec3) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing a 3D rotation around a normalized
				// ///rotation `axis` of `angle` (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				// from_axis_angle(LuaVec3f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a affine transformation matrix containing a rotation from the given euler
				// ///rotation sequence and angles (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_euler(LuaEulerRotf32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing a 3D rotation around the x axis of
				// ///`angle` (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_rotation_x(f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing a 3D rotation around the y axis of
				// ///`angle` (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_rotation_y(f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing a 3D rotation around the z axis of
				// ///`angle` (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_rotation_z(f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				// from_scale(LuaVec3) -> LuaMat4

				///Creates a 4x4 matrix from the first 16 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 16 elements long.
				from_cols_slice(<invalid: &[f32]>) -> LuaMat4

				///Writes the columns of `self` to the first 16 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 16 elements long.
				write_cols_to_slice(self<invalid: &mut [f32]>)

				// Exclusion reason: 
				// ///Returns the matrix column for the given `index`.
				// ///
				// ///# Panics
				// ///
				// ///Panics if `index` is greater than 3.
				// col(&selfusize) -> LuaVec4

				///Returns a mutable reference to the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 3.
				col_mut(<invalid: &mut self>usize)<invalid: &mut LuaVec4>

				// Exclusion reason: 
				// ///Returns the matrix row for the given `index`.
				// ///
				// ///# Panics
				// ///
				// ///Panics if `index` is greater than 3.
				// row(&selfusize) -> LuaVec4

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.
				// ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				// is_finite(&self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(&self) -> bool

				// Exclusion reason: 
				// ///Returns the transpose of `self`.
				// transpose(&self) -> LuaMat4

				// Exclusion reason: 
				// ///Returns the determinant of `self`.
				// determinant(&self) -> f32

				// Exclusion reason: 
				// ///Returns the inverse of `self`.
				// ///
				// ///If the matrix is not invertible the returned matrix will be invalid.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				// inverse(&self) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a left-handed view matrix using a camera position, an up direction, and a focal
				// ///point.
				// ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `up` is not normalized when `glam_assert` is enabled.
				// look_at_lh(LuaVec3LuaVec3LuaVec3) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a right-handed view matrix using a camera position, an up direction, and a focal
				// ///point.
				// ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `up` is not normalized when `glam_assert` is enabled.
				// look_at_rh(LuaVec3LuaVec3LuaVec3) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a right-handed perspective projection matrix with [-1,1] depth range.
				// ///This is the same as the OpenGL `gluPerspective` function.
				// ///See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
				// perspective_rh_gl(f32f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a left-handed perspective projection matrix with `[0,1]` depth range.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
				// ///enabled.
				// perspective_lh(f32f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a right-handed perspective projection matrix with `[0,1]` depth range.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
				// ///enabled.
				// perspective_rh(f32f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
				// perspective_infinite_lh(f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
				// perspective_infinite_reverse_lh(f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an infinite right-handed perspective projection matrix with
				// ///`[0,1]` depth range.
				// perspective_infinite_rh(f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates an infinite reverse right-handed perspective projection matrix
				// ///with `[0,1]` depth range.
				// perspective_infinite_reverse_rh(f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a right-handed orthographic projection matrix with `[-1,1]` depth
				// ///range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
				// ///See
				// ///<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
				// orthographic_rh_gl(f32f32f32f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
				// orthographic_lh(f32f32f32f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
				// orthographic_rh(f32f32f32f32f32f32) -> LuaMat4

				// Exclusion reason: 
				// ///Transforms the given 3D vector as a point, applying perspective correction.
				// ///
				// ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
				// ///The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
				// ///
				// ///This method assumes that `self` contains a projective transform.
				// project_point3(&selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Transforms the given 3D vector as a point.
				// ///
				// ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
				// ///`1.0`.
				// ///
				// ///This method assumes that `self` contains a valid affine transform. It does not perform
				// ///a persective divide, if `self` contains a perspective transform, or if you are unsure,
				// ///the [`Self::project_point3()`] method should be used instead.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
				// transform_point3(&selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Transforms the give 3D vector as a direction.
				// ///
				// ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
				// ///`0.0`.
				// ///
				// ///This method assumes that `self` contains a valid affine transform.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
				// transform_vector3(&selfLuaVec3) -> LuaVec3

				///Transforms the given `Vec3A` as 3D point.
				///
				///This is the equivalent of multiplying the `Vec3A` as a 4D vector where `w` is `1.0`.
				transform_point3a(&self)

				///Transforms the give `Vec3A` as 3D vector.
				///
				///This is the equivalent of multiplying the `Vec3A` as a 4D vector where `w` is `0.0`.
				transform_vector3a(&self)

				// Exclusion reason: 
				// ///Transforms a 4D vector.
				// mul_vec4(&selfLuaVec4) -> LuaVec4

				// Exclusion reason: 
				// ///Multiplies two 4x4 matrices.
				// mul_mat4(&self&LuaMat4) -> LuaMat4

				// Exclusion reason: 
				// ///Adds two 4x4 matrices.
				// add_mat4(&self&LuaMat4) -> LuaMat4

				// Exclusion reason: 
				// ///Subtracts two 4x4 matrices.
				// sub_mat4(&self&LuaMat4) -> LuaMat4

				// Exclusion reason: 
				// ///Multiplies a 4x4 matrix by a scalar.
				// mul_scalar(&selff32) -> LuaMat4

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs`
				// ///is less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two matrices contain similar elements. It works best
				// ///when comparing with a known value. The `max_abs_diff` that should be used used
				// ///depends on the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(&selfLuaMat4f32) -> bool

				// Exclusion reason: 
				// as_dmat4(&self) -> LuaDMat4

				try_from()

				///Returns the argument unchanged.
				from()

				from() -> LuaMat4

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaMat4)

				mul(self)

				mul(selfLuaMat4)

				mul(selfLuaVec4)

				mul(selfLuaMat4)

				mul(selff32)

				// Exclusion reason: 
				// clone(&self) -> LuaMat4

				// Exclusion reason: 
				// default() -> LuaMat4

				add(selfLuaMat4)

				add_assign(<invalid: &mut self>LuaMat4)

				sub(selfLuaMat4)

				sub_assign(<invalid: &mut self>LuaMat4)

				neg(self)

				mul_assign(<invalid: &mut self>LuaMat4)

				mul_assign(<invalid: &mut self>f32)

				sum() -> LuaMat4

				product() -> LuaMat4

				// Exclusion reason: 
				// eq(&self&LuaMat4) -> bool

				as_ref(&self)<invalid: &[f32;16]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f32;16]>

				fmt(&self)

				fmt(&self)

			)
+ BinaryOps			(
self Add LuaMat4 -> LuaMat4 -> LuaMat4
self Sub LuaMat4 -> LuaMat4 -> LuaMat4
self Mul LuaMat4 -> LuaMat4 -> LuaMat4
self Mul LuaVec4 -> LuaVec4 -> LuaVec4
f32 Mul self -> LuaMat4 -> LuaMat4
self Mul f32 -> LuaMat4 -> LuaMat4
			)
+ UnaryOps			(
			)
+ 			Copy(LuaMat3 -> mut (MetaMethod::Index) (s=LuaMat4,b=Mat4,v=LuaVec4))
impl			{
			}
		}
		{
			///A 3x3 column major matrix.
			///
			///This 3x3 matrix type features convenience methods for creating and using linear and
			///affine transformations. If you are primarily dealing with 2D affine transformations the
			///[`DAffine2`](crate::DAffine2) type is much faster and more space efficient than
			///using a 3x3 matrix.
			///
			///Linear transformations including 3D rotation and scale can be created using methods
			///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
			///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
			///[`Self::from_rotation_z()`].
			///
			///The resulting matrices can be use to transform 3D vectors using regular vector
			///multiplication.
			///
			///Affine transformations including 2D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
			///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
			///
			///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
			///are provided for performing affine transforms on 2D vectors and points. These multiply
			///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
			///vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
glam::f64::dmat3::DMat3 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a 3x3 matrix from two column vectors.
				// from_cols(LuaDVec3LuaDVec3LuaDVec3) -> LuaDMat3

				///Creates a 3x3 matrix from a `[f64; 9]` array stored in column major order.
				///If your data is stored in row major you will need to `transpose` the returned
				///matrix.
				from_cols_array(<invalid: &[f64;9]>) -> LuaDMat3

				///Creates a `[f64; 9]` array storing data in column major order.
				///If you require data in row major order `transpose` the matrix first.
				to_cols_array(&self)<invalid: [f64;9]>

				///Creates a 3x3 matrix from a `[[f64; 3]; 3]` 3D array stored in column major order.
				///If your data is in row major order you will need to `transpose` the returned
				///matrix.
				from_cols_array_2d(<invalid: &[[f64;3];3]>) -> LuaDMat3

				///Creates a `[[f64; 3]; 3]` 3D array storing data in column major order.
				///If you require data in row major order `transpose` the matrix first.
				to_cols_array_2d(&self)<invalid: [[f64;3];3]>

				// Exclusion reason: 
				// ///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				// from_diagonal(LuaDVec3) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.
				// from_mat4(LuaDMat4) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from the given quaternion.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				// from_quat(LuaDQuat) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
				// ///radians).
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				// from_axis_angle(LuaDVec3f64) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
				// ///radians).
				// from_euler(LuaEulerRotf64f64f64) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
				// from_rotation_x(f64) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
				// from_rotation_y(f64) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
				// from_rotation_z(f64) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 2D `translation`.
				// ///
				// ///The resulting matrix can be used to transform 2D points and vectors. See
				// ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				// from_translation(LuaDVec2) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 2D rotation `angle` (in
				// ///radians).
				// ///
				// ///The resulting matrix can be used to transform 2D points and vectors. See
				// ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				// from_angle(f64) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
				// ///radians) and `translation`.
				// ///
				// ///The resulting matrix can be used to transform 2D points and vectors. See
				// ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				// from_scale_angle_translation(LuaDVec2f64LuaDVec2) -> LuaDMat3

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
				// ///
				// ///The resulting matrix can be used to transform 2D points and vectors. See
				// ///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				// from_scale(LuaDVec2) -> LuaDMat3

				///Creates an affine transformation matrix from the given 2x2 matrix.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_mat2() -> LuaDMat3

				///Creates a 3x3 matrix from the first 9 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 9 elements long.
				from_cols_slice(<invalid: &[f64]>) -> LuaDMat3

				///Writes the columns of `self` to the first 9 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 9 elements long.
				write_cols_to_slice(self<invalid: &mut [f64]>)

				// Exclusion reason: 
				// ///Returns the matrix column for the given `index`.
				// ///
				// ///# Panics
				// ///
				// ///Panics if `index` is greater than 2.
				// col(&selfusize) -> LuaDVec3

				///Returns a mutable reference to the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 2.
				col_mut(<invalid: &mut self>usize)<invalid: &mut LuaDVec3>

				// Exclusion reason: 
				// ///Returns the matrix row for the given `index`.
				// ///
				// ///# Panics
				// ///
				// ///Panics if `index` is greater than 2.
				// row(&selfusize) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.
				// ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				// is_finite(&self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(&self) -> bool

				// Exclusion reason: 
				// ///Returns the transpose of `self`.
				// transpose(&self) -> LuaDMat3

				// Exclusion reason: 
				// ///Returns the determinant of `self`.
				// determinant(&self) -> f64

				// Exclusion reason: 
				// ///Returns the inverse of `self`.
				// ///
				// ///If the matrix is not invertible the returned matrix will be invalid.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				// inverse(&self) -> LuaDMat3

				// Exclusion reason: 
				// ///Transforms the given 2D vector as a point.
				// ///
				// ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
				// ///
				// ///This method assumes that `self` contains a valid affine transform.
				// transform_point2(&selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Rotates the given 2D vector.
				// ///
				// ///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
				// ///
				// ///This method assumes that `self` contains a valid affine transform.
				// transform_vector2(&selfLuaDVec2) -> LuaDVec2

				// Exclusion reason: 
				// ///Transforms a 3D vector.
				// mul_vec3(&selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Multiplies two 3x3 matrices.
				// mul_mat3(&self&LuaDMat3) -> LuaDMat3

				// Exclusion reason: 
				// ///Adds two 3x3 matrices.
				// add_mat3(&self&LuaDMat3) -> LuaDMat3

				// Exclusion reason: 
				// ///Subtracts two 3x3 matrices.
				// sub_mat3(&self&LuaDMat3) -> LuaDMat3

				// Exclusion reason: 
				// ///Multiplies a 3x3 matrix by a scalar.
				// mul_scalar(&selff64) -> LuaDMat3

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs`
				// ///is less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two matrices contain similar elements. It works best
				// ///when comparing with a known value. The `max_abs_diff` that should be used used
				// ///depends on the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(&selfLuaDMat3f64) -> bool

				// Exclusion reason: 
				// as_mat3(&self) -> LuaMat3

				try_from()

				///Returns the argument unchanged.
				from()

				from() -> LuaDMat3

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaDMat3)

				mul(self)

				mul(selfLuaDMat3)

				mul(selfLuaDVec3)

				mul(selfLuaDMat3)

				mul(selff64)

				// Exclusion reason: 
				// clone(&self) -> LuaDMat3

				// Exclusion reason: 
				// default() -> LuaDMat3

				add(selfLuaDMat3)

				add_assign(<invalid: &mut self>LuaDMat3)

				sub(selfLuaDMat3)

				sub_assign(<invalid: &mut self>LuaDMat3)

				neg(self)

				mul_assign(<invalid: &mut self>LuaDMat3)

				mul_assign(<invalid: &mut self>f64)

				sum() -> LuaDMat3

				product() -> LuaDMat3

				// Exclusion reason: 
				// eq(&self&LuaDMat3) -> bool

				as_ref(&self)<invalid: &[f64;9]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f64;9]>

				fmt(&self)

				fmt(&self)

			)
+ BinaryOps			(
self Add LuaDMat3 -> LuaDMat3 -> LuaDMat3
self Sub LuaDMat3 -> LuaDMat3 -> LuaDMat3
self Mul LuaDMat3 -> LuaDMat3 -> LuaDMat3
self Mul LuaDVec3 -> LuaDVec3 -> LuaDVec3
f64 Mul self -> LuaDMat3 -> LuaDMat3
self Mul f64 -> LuaDMat3 -> LuaDMat3
			)
+ UnaryOps			(
			)
+ 			Copy(LuaMat3 -> mut (MetaMethod::Index) (s=LuaDMat3,b=DMat3,v=LuaDVec3))
impl			{
			}
		}
		{
			///A 4x4 column major matrix.
			///
			///This 4x4 matrix type features convenience methods for creating and using affine transforms and
			///perspective projections. If you are primarily dealing with 3D affine transformations
			///considering using [`DAffine3`](crate::DAffine3) which is faster than a 4x4 matrix
			///for some affine operations.
			///
			///Affine transformations including 3D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_quat()`],
			///[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].
			///
			///Othographic projections can be created using the methods [`Self::orthographic_lh()`] for
			///left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed
			///systems. The resulting matrix is also an affine transformation.
			///
			///The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods
			///are provided for performing affine transformations on 3D vectors and points. These
			///multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`
			///for vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
			///
			///Perspective projections can be created using methods such as
			///[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and
			///[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and
			///[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and
			///[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.
			///
			///The resulting perspective project can be use to transform 3D vectors as points with
			///perspective correction using the [`Self::project_point3()`] convenience method.
glam::f64::dmat4::DMat4 : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a 4x4 matrix from two column vectors.
				// from_cols(LuaDVec4LuaDVec4LuaDVec4LuaDVec4) -> LuaDMat4

				///Creates a 4x4 matrix from a `[f64; 16]` array stored in column major order.
				///If your data is stored in row major you will need to `transpose` the returned
				///matrix.
				from_cols_array(<invalid: &[f64;16]>) -> LuaDMat4

				///Creates a `[f64; 16]` array storing data in column major order.
				///If you require data in row major order `transpose` the matrix first.
				to_cols_array(&self)<invalid: [f64;16]>

				///Creates a 4x4 matrix from a `[[f64; 4]; 4]` 4D array stored in column major order.
				///If your data is in row major order you will need to `transpose` the returned
				///matrix.
				from_cols_array_2d(<invalid: &[[f64;4];4]>) -> LuaDMat4

				///Creates a `[[f64; 4]; 4]` 4D array storing data in column major order.
				///If you require data in row major order `transpose` the matrix first.
				to_cols_array_2d(&self)<invalid: [[f64;4];4]>

				// Exclusion reason: 
				// ///Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				// from_diagonal(LuaDVec4) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
				// ///`translation`.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				// from_scale_rotation_translation(LuaDVec3LuaDQuatLuaDVec3) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 3D `translation`.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				// from_rotation_translation(LuaDQuatLuaDVec3) -> LuaDMat4

				///Extracts `scale`, `rotation` and `translation` from `self`. The input matrix is
				///expected to be a 3D affine transformation matrix otherwise the output will be invalid.
				///
				///# Panics
				///
				///Will panic if the determinant of `self` is zero or if the resulting scale vector
				///contains any zero elements when `glam_assert` is enabled.
				to_scale_rotation_translation(&self)<invalid: (LuaDVec3,LuaDQuat,LuaDVec3)>

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given `rotation` quaternion.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				// from_quat(LuaDQuat) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 3x3 linear transformation
				// ///matrix.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_mat3(LuaDMat3) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix from the given 3D `translation`.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_translation(LuaDVec3) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing a 3D rotation around a normalized
				// ///rotation `axis` of `angle` (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				// from_axis_angle(LuaDVec3f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a affine transformation matrix containing a rotation from the given euler
				// ///rotation sequence and angles (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_euler(LuaEulerRotf64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing a 3D rotation around the x axis of
				// ///`angle` (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_rotation_x(f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing a 3D rotation around the y axis of
				// ///`angle` (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_rotation_y(f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing a 3D rotation around the z axis of
				// ///`angle` (in radians).
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// from_rotation_z(f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
				// ///
				// ///The resulting matrix can be used to transform 3D points and vectors. See
				// ///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				// ///
				// ///# Panics
				// ///
				// ///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				// from_scale(LuaDVec3) -> LuaDMat4

				///Creates a 4x4 matrix from the first 16 values in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 16 elements long.
				from_cols_slice(<invalid: &[f64]>) -> LuaDMat4

				///Writes the columns of `self` to the first 16 elements in `slice`.
				///
				///# Panics
				///
				///Panics if `slice` is less than 16 elements long.
				write_cols_to_slice(self<invalid: &mut [f64]>)

				// Exclusion reason: 
				// ///Returns the matrix column for the given `index`.
				// ///
				// ///# Panics
				// ///
				// ///Panics if `index` is greater than 3.
				// col(&selfusize) -> LuaDVec4

				///Returns a mutable reference to the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 3.
				col_mut(<invalid: &mut self>usize)<invalid: &mut LuaDVec4>

				// Exclusion reason: 
				// ///Returns the matrix row for the given `index`.
				// ///
				// ///# Panics
				// ///
				// ///Panics if `index` is greater than 3.
				// row(&selfusize) -> LuaDVec4

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.
				// ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				// is_finite(&self) -> bool

				// Exclusion reason: 
				// ///Returns `true` if any elements are `NaN`.
				// is_nan(&self) -> bool

				// Exclusion reason: 
				// ///Returns the transpose of `self`.
				// transpose(&self) -> LuaDMat4

				// Exclusion reason: 
				// ///Returns the determinant of `self`.
				// determinant(&self) -> f64

				// Exclusion reason: 
				// ///Returns the inverse of `self`.
				// ///
				// ///If the matrix is not invertible the returned matrix will be invalid.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				// inverse(&self) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a left-handed view matrix using a camera position, an up direction, and a focal
				// ///point.
				// ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `up` is not normalized when `glam_assert` is enabled.
				// look_at_lh(LuaDVec3LuaDVec3LuaDVec3) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a right-handed view matrix using a camera position, an up direction, and a focal
				// ///point.
				// ///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `up` is not normalized when `glam_assert` is enabled.
				// look_at_rh(LuaDVec3LuaDVec3LuaDVec3) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a right-handed perspective projection matrix with [-1,1] depth range.
				// ///This is the same as the OpenGL `gluPerspective` function.
				// ///See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
				// perspective_rh_gl(f64f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a left-handed perspective projection matrix with `[0,1]` depth range.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
				// ///enabled.
				// perspective_lh(f64f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a right-handed perspective projection matrix with `[0,1]` depth range.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
				// ///enabled.
				// perspective_rh(f64f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
				// perspective_infinite_lh(f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
				// perspective_infinite_reverse_lh(f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an infinite right-handed perspective projection matrix with
				// ///`[0,1]` depth range.
				// perspective_infinite_rh(f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates an infinite reverse right-handed perspective projection matrix
				// ///with `[0,1]` depth range.
				// perspective_infinite_reverse_rh(f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a right-handed orthographic projection matrix with `[-1,1]` depth
				// ///range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
				// ///See
				// ///<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
				// orthographic_rh_gl(f64f64f64f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
				// orthographic_lh(f64f64f64f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
				// orthographic_rh(f64f64f64f64f64f64) -> LuaDMat4

				// Exclusion reason: 
				// ///Transforms the given 3D vector as a point, applying perspective correction.
				// ///
				// ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
				// ///The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
				// ///
				// ///This method assumes that `self` contains a projective transform.
				// project_point3(&selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Transforms the given 3D vector as a point.
				// ///
				// ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
				// ///`1.0`.
				// ///
				// ///This method assumes that `self` contains a valid affine transform. It does not perform
				// ///a persective divide, if `self` contains a perspective transform, or if you are unsure,
				// ///the [`Self::project_point3()`] method should be used instead.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
				// transform_point3(&selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Transforms the give 3D vector as a direction.
				// ///
				// ///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
				// ///`0.0`.
				// ///
				// ///This method assumes that `self` contains a valid affine transform.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
				// transform_vector3(&selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Transforms a 4D vector.
				// mul_vec4(&selfLuaDVec4) -> LuaDVec4

				// Exclusion reason: 
				// ///Multiplies two 4x4 matrices.
				// mul_mat4(&self&LuaDMat4) -> LuaDMat4

				// Exclusion reason: 
				// ///Adds two 4x4 matrices.
				// add_mat4(&self&LuaDMat4) -> LuaDMat4

				// Exclusion reason: 
				// ///Subtracts two 4x4 matrices.
				// sub_mat4(&self&LuaDMat4) -> LuaDMat4

				// Exclusion reason: 
				// ///Multiplies a 4x4 matrix by a scalar.
				// mul_scalar(&selff64) -> LuaDMat4

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs`
				// ///is less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two matrices contain similar elements. It works best
				// ///when comparing with a known value. The `max_abs_diff` that should be used used
				// ///depends on the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(&selfLuaDMat4f64) -> bool

				// Exclusion reason: 
				// as_mat4(&self) -> LuaMat4

				try_from()

				///Returns the argument unchanged.
				from()

				from() -> LuaDMat4

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				mul(selfLuaDMat4)

				mul(self)

				mul(selfLuaDMat4)

				mul(selfLuaDVec4)

				mul(selfLuaDMat4)

				mul(selff64)

				// Exclusion reason: 
				// clone(&self) -> LuaDMat4

				// Exclusion reason: 
				// default() -> LuaDMat4

				add(selfLuaDMat4)

				add_assign(<invalid: &mut self>LuaDMat4)

				sub(selfLuaDMat4)

				sub_assign(<invalid: &mut self>LuaDMat4)

				neg(self)

				mul_assign(<invalid: &mut self>LuaDMat4)

				mul_assign(<invalid: &mut self>f64)

				sum() -> LuaDMat4

				product() -> LuaDMat4

				// Exclusion reason: 
				// eq(&self&LuaDMat4) -> bool

				as_ref(&self)<invalid: &[f64;16]>

				as_mut(<invalid: &mut self>)<invalid: &mut [f64;16]>

				fmt(&self)

				fmt(&self)

			)
+ BinaryOps			(
self Add LuaDMat4 -> LuaDMat4 -> LuaDMat4
self Sub LuaDMat4 -> LuaDMat4 -> LuaDMat4
self Mul LuaDMat4 -> LuaDMat4 -> LuaDMat4
self Mul LuaDVec4 -> LuaDVec4 -> LuaDVec4
f64 Mul self -> LuaDMat4 -> LuaDMat4
self Mul f64 -> LuaDMat4 -> LuaDMat4
			)
+ UnaryOps			(
			)
+ 			Copy(LuaMat3 -> mut (MetaMethod::Index) (s=LuaDMat4,b=DMat4,v=LuaDVec4))
impl			{
			}
		}
		{
			///A quaternion representing an orientation.
			///
			///This quaternion is intended to be of unit length but may denormalize due to
			///floating point "error creep" which can occur when successive quaternion
			///operations are applied.
			///
			///This type is 16 byte aligned.
glam::f32::sse2::quat::Quat : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new rotation quaternion.
				// ///
				// ///This should generally not be called manually unless you know what you are doing.
				// ///Use one of the other constructors instead such as `identity` or `from_axis_angle`.
				// ///
				// ///`from_xyzw` is mostly used by unit tests and `serde` deserialization.
				// ///
				// ///# Preconditions
				// ///
				// ///This function does not check if the input is normalized, it is up to the user to
				// ///provide normalized input or to normalized the resulting quaternion.
				// from_xyzw(f32f32f32f32) -> LuaQuat

				///Creates a rotation quaternion from an array.
				///
				///# Preconditions
				///
				///This function does not check if the input is normalized, it is up to the user to
				///provide normalized input or to normalized the resulting quaternion.
				from_array(<invalid: [f32;4]>) -> LuaQuat

				// Exclusion reason: 
				// ///Creates a new rotation quaternion from a 4D vector.
				// ///
				// ///# Preconditions
				// ///
				// ///This function does not check if the input is normalized, it is up to the user to
				// ///provide normalized input or to normalized the resulting quaternion.
				// from_vec4(LuaVec4) -> LuaQuat

				///Creates a rotation quaternion from a slice.
				///
				///# Preconditions
				///
				///This function does not check if the input is normalized, it is up to the user to
				///provide normalized input or to normalized the resulting quaternion.
				///
				///# Panics
				///
				///Panics if `slice` length is less than 4.
				from_slice(<invalid: &[f32]>) -> LuaQuat

				///Writes the quaternion to an unaligned slice.
				///
				///# Panics
				///
				///Panics if `slice` length is less than 4.
				write_to_slice(self<invalid: &mut [f32]>)

				// Exclusion reason: 
				// ///Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
				// ///The axis must be normalized (unit-length).
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				// from_axis_angle(LuaVec3f32) -> LuaQuat

				// Exclusion reason: 
				// ///Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
				// ///
				// ///`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
				// from_scaled_axis(LuaVec3) -> LuaQuat

				// Exclusion reason: 
				// ///Creates a quaternion from the `angle` (in radians) around the x axis.
				// from_rotation_x(f32) -> LuaQuat

				// Exclusion reason: 
				// ///Creates a quaternion from the `angle` (in radians) around the y axis.
				// from_rotation_y(f32) -> LuaQuat

				// Exclusion reason: 
				// ///Creates a quaternion from the `angle` (in radians) around the z axis.
				// from_rotation_z(f32) -> LuaQuat

				// Exclusion reason: 
				// ///Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
				// from_euler(LuaEulerRotf32f32f32) -> LuaQuat

				// Exclusion reason: 
				// ///Creates a quaternion from a 3x3 rotation matrix.
				// from_mat3(&LuaMat3) -> LuaQuat

				// Exclusion reason: 
				// ///Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.
				// from_mat4(&LuaMat4) -> LuaQuat

				// Exclusion reason: 
				// ///Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
				// ///plane spanned by the two vectors.  Will rotate at most 180 degrees.
				// ///
				// ///The input vectors must be normalized (unit-length).
				// ///
				// ///`from_rotation_arc(from, to) * from ≈ to`.
				// ///
				// ///For near-singular cases (from≈to and from≈-to) the current implementation
				// ///is only accurate to about 0.001 (for `f32`).
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				// from_rotation_arc(LuaVec3LuaVec3) -> LuaQuat

				// Exclusion reason: 
				// ///Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
				// ///that the resulting quaternion will rotate `from` so that it is colinear with `to`.
				// ///
				// ///The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
				// ///degrees.
				// ///
				// ///The input vectors must be normalized (unit-length).
				// ///
				// ///`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				// from_rotation_arc_colinear(LuaVec3LuaVec3) -> LuaQuat

				// Exclusion reason: 
				// ///Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
				// ///around the z axis. Will rotate at most 180 degrees.
				// ///
				// ///The input vectors must be normalized (unit-length).
				// ///
				// ///`from_rotation_arc_2d(from, to) * from ≈ to`.
				// ///
				// ///For near-singular cases (from≈to and from≈-to) the current implementation
				// ///is only accurate to about 0.001 (for `f32`).
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				// from_rotation_arc_2d(LuaVec2LuaVec2) -> LuaQuat

				///Returns the rotation axis and angle (in radians) of `self`.
				to_axis_angle(self)<invalid: (LuaVec3,f32)>

				// Exclusion reason: 
				// ///Returns the rotation axis scaled by the rotation in radians.
				// to_scaled_axis(self) -> LuaVec3

				///Returns the rotation angles for the given euler rotation sequence.
				to_euler(selfLuaEulerRot)<invalid: (f32,f32,f32)>

				///`[x, y, z, w]`
				to_array(&self)<invalid: [f32;4]>

				// Exclusion reason: 
				// ///Returns the vector part of the quaternion.
				// xyz(self) -> LuaVec3

				// Exclusion reason: 
				// ///Returns the quaternion conjugate of `self`. For a unit quaternion the
				// ///conjugate is also the inverse.
				// conjugate(self) -> LuaQuat

				// Exclusion reason: 
				// ///Returns the inverse of a normalized quaternion.
				// ///
				// ///Typically quaternion inverse returns the conjugate of a normalized quaternion.
				// ///Because `self` is assumed to already be unit length this method *does not* normalize
				// ///before returning the conjugate.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` is not normalized when `glam_assert` is enabled.
				// inverse(self) -> LuaQuat

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`. The dot product is
				// ///equal to the cosine of the angle between two quaternion rotations.
				// dot(selfLuaQuat) -> f32

				// Exclusion reason: 
				// ///Computes the length of `self`.
				// length(self) -> f32

				// Exclusion reason: 
				// ///Computes the squared length of `self`.
				// ///
				// ///This is generally faster than `length()` as it avoids a square
				// ///root operation.
				// length_squared(self) -> f32

				// Exclusion reason: 
				// ///Computes `1.0 / length()`.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// length_recip(self) -> f32

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// ///
				// ///Panics
				// ///
				// ///Will panic if `self` is zero length when `glam_assert` is enabled.
				// normalize(self) -> LuaQuat

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.
				// ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				// is_finite(self) -> bool

				// Exclusion reason: 
				// is_nan(self) -> bool

				// Exclusion reason: 
				// ///Returns whether `self` of length `1.0` or not.
				// ///
				// ///Uses a precision threshold of `1e-6`.
				// is_normalized(self) -> bool

				// Exclusion reason: 
				// is_near_identity(self) -> bool

				// Exclusion reason: 
				// ///Returns the angle (in radians) for the minimal rotation
				// ///for transforming this quaternion into another.
				// ///
				// ///Both quaternions must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				// angle_between(selfLuaQuat) -> f32

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs`
				// ///is less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two quaternions contain similar elements. It works
				// ///best when comparing with a known value. The `max_abs_diff` that should be used used
				// ///depends on the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(selfLuaQuatf32) -> bool

				// Exclusion reason: 
				// ///Performs a linear interpolation between `self` and `rhs` based on
				// ///the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s`
				// ///is `1.0`, the result will be equal to `rhs`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
				// lerp(selfLuaQuatf32) -> LuaQuat

				// Exclusion reason: 
				// ///Performs a spherical linear interpolation between `self` and `end`
				// ///based on the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s`
				// ///is `1.0`, the result will be equal to `end`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
				// slerp(selfLuaQuatf32) -> LuaQuat

				// Exclusion reason: 
				// ///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` is not normalized when `glam_assert` is enabled.
				// mul_vec3(selfLuaVec3) -> LuaVec3

				// Exclusion reason: 
				// ///Multiplies two quaternions. If they each represent a rotation, the result will
				// ///represent the combined rotation.
				// ///
				// ///Note that due to floating point rounding the result may not be perfectly normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				// mul_quat(selfLuaQuat) -> LuaQuat

				///Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.
				from_affine3() -> LuaQuat

				///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				mul_vec3a(self)

				// Exclusion reason: 
				// as_f64(self) -> LuaDQuat

				try_from()

				///Returns the argument unchanged.
				from()

				// Exclusion reason: 
				// from(LuaQuat) -> LuaQuat

				// Exclusion reason: 
				// from(LuaQuat) -> LuaQuat

				// Exclusion reason: 
				// from(LuaQuat) -> LuaQuat

				// Exclusion reason: 
				// from(LuaQuat) -> LuaQuat

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				// Exclusion reason: 
				// clone(&self) -> LuaQuat

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// ///Adds two quaternions.
				// ///
				// ///The sum is not guaranteed to be normalized.
				// ///
				// ///Note that addition is not the same as combining the rotations represented by the
				// ///two quaternions! That corresponds to multiplication.
				// add(selfLuaQuat) -> LuaQuat

				// Exclusion reason: 
				// ///Subtracts the `rhs` quaternion from `self`.
				// ///
				// ///The difference is not guaranteed to be normalized.
				// sub(selfLuaQuat) -> LuaQuat

				// Exclusion reason: 
				// ///Multiplies a quaternion by a scalar value.
				// ///
				// ///The product is not guaranteed to be normalized.
				// mul(selff32) -> LuaQuat

				// Exclusion reason: 
				// ///Multiplies two quaternions. If they each represent a rotation, the result will
				// ///represent the combined rotation.
				// ///
				// ///Note that due to floating point rounding the result may not be perfectly
				// ///normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				// mul(selfLuaQuat) -> LuaQuat

				///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				mul(selfLuaVec3)

				mul(self)

				// Exclusion reason: 
				// ///Divides a quaternion by a scalar value.
				// ///The quotient is not guaranteed to be normalized.
				// div(selff32) -> LuaQuat

				///Multiplies two quaternions. If they each represent a rotation, the result will
				///represent the combined rotation.
				///
				///Note that due to floating point rounding the result may not be perfectly
				///normalized.
				///
				///# Panics
				///
				///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				mul_assign(<invalid: &mut self>LuaQuat)

				// Exclusion reason: 
				// neg(self) -> LuaQuat

				// Exclusion reason: 
				// default() -> LuaQuat

				// Exclusion reason: 
				// eq(&self&LuaQuat) -> bool

				as_ref(&self)<invalid: &[f32;4]>

				sum() -> LuaQuat

				product() -> LuaQuat

				deref(&self)

				deref_mut(<invalid: &mut self>)

			)
+ BinaryOps			(
self Add LuaQuat -> LuaQuat -> LuaQuat
self Sub LuaQuat -> LuaQuat -> LuaQuat
self Div f32 -> LuaQuat -> LuaQuat
self Mul f32 -> LuaQuat -> LuaQuat
self Mul LuaQuat -> LuaQuat -> LuaQuat
self Mul LuaVec3 -> LuaVec3 -> LuaVec3
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
			///A quaternion representing an orientation.
			///
			///This quaternion is intended to be of unit length but may denormalize due to
			///floating point "error creep" which can occur when successive quaternion
			///operations are applied.
glam::f64::dquat::DQuat : Value
AutoMethods			(
				// Exclusion reason: 
				// ///Creates a new rotation quaternion.
				// ///
				// ///This should generally not be called manually unless you know what you are doing.
				// ///Use one of the other constructors instead such as `identity` or `from_axis_angle`.
				// ///
				// ///`from_xyzw` is mostly used by unit tests and `serde` deserialization.
				// ///
				// ///# Preconditions
				// ///
				// ///This function does not check if the input is normalized, it is up to the user to
				// ///provide normalized input or to normalized the resulting quaternion.
				// from_xyzw(f64f64f64f64) -> LuaDQuat

				///Creates a rotation quaternion from an array.
				///
				///# Preconditions
				///
				///This function does not check if the input is normalized, it is up to the user to
				///provide normalized input or to normalized the resulting quaternion.
				from_array(<invalid: [f64;4]>) -> LuaDQuat

				// Exclusion reason: 
				// ///Creates a new rotation quaternion from a 4D vector.
				// ///
				// ///# Preconditions
				// ///
				// ///This function does not check if the input is normalized, it is up to the user to
				// ///provide normalized input or to normalized the resulting quaternion.
				// from_vec4(LuaDVec4) -> LuaDQuat

				///Creates a rotation quaternion from a slice.
				///
				///# Preconditions
				///
				///This function does not check if the input is normalized, it is up to the user to
				///provide normalized input or to normalized the resulting quaternion.
				///
				///# Panics
				///
				///Panics if `slice` length is less than 4.
				from_slice(<invalid: &[f64]>) -> LuaDQuat

				///Writes the quaternion to an unaligned slice.
				///
				///# Panics
				///
				///Panics if `slice` length is less than 4.
				write_to_slice(self<invalid: &mut [f64]>)

				// Exclusion reason: 
				// ///Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
				// ///The axis must be normalized (unit-length).
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				// from_axis_angle(LuaDVec3f64) -> LuaDQuat

				// Exclusion reason: 
				// ///Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
				// ///
				// ///`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
				// from_scaled_axis(LuaDVec3) -> LuaDQuat

				// Exclusion reason: 
				// ///Creates a quaternion from the `angle` (in radians) around the x axis.
				// from_rotation_x(f64) -> LuaDQuat

				// Exclusion reason: 
				// ///Creates a quaternion from the `angle` (in radians) around the y axis.
				// from_rotation_y(f64) -> LuaDQuat

				// Exclusion reason: 
				// ///Creates a quaternion from the `angle` (in radians) around the z axis.
				// from_rotation_z(f64) -> LuaDQuat

				// Exclusion reason: 
				// ///Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
				// from_euler(LuaEulerRotf64f64f64) -> LuaDQuat

				// Exclusion reason: 
				// ///Creates a quaternion from a 3x3 rotation matrix.
				// from_mat3(&LuaDMat3) -> LuaDQuat

				// Exclusion reason: 
				// ///Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.
				// from_mat4(&LuaDMat4) -> LuaDQuat

				// Exclusion reason: 
				// ///Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
				// ///plane spanned by the two vectors.  Will rotate at most 180 degrees.
				// ///
				// ///The input vectors must be normalized (unit-length).
				// ///
				// ///`from_rotation_arc(from, to) * from ≈ to`.
				// ///
				// ///For near-singular cases (from≈to and from≈-to) the current implementation
				// ///is only accurate to about 0.001 (for `f32`).
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				// from_rotation_arc(LuaDVec3LuaDVec3) -> LuaDQuat

				// Exclusion reason: 
				// ///Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
				// ///that the resulting quaternion will rotate `from` so that it is colinear with `to`.
				// ///
				// ///The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
				// ///degrees.
				// ///
				// ///The input vectors must be normalized (unit-length).
				// ///
				// ///`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				// from_rotation_arc_colinear(LuaDVec3LuaDVec3) -> LuaDQuat

				// Exclusion reason: 
				// ///Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
				// ///around the z axis. Will rotate at most 180 degrees.
				// ///
				// ///The input vectors must be normalized (unit-length).
				// ///
				// ///`from_rotation_arc_2d(from, to) * from ≈ to`.
				// ///
				// ///For near-singular cases (from≈to and from≈-to) the current implementation
				// ///is only accurate to about 0.001 (for `f32`).
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				// from_rotation_arc_2d(LuaDVec2LuaDVec2) -> LuaDQuat

				///Returns the rotation axis and angle (in radians) of `self`.
				to_axis_angle(self)<invalid: (LuaDVec3,f64)>

				// Exclusion reason: 
				// ///Returns the rotation axis scaled by the rotation in radians.
				// to_scaled_axis(self) -> LuaDVec3

				///Returns the rotation angles for the given euler rotation sequence.
				to_euler(selfLuaEulerRot)<invalid: (f64,f64,f64)>

				///`[x, y, z, w]`
				to_array(&self)<invalid: [f64;4]>

				// Exclusion reason: 
				// ///Returns the vector part of the quaternion.
				// xyz(self) -> LuaDVec3

				// Exclusion reason: 
				// ///Returns the quaternion conjugate of `self`. For a unit quaternion the
				// ///conjugate is also the inverse.
				// conjugate(self) -> LuaDQuat

				// Exclusion reason: 
				// ///Returns the inverse of a normalized quaternion.
				// ///
				// ///Typically quaternion inverse returns the conjugate of a normalized quaternion.
				// ///Because `self` is assumed to already be unit length this method *does not* normalize
				// ///before returning the conjugate.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` is not normalized when `glam_assert` is enabled.
				// inverse(self) -> LuaDQuat

				// Exclusion reason: 
				// ///Computes the dot product of `self` and `rhs`. The dot product is
				// ///equal to the cosine of the angle between two quaternion rotations.
				// dot(selfLuaDQuat) -> f64

				// Exclusion reason: 
				// ///Computes the length of `self`.
				// length(self) -> f64

				// Exclusion reason: 
				// ///Computes the squared length of `self`.
				// ///
				// ///This is generally faster than `length()` as it avoids a square
				// ///root operation.
				// length_squared(self) -> f64

				// Exclusion reason: 
				// ///Computes `1.0 / length()`.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// length_recip(self) -> f64

				// Exclusion reason: 
				// ///Returns `self` normalized to length 1.0.
				// ///
				// ///For valid results, `self` must _not_ be of length zero.
				// ///
				// ///Panics
				// ///
				// ///Will panic if `self` is zero length when `glam_assert` is enabled.
				// normalize(self) -> LuaDQuat

				// Exclusion reason: 
				// ///Returns `true` if, and only if, all elements are finite.
				// ///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				// is_finite(self) -> bool

				// Exclusion reason: 
				// is_nan(self) -> bool

				// Exclusion reason: 
				// ///Returns whether `self` of length `1.0` or not.
				// ///
				// ///Uses a precision threshold of `1e-6`.
				// is_normalized(self) -> bool

				// Exclusion reason: 
				// is_near_identity(self) -> bool

				// Exclusion reason: 
				// ///Returns the angle (in radians) for the minimal rotation
				// ///for transforming this quaternion into another.
				// ///
				// ///Both quaternions must be normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				// angle_between(selfLuaDQuat) -> f64

				// Exclusion reason: 
				// ///Returns true if the absolute difference of all elements between `self` and `rhs`
				// ///is less than or equal to `max_abs_diff`.
				// ///
				// ///This can be used to compare if two quaternions contain similar elements. It works
				// ///best when comparing with a known value. The `max_abs_diff` that should be used used
				// ///depends on the values being compared against.
				// ///
				// ///For more see
				// ///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				// abs_diff_eq(selfLuaDQuatf64) -> bool

				// Exclusion reason: 
				// ///Performs a linear interpolation between `self` and `rhs` based on
				// ///the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s`
				// ///is `1.0`, the result will be equal to `rhs`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
				// lerp(selfLuaDQuatf64) -> LuaDQuat

				// Exclusion reason: 
				// ///Performs a spherical linear interpolation between `self` and `end`
				// ///based on the value `s`.
				// ///
				// ///When `s` is `0.0`, the result will be equal to `self`.  When `s`
				// ///is `1.0`, the result will be equal to `end`.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
				// slerp(selfLuaDQuatf64) -> LuaDQuat

				// Exclusion reason: 
				// ///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` is not normalized when `glam_assert` is enabled.
				// mul_vec3(selfLuaDVec3) -> LuaDVec3

				// Exclusion reason: 
				// ///Multiplies two quaternions. If they each represent a rotation, the result will
				// ///represent the combined rotation.
				// ///
				// ///Note that due to floating point rounding the result may not be perfectly normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				// mul_quat(selfLuaDQuat) -> LuaDQuat

				///Creates a quaternion from a 3x3 rotation matrix inside a 3D affine transform.
				from_affine3() -> LuaDQuat

				// Exclusion reason: 
				// as_f32(self) -> LuaQuat

				try_from()

				///Returns the argument unchanged.
				from()

				// Exclusion reason: 
				// from(LuaDQuat) -> LuaDQuat

				// Exclusion reason: 
				// from(LuaDQuat) -> LuaDQuat

				// Exclusion reason: 
				// from(LuaDQuat) -> LuaDQuat

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_string(&self)

				to_owned(&self)

				clone_into(&self)

				is_valid_bit_pattern() -> bool

				serialize(&self)

				deserialize()

				// Exclusion reason: 
				// clone(&self) -> LuaDQuat

				fmt(&self)

				fmt(&self)

				// Exclusion reason: 
				// ///Adds two quaternions.
				// ///
				// ///The sum is not guaranteed to be normalized.
				// ///
				// ///Note that addition is not the same as combining the rotations represented by the
				// ///two quaternions! That corresponds to multiplication.
				// add(selfLuaDQuat) -> LuaDQuat

				// Exclusion reason: 
				// ///Subtracts the `rhs` quaternion from `self`.
				// ///
				// ///The difference is not guaranteed to be normalized.
				// sub(selfLuaDQuat) -> LuaDQuat

				// Exclusion reason: 
				// ///Multiplies a quaternion by a scalar value.
				// ///
				// ///The product is not guaranteed to be normalized.
				// mul(selff64) -> LuaDQuat

				// Exclusion reason: 
				// ///Multiplies two quaternions. If they each represent a rotation, the result will
				// ///represent the combined rotation.
				// ///
				// ///Note that due to floating point rounding the result may not be perfectly
				// ///normalized.
				// ///
				// ///# Panics
				// ///
				// ///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				// mul(selfLuaDQuat) -> LuaDQuat

				///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				mul(selfLuaDVec3)

				// Exclusion reason: 
				// ///Divides a quaternion by a scalar value.
				// ///The quotient is not guaranteed to be normalized.
				// div(selff64) -> LuaDQuat

				///Multiplies two quaternions. If they each represent a rotation, the result will
				///represent the combined rotation.
				///
				///Note that due to floating point rounding the result may not be perfectly
				///normalized.
				///
				///# Panics
				///
				///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				mul_assign(<invalid: &mut self>LuaDQuat)

				// Exclusion reason: 
				// neg(self) -> LuaDQuat

				// Exclusion reason: 
				// default() -> LuaDQuat

				// Exclusion reason: 
				// eq(&self&LuaDQuat) -> bool

				as_ref(&self)<invalid: &[f64;4]>

				sum() -> LuaDQuat

				product() -> LuaDQuat

			)
+ BinaryOps			(
self Add LuaDQuat -> LuaDQuat -> LuaDQuat
self Sub LuaDQuat -> LuaDQuat -> LuaDQuat
self Div f64 -> LuaDQuat -> LuaDQuat
self Mul f64 -> LuaDQuat -> LuaDQuat
self Mul LuaDQuat -> LuaDQuat -> LuaDQuat
self Mul LuaDVec3 -> LuaDVec3 -> LuaDVec3
			)
+ UnaryOps			(
			)
impl			{
			}
		}
		{
			///Euler rotation sequences.
			///
			///The angles are applied starting from the right.
			///E.g. XYZ will first apply the z-axis rotation.
			///
			///YXZ can be used for yaw (y-axis), pitch (x-axis), roll (z-axis).
			///
			///The two-axis rotations (e.g. ZYZ) are not fully tested and have to be treated with caution.
glam::euler::EulerRot : Value
AutoMethods			(
				try_from()

				///Returns the argument unchanged.
				from()

				///Calls `U::from(self)`.
				///
				///That is, this conversion is whatever the implementation of
				///<code>[From]&lt;T&gt; for U</code> chooses to do.
				into(self)

				borrow(&self)

				type_id(&self)

				try_into(self)

				borrow_mut(<invalid: &mut self>)

				to_owned(&self)

				clone_into(&self)

				fmt(&self)

				// Exclusion reason: 
				// clone(&self) -> LuaEulerRot

				// Exclusion reason: 
				// ///Default `YXZ` as yaw (y-axis), pitch (x-axis), roll (z-axis).
				// default() -> LuaEulerRot

			)
+ BinaryOps			(
			)
+ UnaryOps			(
			)
impl			{
			}
		}
	]
)
;
