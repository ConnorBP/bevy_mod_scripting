// This file is generated by `bevy_mod_scripting_derive/main.rs` change the template not this file
use bevy_mod_scripting_derive::impl_lua_newtypes;
impl_lua_newtypes!(
	(
		use std::ops::*;
		use phf::{phf_map, Map};
		use crate::ReflectPtr;
		use crate::{LuaWorld,ScriptRef,ScriptRefBase, api::ValueIndex};
		use std::sync::Arc;
		use crate::util::impl_tealr_type;
		use num_traits::cast::ToPrimitive;
		use bevy_mod_scripting_derive::{replace};
		use tealr::{mlu::{mlua,mlua::{prelude::*,Error,MetaMethod,Value}},create_union_mlua};
		
		use bevy::ui::AlignContent;
		use bevy::ui::AlignItems;
		use bevy::ui::AlignSelf;
		use bevy::ui::Direction;
		use bevy::ui::FlexDirection;
		use bevy::ui::FlexWrap;
		use bevy::ui::FocusPolicy;
		use bevy::ui::Interaction;
		use bevy::ui::JustifyContent;
		use bevy::ui::Overflow;
		use bevy::ui::PositionType;
		use bevy::ui::Val;
		use bevy::ui::CalculatedClip;
		use bevy::ui::CalculatedSize;
		use bevy::ui::Node;
		use bevy::ui::Style;
		use bevy::ui::UiColor;
		use bevy::ui::UiImage;
		use bevy::ui::widget::Button;
		use bevy::ui::widget::ImageMode;
		use bevy::ui::Display;
		use bevy::animation::AnimationPlayer;
		use bevy::core::Name;
		use bevy::gltf::GltfExtras;
		use bevy::hierarchy::Children;
		use bevy::hierarchy::Parent;
		use bevy::hierarchy::PreviousParent;
		use bevy::text::Text2dBounds;
		use bevy::text::Text2dSize;
		use bevy::text::Text;
		use bevy::text::TextAlignment;
		use bevy::text::TextSection;
		use bevy::text::TextStyle;
		use bevy::text::HorizontalAlign;
		use bevy::text::VerticalAlign;
		use bevy::time::Stopwatch;
		use bevy::time::Timer;
		use bevy::reflect::DynamicArray;
		use bevy::reflect::DynamicList;
		use bevy::reflect::DynamicMap;
		use bevy::reflect::DynamicStruct;
		use bevy::reflect::DynamicTuple;
		use bevy::reflect::DynamicTupleStruct;
		use bevy::ecs::entity::Entity;
		use bevy::transform::components::Transform;
		use bevy::transform::components::GlobalTransform;
		use bevy::pbr::AmbientLight;
		use bevy::pbr::CubemapVisibleEntities;
		use bevy::pbr::DirectionalLight;
		use bevy::pbr::DirectionalLightShadowMap;
		use bevy::pbr::NotShadowCaster;
		use bevy::pbr::NotShadowReceiver;
		use bevy::pbr::PointLight;
		use bevy::pbr::PointLightShadowMap;
		use bevy::pbr::AlphaMode;
		use bevy::pbr::wireframe::Wireframe;
		use bevy::pbr::wireframe::WireframeConfig;
		use bevy::core_pipeline::core_3d::Camera3dDepthLoadOp;
		use bevy::core_pipeline::clear_color::ClearColor;
		use bevy::core_pipeline::clear_color::ClearColorConfig;
		use bevy::core_pipeline::core_2d::Camera2d;
		use bevy::core_pipeline::core_3d::Camera3d;
		use bevy::sprite::Anchor;
		use bevy::sprite::Mesh2dHandle;
		use bevy::sprite::TextureAtlasSprite;
		use bevy::sprite::Sprite;
		use bevy::sprite::Rect;
		use bevy::render::view::visibility::RenderLayers;
		use bevy::render::view::visibility::Visibility;
		use bevy::render::view::visibility::VisibleEntities;
		use bevy::render::view::visibility::ComputedVisibility;
		use bevy::render::mesh::skinning::SkinnedMesh;
		use bevy::render::camera::ScalingMode;
		use bevy::render::camera::WindowOrigin;
		use bevy::render::color::Color;
		use bevy::render::primitives::Aabb;
		use bevy::render::primitives::CubemapFrusta;
		use bevy::render::primitives::Frustum;
		use bevy::render::view::Msaa;
		use bevy::render::camera::Camera;
		use bevy::render::camera::RenderTarget;
		use bevy::render::camera::Viewport;
		use bevy::render::camera::Projection;
		use bevy::render::camera::OrthographicProjection;
		use bevy::render::camera::PerspectiveProjection;
		use bevy::render::camera::DepthCalculation;
		use bevy::render::camera::CameraRenderGraph;
		use bevy::asset::AssetPathId;
		use bevy::asset::LabelId;
		use bevy::asset::SourcePathId;
		use bevy::asset::HandleId;
		use bevy::math::f32::Vec2;
		use bevy::math::f32::Vec3;
		use bevy::math::f32::Vec3A;
		use bevy::math::f32::Vec4;
		use bevy::math::bool::BVec2;
		use bevy::math::bool::BVec3;
		use bevy::math::bool::BVec4;
		use bevy::math::bool::BVec3A;
		use bevy::math::bool::BVec4A;
		use bevy::math::f64::DVec2;
		use bevy::math::f64::DVec3;
		use bevy::math::f64::DVec4;
		use bevy::math::i32::IVec2;
		use bevy::math::i32::IVec3;
		use bevy::math::i32::IVec4;
		use bevy::math::u32::UVec2;
		use bevy::math::u32::UVec3;
		use bevy::math::u32::UVec4;
		use bevy::math::f32::Mat3;
		use bevy::math::f32::Mat2;
		use bevy::math::f32::Mat3A;
		use bevy::math::f32::Mat4;
		use bevy::math::f64::DMat3;
		use bevy::math::f64::DMat4;
		use bevy::math::f32::Affine2;
		use bevy::math::f32::Affine3A;
		use bevy::math::f64::DAffine2;
		use bevy::math::f64::DAffine3;
		use bevy::math::f32::Quat;
		use bevy::math::f64::DQuat;
		use bevy::math::EulerRot;
		use bevy::render::camera::CameraProjection;
	)
	[
		LuaWorld
	]
	[
		
		    {
		            usize : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<usize>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_usize().ok_or_else(||Error::RuntimeError("Value not compatibile with usize".to_owned()))?)));
		            }
		    },
		    {
		            isize : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<isize>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_isize().ok_or_else(||Error::RuntimeError("Value not compatibile with isize".to_owned()))?)));
		            }
		    },
		    {
		            i128 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i128>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i128().ok_or_else(||Error::RuntimeError("Value not compatibile with i128".to_owned()))?)));
		            }
		    },
		    {
		            i64 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i64>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i64().ok_or_else(||Error::RuntimeError("Value not compatibile with i64".to_owned()))?)));
		            }
		    },
		    {
		            i32 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i32>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i32().ok_or_else(||Error::RuntimeError("Value not compatibile with i32".to_owned()))?)));
		            }
		    },
		    {
		            i16 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i16>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i16().ok_or_else(||Error::RuntimeError("Value not compatibile with i16".to_owned()))?)));
		            }
		    },
		    {
		            i8 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<i8>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_i8().ok_or_else(||Error::RuntimeError("Value not compatibile with i8".to_owned()))?)));
		            }
		    },
		    {
		            u128 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u128>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u128().ok_or_else(||Error::RuntimeError("Value not compatibile with u128".to_owned()))?)));
		            }
		    },
		    {
		            u64 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u64>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u64().ok_or_else(||Error::RuntimeError("Value not compatibile with u64".to_owned()))?)));
		            }
		    },
		    {
		            u32 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u32>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u32().ok_or_else(||Error::RuntimeError("Value not compatibile with u32".to_owned()))?)));
		            }
		    },
		    {
		            u16 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u16>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u16().ok_or_else(||Error::RuntimeError("Value not compatibile with u16".to_owned()))?)));
		            }
		    },
		    {
		            u8 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Integer(s.downcast_ref::<u8>().unwrap().to_i64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_integer(v)?.ok_or_else(||Error::RuntimeError("Not an integer".to_owned()))?.to_u8().ok_or_else(||Error::RuntimeError("Value not compatibile with u8".to_owned()))?)));
		            }
		    },
		    {
		            f32 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Number(s.downcast_ref::<f32>().unwrap().to_f64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_number(v)?.ok_or_else(||Error::RuntimeError("Not a number".to_owned()))?.to_f32().ok_or_else(||Error::RuntimeError("Value not compatibile with f32".to_owned()))?)));
		            }
		    },
		    {
		            f64 : Primitive
		            impl {
		            "to" => |r,_| r.get(|s,_| Value::Number(s.downcast_ref::<f64>().unwrap().to_f64().unwrap()));
		            "from" =>   |r,c,v : Value| r.get_mut(|s,_| Ok(s.apply(&c.coerce_number(v)?.ok_or_else(||Error::RuntimeError("Not a number".to_owned()))?.to_f64().ok_or_else(||Error::RuntimeError("Value not compatibile with f64".to_owned()))?)));
		            }
		    },
		    {
		            alloc::string::String : Primitive
		            impl {
		            "to" => |r,c| r.get(|s,_| Value::String(c.create_string(s.downcast_ref::<String>().unwrap()).unwrap()));
		            "from" =>   |r,c,v : Value| c.coerce_string(v)?.ok_or_else(||Error::RuntimeError("Not a string".to_owned())).and_then(|string| r.get_mut(|s,_| Ok(s.apply(&string.to_str()?.to_owned()))));                             //      
		            }
		    },
		    
		{
			///Defines how each line is aligned within the flexbox.
			///
			///It only applies if [`FlexWrap::Wrap`] is present and if there are multiple lines of items.
			bevy_ui::AlignContent : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///How items are aligned according to the cross axis
			bevy_ui::AlignItems : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Works like [`AlignItems`] but applies only to a single item
			bevy_ui::AlignSelf : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Defines the text direction
			///
			///For example English is written LTR (left-to-right) while Arabic is written RTL (right-to-left).
			bevy_ui::Direction : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Defines how flexbox items are ordered within a flexbox
			bevy_ui::FlexDirection : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Defines if flexbox items appear on a single line or on multiple lines
			bevy_ui::FlexWrap : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describes whether the node should block interactions with lower nodes
			bevy_ui::FocusPolicy : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describes what type of input interaction has occurred for a UI node.
			///
			///This is commonly queried with a `Changed<Interaction>` filter.
			bevy_ui::Interaction : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Defines how items are aligned according to the main axis
			bevy_ui::JustifyContent : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Whether to show or hide overflowing items
			bevy_ui::Overflow : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The strategy used to position this node
			bevy_ui::PositionType : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///An enum that describes possible types of value in flexbox layout options
			bevy_ui::Val : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
				self Add f32 -> LuaVal,
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The calculated clip of the node
			bevy_ui::CalculatedClip : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The calculated size of the node
			bevy_ui::CalculatedSize : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describes the size of a UI node
			bevy_ui::Node : Value
			: Fields
			(
				/// The size of the node as width and height in pixels
				size: LuaVec2,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describes the style of a UI node
			///
			///It uses the [Flexbox](https://cssreference.io/flexbox/) system.
			///
			///**Note:** Bevy's UI is upside down compared to how Flexbox normally works, to stay consistent with engine paradigms about layouting from
			///the upper left corner of the display
			bevy_ui::Style : Value
			: Fields
			(
				/// Whether to arrange this node and its children with flexbox layout
				display: LuaDisplay,
				/// Whether to arrange this node relative to other nodes, or positioned absolutely
				position_type: LuaPositionType,
				/// Which direction the content of this node should go
				direction: LuaDirection,
				/// Whether to use column or row layout
				flex_direction: LuaFlexDirection,
				/// How to wrap nodes
				flex_wrap: LuaFlexWrap,
				/// How items are aligned according to the cross axis
				align_items: LuaAlignItems,
				/// Like align_items but for only this item
				align_self: LuaAlignSelf,
				/// How to align each line, only applies if flex_wrap is set to
				/// [`FlexWrap::Wrap`] and there are multiple lines of items
				align_content: LuaAlignContent,
				/// How items align according to the main axis
				justify_content: LuaJustifyContent,
				/// Defines how much a flexbox item should grow if there's space available
				flex_grow: f32,
				/// How to shrink if there's not enough space available
				flex_shrink: f32,
				/// The initial size of the item
				flex_basis: LuaVal,
				/// How to handle overflow
				overflow: LuaOverflow,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The color of the node
			bevy_ui::UiColor : Value
			: Fields
			(
				0: LuaColor,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The image of the node
			bevy_ui::UiImage : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Marker struct for buttons
			bevy_ui::widget::Button : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describes how to resize the Image node
			bevy_ui::widget::ImageMode : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Whether to use Flexbox layout
			bevy_ui::Display : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Animation controls
			bevy_animation::AnimationPlayer : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Is the animation paused
				is_paused(&self) -> bool,

				///Speed of the animation playback
				speed(&self) -> f32,

				///Time elapsed playing the animation
				elapsed(&self) -> f32,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Component used to identify an entity. Stores a hash for faster comparisons
			///The hash is eagerly re-computed upon each update to the name.
			///
			///[`Name`] should not be treated as a globally unique identifier for entities,
			///as multiple entities can have the same name.  [`bevy_ecs::entity::Entity`] should be
			///used instead as the default unique identifier.
			bevy_core::Name : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_gltf::GltfExtras : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Contains references to the child entities of this entity
			bevy_hierarchy::Children : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Holds a reference to the parent entity of this entity.
			///This component should only be present on entities that actually have a parent entity.
			bevy_hierarchy::Parent : Value
			: Fields
			(
				0: LuaEntity,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Component that holds the [`Parent`] this entity had previously
			bevy_hierarchy::PreviousParent : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The maximum width and height of text. The text will wrap according to the specified size.
			///Characters out of the bounds after wrapping will be truncated. Text is aligned according to the
			///specified `TextAlignment`.
			///
			///Note: only characters that are completely out of the bounds will be truncated, so this is not a
			///reliable limit if it is necessary to contain the text strictly in the bounds. Currently this
			///component is mainly useful for text wrapping only.
			bevy_text::Text2dBounds : Value
			: Fields
			(
				size: LuaVec2,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The calculated size of text drawn in 2D scene.
			bevy_text::Text2dSize : Value
			: Fields
			(
				size: LuaVec2,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_text::Text : Value
			: Fields
			(
				alignment: LuaTextAlignment,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_text::TextAlignment : Value
			: Fields
			(
				vertical: LuaVerticalAlign,
				horizontal: LuaHorizontalAlign,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_text::TextSection : Value
			: Fields
			(
				style: LuaTextStyle,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_text::TextStyle : Value
			: Fields
			(
				font_size: f32,
				color: LuaColor,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describes horizontal alignment preference for positioning & bounds.
			bevy_text::HorizontalAlign : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describes vertical alignment preference for positioning & bounds. Currently a placeholder
			///for future functionality.
			bevy_text::VerticalAlign : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A Stopwatch is a struct that track elapsed time when started.
			///
			///# Examples
			///
			///```
			///# use bevy_time::*;
			///use std::time::Duration;
			///let mut stopwatch = Stopwatch::new();
			///assert_eq!(stopwatch.elapsed_secs(), 0.0);
			///
			///stopwatch.tick(Duration::from_secs_f32(1.0)); // tick one second
			///assert_eq!(stopwatch.elapsed_secs(), 1.0);
			///
			///stopwatch.pause();
			///stopwatch.tick(Duration::from_secs_f32(1.0)); // paused stopwatches don't tick
			///assert_eq!(stopwatch.elapsed_secs(), 1.0);
			///
			///stopwatch.reset(); // reset the stopwatch
			///assert!(stopwatch.paused());
			///assert_eq!(stopwatch.elapsed_secs(), 0.0);
			///```
			bevy_time::Stopwatch : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Create a new unpaused `Stopwatch` with no elapsed time.
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///let stopwatch = Stopwatch::new();
				///assert_eq!(stopwatch.elapsed_secs(), 0.0);
				///assert_eq!(stopwatch.paused(), false);
				///```
				new() -> LuaStopwatch,

				///Returns the elapsed time since the last [`reset`](Stopwatch::reset)
				///of the stopwatch, in seconds.
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///use std::time::Duration;
				///let mut stopwatch = Stopwatch::new();
				///stopwatch.tick(Duration::from_secs(1));
				///assert_eq!(stopwatch.elapsed_secs(), 1.0);
				///```
				///
				///# See Also
				///
				///[`elapsed`](Stopwatch::elapsed) - if a `Duration` is desirable instead.
				elapsed_secs(&self) -> f32,

				///Returns `true` if the stopwatch is paused.
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///let mut stopwatch = Stopwatch::new();
				///assert!(!stopwatch.paused());
				///stopwatch.pause();
				///assert!(stopwatch.paused());
				///stopwatch.unpause();
				///assert!(!stopwatch.paused());
				///```
				paused(&self) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Tracks elapsed time. Enters the finished state once `duration` is reached.
			///
			///Non repeating timers will stop tracking and stay in the finished state until reset.
			///Repeating timers will only be in the finished state on each tick `duration` is reached or
			///exceeded, and can still be reset at any given point.
			///
			///Paused timers will not have elapsed time increased.
			bevy_time::Timer : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Creates a new timer with a given duration in seconds.
				///
				///# Example
				///```
				///# use bevy_time::*;
				///let mut timer = Timer::from_seconds(1.0, false);
				///```
				from_seconds(f32,bool) -> LuaTimer,

				///Returns `true` if the timer has reached its duration.
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///use std::time::Duration;
				///let mut timer = Timer::from_seconds(1.0, false);
				///timer.tick(Duration::from_secs_f32(1.5));
				///assert!(timer.finished());
				///timer.tick(Duration::from_secs_f32(0.5));
				///assert!(timer.finished());
				///```
				finished(&self) -> bool,

				///Returns `true` only on the tick the timer reached its duration.
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///use std::time::Duration;
				///let mut timer = Timer::from_seconds(1.0, false);
				///timer.tick(Duration::from_secs_f32(1.5));
				///assert!(timer.just_finished());
				///timer.tick(Duration::from_secs_f32(0.5));
				///assert!(!timer.just_finished());
				///```
				just_finished(&self) -> bool,

				///Returns the time elapsed on the timer as a `f32`.
				///See also [`Timer::elapsed`](Timer::elapsed).
				elapsed_secs(&self) -> f32,

				///Returns `true` if the timer is repeating.
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///let mut timer = Timer::from_seconds(1.0, true);
				///assert!(timer.repeating());
				///```
				repeating(&self) -> bool,

				///Returns `true` if the timer is paused.
				///
				///See also [`Stopwatch::paused`](Stopwatch::paused).
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///let mut timer = Timer::from_seconds(1.0, false);
				///assert!(!timer.paused());
				///timer.pause();
				///assert!(timer.paused());
				///timer.unpause();
				///assert!(!timer.paused());
				///```
				paused(&self) -> bool,

				///Returns the percentage of the timer elapsed time (goes from 0.0 to 1.0).
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///use std::time::Duration;
				///let mut timer = Timer::from_seconds(2.0, false);
				///timer.tick(Duration::from_secs_f32(0.5));
				///assert_eq!(timer.percent(), 0.25);
				///```
				percent(&self) -> f32,

				///Returns the percentage of the timer remaining time (goes from 0.0 to 1.0).
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///use std::time::Duration;
				///let mut timer = Timer::from_seconds(2.0, false);
				///timer.tick(Duration::from_secs_f32(0.5));
				///assert_eq!(timer.percent_left(), 0.75);
				///```
				percent_left(&self) -> f32,

				///Returns the number of times a repeating timer
				///finished during the last [`tick`](Timer<T>::tick) call.
				///
				///For non repeating-timers, this method will only ever
				///return 0 or 1.
				///
				///# Examples
				///```
				///# use bevy_time::*;
				///use std::time::Duration;
				///let mut timer = Timer::from_seconds(1.0, true);
				///timer.tick(Duration::from_secs_f32(6.0));
				///assert_eq!(timer.times_finished_this_tick(), 6);
				///timer.tick(Duration::from_secs_f32(2.0));
				///assert_eq!(timer.times_finished_this_tick(), 2);
				///timer.tick(Duration::from_secs_f32(0.5));
				///assert_eq!(timer.times_finished_this_tick(), 0);
				///```
				times_finished_this_tick(&self) -> u32,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A fixed-size list of reflected values.
			///
			///This differs from [`DynamicList`] in that the size of the [`DynamicArray`]
			///is constant, whereas a [`DynamicList`] can have items added and removed.
			///
			///This isn't to say that a [`DynamicArray`] is immutable— its items
			///can be mutated— just that the _number_ of items cannot change.
			///
			///[`DynamicList`]: crate::DynamicList
			bevy_reflect::DynamicArray : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A list of reflected values.
			bevy_reflect::DynamicList : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///An ordered mapping between reflected values.
			bevy_reflect::DynamicMap : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A struct type which allows fields to be added at runtime.
			bevy_reflect::DynamicStruct : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A tuple which allows fields to be added at runtime.
			bevy_reflect::DynamicTuple : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A tuple struct which allows fields to be added at runtime.
			bevy_reflect::DynamicTupleStruct : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Lightweight identifier of an [entity](crate::entity).
			///
			///The identifier is implemented using a [generational index]: a combination of an ID and a generation.
			///This allows fast insertion after data removal in an array while minimizing loss of spatial locality.
			///
			///[generational index]: https://lucassardois.medium.com/generational-indices-guide-8e3c5f7fd594
			///
			///# Usage
			///
			///This data type is returned by iterating a `Query` that has `Entity` as part of its query fetch type parameter ([learn more]).
			///It can also be obtained by calling [`EntityCommands::id`] or [`EntityMut::id`].
			///
			///```
			///# use bevy_ecs::prelude::*;
			///#
			///fn setup(mut commands: Commands) {
			///    // Calling `spawn` returns `EntityCommands`.
			///    let entity = commands.spawn().id();
			///}
			///
			///fn exclusive_system(world: &mut World) {
			///    // Calling `spawn` returns `EntityMut`.
			///    let entity = world.spawn().id();
			///}
			///#
			///# bevy_ecs::system::assert_is_system(setup);
			///# bevy_ecs::system::IntoExclusiveSystem::exclusive_system(exclusive_system);
			///```
			///
			///It can be used to refer to a specific entity to apply [`EntityCommands`], or to call [`Query::get`] (or similar methods) to access its components.
			///
			///```
			///# use bevy_ecs::prelude::*;
			///#
			///# #[derive(Component)]
			///# struct Expired;
			///#
			///fn dispose_expired_food(mut commands: Commands, query: Query<Entity, With<Expired>>) {
			///    for food_entity in query.iter() {
			///        commands.entity(food_entity).despawn();
			///    }
			///}
			///#
			///# bevy_ecs::system::assert_is_system(dispose_expired_food);
			///```
			///
			///[learn more]: crate::system::Query#entity-id-access
			///[`EntityCommands::id`]: crate::system::EntityCommands::id
			///[`EntityMut::id`]: crate::world::EntityMut::id
			///[`EntityCommands`]: crate::system::EntityCommands
			///[`Query::get`]: crate::system::Query::get
			bevy_ecs::entity::Entity : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Creates a new entity reference with the specified `id` and a generation of 0.
				///
				///# Note
				///
				///Spawning a specific `entity` value is __rarely the right choice__. Most apps should favor
				///[`Commands::spawn`](crate::system::Commands::spawn). This method should generally
				///only be used for sharing entities across apps, and only when they have a scheme
				///worked out to share an ID space (which doesn't happen by default).
				///
				///In general, one should not try to synchronize the ECS by attempting to ensure that
				///`Entity` lines up between instances, but instead insert a secondary identifier as
				///a component.
				///
				///There are still some use cases where it might be appropriate to use this function
				///externally.
				///
				///## Examples
				///
				///Initializing a collection (e.g. `array` or `Vec`) with a known size:
				///
				///```no_run
				///# use bevy_ecs::prelude::*;
				///// Create a new array of size 10 and initialize it with (invalid) entities.
				///let mut entities: [Entity; 10] = [Entity::from_raw(0); 10];
				///
				///// ... replace the entities with valid ones.
				///```
				///
				///Deriving `Reflect` for a component that has an `Entity` field:
				///
				///```no_run
				///# use bevy_ecs::{prelude::*, component::*};
				///# use bevy_reflect::Reflect;
				///#[derive(Reflect, Component)]
				///#[reflect(Component)]
				///pub struct MyStruct {
				///    pub entity: Entity,
				///}
				///
				///impl FromWorld for MyStruct {
				///    fn from_world(_world: &mut World) -> Self {
				///        Self {
				///            entity: Entity::from_raw(u32::MAX),
				///        }
				///    }
				///}
				///```
				from_raw(u32) -> LuaEntity,

				///Convert to a form convenient for passing outside of rust.
				///
				///Only useful for identifying entities within the same instance of an application. Do not use
				///for serialization between runs.
				///
				///No particular structure is guaranteed for the returned bits.
				to_bits(self) -> u64,

				///Reconstruct an `Entity` previously destructured with [`Entity::to_bits`].
				///
				///Only useful when applied to results from `to_bits` in the same instance of an application.
				from_bits(u64) -> LuaEntity,

				///Return a transiently unique identifier.
				///
				///No two simultaneously-live entities share the same ID, but dead entities' IDs may collide
				///with both live and dead entities. Useful for compactly representing entities within a
				///specific snapshot of the world, such as when serializing.
				id(self) -> u32,

				///Returns the generation of this Entity's id. The generation is incremented each time an
				///entity with a given id is despawned. This serves as a "count" of the number of times a
				///given id has been reused (id, generation) pairs uniquely identify a given Entity.
				generation(self) -> u32,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describe the position of an entity. If the entity has a parent, the position is relative
			///to its parent position.
			///
			///* To place or move an entity, you should set its [`Transform`].
			///* To get the global position of an entity, you should get its [`GlobalTransform`].
			///* To be displayed, an entity must have both a [`Transform`] and a [`GlobalTransform`].
			///  * You may use the [`TransformBundle`](crate::TransformBundle) to guarantee this.
			///
			///## [`Transform`] and [`GlobalTransform`]
			///
			///[`Transform`] is the position of an entity relative to its parent position, or the reference
			///frame if it doesn't have a [`Parent`](bevy_hierarchy::Parent).
			///
			///[`GlobalTransform`] is the position of an entity relative to the reference frame.
			///
			///[`GlobalTransform`] is updated from [`Transform`] in the system
			///[`transform_propagate_system`](crate::transform_propagate_system).
			///
			///This system runs in stage [`CoreStage::PostUpdate`](crate::CoreStage::PostUpdate). If you
			///update the[`Transform`] of an entity in this stage or after, you will notice a 1 frame lag
			///before the [`GlobalTransform`] is updated.
			bevy_transform::components::Transform : Value
			: Fields
			(
				/// Position of the entity. In 2d, the last value of the `Vec3` is used for z-ordering.
				translation: LuaVec3,
				/// Rotation of the entity.
				rotation: LuaQuat,
				/// Scale of the entity.
				scale: LuaVec3,
			)
			+ AutoMethods
			(
				///Creates a new [`Transform`] at the position `(x, y, z)`. In 2d, the `z` component
				///is used for z-ordering elements: higher `z`-value will be in front of lower
				///`z`-value.
				from_xyz(f32,f32,f32) -> LuaTransform,

				///Creates a new identity [`Transform`], with no translation, rotation, and a scale of 1 on
				///all axes.
				identity() -> LuaTransform,

				///Extracts the translation, rotation, and scale from `matrix`. It must be a 3d affine
				///transformation matrix.
				from_matrix(LuaMat4) -> LuaTransform,

				///Creates a new [`Transform`], with `translation`. Rotation will be 0 and scale 1 on
				///all axes.
				from_translation(LuaVec3) -> LuaTransform,

				///Creates a new [`Transform`], with `rotation`. Translation will be 0 and scale 1 on
				///all axes.
				from_rotation(LuaQuat) -> LuaTransform,

				///Creates a new [`Transform`], with `scale`. Translation will be 0 and rotation 0 on
				///all axes.
				from_scale(LuaVec3) -> LuaTransform,

				///Updates and returns this [`Transform`] by rotating it so that its unit vector in the
				///local z direction is toward `target` and its unit vector in the local y direction
				///is toward `up`.
				looking_at(self,LuaVec3,LuaVec3) -> LuaTransform,

				///Returns this [`Transform`] with a new translation.
				with_translation(self,LuaVec3) -> LuaTransform,

				///Returns this [`Transform`] with a new rotation.
				with_rotation(self,LuaQuat) -> LuaTransform,

				///Returns this [`Transform`] with a new scale.
				with_scale(self,LuaVec3) -> LuaTransform,

				///Returns the 3d affine transformation matrix from this transforms translation,
				///rotation, and scale.
				compute_matrix(&self) -> LuaMat4,

				///Get the unit vector in the local x direction.
				local_x(&self) -> LuaVec3,

				///Equivalent to [`-local_x()`][Transform::local_x()]
				left(&self) -> LuaVec3,

				///Equivalent to [`local_x()`][Transform::local_x()]
				right(&self) -> LuaVec3,

				///Get the unit vector in the local y direction.
				local_y(&self) -> LuaVec3,

				///Equivalent to [`local_y()`][Transform::local_y]
				up(&self) -> LuaVec3,

				///Equivalent to [`-local_y()`][Transform::local_y]
				down(&self) -> LuaVec3,

				///Get the unit vector in the local z direction.
				local_z(&self) -> LuaVec3,

				///Equivalent to [`-local_z()`][Transform::local_z]
				forward(&self) -> LuaVec3,

				///Equivalent to [`local_z()`][Transform::local_z]
				back(&self) -> LuaVec3,

				///Multiplies `self` with `transform` component by component, returning the
				///resulting [`Transform`]
				mul_transform(&self,LuaTransform) -> LuaTransform,

				///Returns a [`Vec3`] of this [`Transform`] applied to `value`.
				mul_vec3(&self,LuaVec3) -> LuaVec3,

			)
			+ BinOps
			(
				self Mul LuaTransform -> LuaTransform,
				self Mul LuaVec3 -> LuaVec3,
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describe the position of an entity relative to the reference frame.
			///
			///* To place or move an entity, you should set its [`Transform`].
			///* To get the global position of an entity, you should get its [`GlobalTransform`].
			///* For transform hierarchies to work correctly, you must have both a [`Transform`] and a [`GlobalTransform`].
			///  * You may use the [`TransformBundle`](crate::TransformBundle) to guarantee this.
			///
			///## [`Transform`] and [`GlobalTransform`]
			///
			///[`Transform`] is the position of an entity relative to its parent position, or the reference
			///frame if it doesn't have a [`Parent`](bevy_hierarchy::Parent).
			///
			///[`GlobalTransform`] is the position of an entity relative to the reference frame.
			///
			///[`GlobalTransform`] is updated from [`Transform`] in the system
			///[`transform_propagate_system`](crate::transform_propagate_system).
			///
			///This system runs in stage [`CoreStage::PostUpdate`](crate::CoreStage::PostUpdate). If you
			///update the[`Transform`] of an entity in this stage or after, you will notice a 1 frame lag
			///before the [`GlobalTransform`] is updated.
			bevy_transform::components::GlobalTransform : Value
			: Fields
			(
				/// The position of the global transform
				translation: LuaVec3,
				/// The rotation of the global transform
				rotation: LuaQuat,
				/// The scale of the global transform
				scale: LuaVec3,
			)
			+ AutoMethods
			(
				///Creates a new identity [`GlobalTransform`], with no translation, rotation, and a scale of 1
				///on all axes.
				identity() -> LuaGlobalTransform,

				///Returns the 3d affine transformation matrix from this transforms translation,
				///rotation, and scale.
				compute_matrix(&self) -> LuaMat4,

				///Returns the 3d affine transformation from this transforms translation,
				///rotation, and scale.
				compute_affine(&self) -> LuaAffine3A,

				///Get the unit vector in the local x direction
				local_x(&self) -> LuaVec3,

				///Equivalent to [`-local_x()`][GlobalTransform::local_x]
				left(&self) -> LuaVec3,

				///Equivalent to [`local_x()`][GlobalTransform::local_x]
				right(&self) -> LuaVec3,

				///Get the unit vector in the local y direction
				local_y(&self) -> LuaVec3,

				///Equivalent to [`local_y()`][GlobalTransform::local_y]
				up(&self) -> LuaVec3,

				///Equivalent to [`-local_y()`][GlobalTransform::local_y]
				down(&self) -> LuaVec3,

				///Get the unit vector in the local z direction
				local_z(&self) -> LuaVec3,

				///Equivalent to [`-local_z()`][GlobalTransform::local_z]
				forward(&self) -> LuaVec3,

				///Equivalent to [`local_z()`][GlobalTransform::local_z]
				back(&self) -> LuaVec3,

				///Multiplies `self` with `transform` component by component, returning the
				///resulting [`GlobalTransform`]
				mul_transform(&self,LuaTransform) -> LuaGlobalTransform,

				///Returns a [`Vec3`] of this [`Transform`] applied to `value`.
				mul_vec3(&self,LuaVec3) -> LuaVec3,

			)
			+ BinOps
			(
				self Mul LuaGlobalTransform -> LuaGlobalTransform,
				self Mul LuaTransform -> LuaGlobalTransform,
				self Mul LuaVec3 -> LuaVec3,
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///An ambient light, which lights the entire scene equally.
			bevy_pbr::AmbientLight : Value
			: Fields
			(
				color: LuaColor,
				/// A direct scale factor multiplied with `color` before being passed to the shader.
				brightness: f32,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_pbr::CubemapVisibleEntities : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A Directional light.
			///
			///Directional lights don't exist in reality but they are a good
			///approximation for light sources VERY far away, like the sun or
			///the moon.
			///
			///Valid values for `illuminance` are:
			///
			///| Illuminance (lux) | Surfaces illuminated by                        |
			///|-------------------|------------------------------------------------|
			///| 0.0001            | Moonless, overcast night sky (starlight)       |
			///| 0.002             | Moonless clear night sky with airglow          |
			///| 0.05–0.3          | Full moon on a clear night                     |
			///| 3.4               | Dark limit of civil twilight under a clear sky |
			///| 20–50             | Public areas with dark surroundings            |
			///| 50                | Family living room lights                      |
			///| 80                | Office building hallway/toilet lighting        |
			///| 100               | Very dark overcast day                         |
			///| 150               | Train station platforms                        |
			///| 320–500           | Office lighting                                |
			///| 400               | Sunrise or sunset on a clear day.              |
			///| 1000              | Overcast day; typical TV studio lighting       |
			///| 10,000–25,000     | Full daylight (not direct sun)                 |
			///| 32,000–100,000    | Direct sunlight                                |
			///
			///Source: [Wikipedia](https://en.wikipedia.org/wiki/Lux)
			bevy_pbr::DirectionalLight : Value
			: Fields
			(
				color: LuaColor,
				/// Illuminance in lux
				illuminance: f32,
				shadows_enabled: bool,
				shadow_projection: LuaOrthographicProjection,
				shadow_depth_bias: f32,
				/// A bias applied along the direction of the fragment's surface normal. It is scaled to the
				/// shadow map's texel size so that it is automatically adjusted to the orthographic projection.
				shadow_normal_bias: f32,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_pbr::DirectionalLightShadowMap : Value
			: Fields
			(
				size: usize,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not cast shadows.
			bevy_pbr::NotShadowCaster : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not receive shadows.
			bevy_pbr::NotShadowReceiver : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A light that emits light in all directions from a central point.
			///
			///Real-world values for `intensity` (luminous power in lumens) based on the electrical power
			///consumption of the type of real-world light are:
			///
			///| Luminous Power (lumen) (i.e. the intensity member) | Incandescent non-halogen (Watts) | Incandescent halogen (Watts) | Compact fluorescent (Watts) | LED (Watts |
			///|------|-----|----|--------|-------|
			///| 200  | 25  |    | 3-5    | 3     |
			///| 450  | 40  | 29 | 9-11   | 5-8   |
			///| 800  | 60  |    | 13-15  | 8-12  |
			///| 1100 | 75  | 53 | 18-20  | 10-16 |
			///| 1600 | 100 | 72 | 24-28  | 14-17 |
			///| 2400 | 150 |    | 30-52  | 24-30 |
			///| 3100 | 200 |    | 49-75  | 32    |
			///| 4000 | 300 |    | 75-100 | 40.5  |
			///
			///Source: [Wikipedia](https://en.wikipedia.org/wiki/Lumen_(unit)#Lighting)
			bevy_pbr::PointLight : Value
			: Fields
			(
				color: LuaColor,
				intensity: f32,
				range: f32,
				radius: f32,
				shadows_enabled: bool,
				shadow_depth_bias: f32,
				/// A bias applied along the direction of the fragment's surface normal. It is scaled to the
				/// shadow map's texel size so that it can be small close to the camera and gets larger further
				/// away.
				shadow_normal_bias: f32,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_pbr::PointLightShadowMap : Value
			: Fields
			(
				size: usize,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Alpha mode
			bevy_pbr::AlphaMode : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Controls whether an entity should rendered in wireframe-mode if the [`WireframePlugin`] is enabled
			bevy_pbr::wireframe::Wireframe : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_pbr::wireframe::WireframeConfig : Value
			: Fields
			(
				/// Whether to show wireframes for all meshes. If `false`, only meshes with a [Wireframe] component will be rendered.
				global: bool,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The depth clear operation to perform for the main 3d pass.
			bevy_core_pipeline::core_3d::Camera3dDepthLoadOp : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///When used as a resource, sets the color that is used to clear the screen between frames.
			///
			///This color appears as the "background" color for simple apps, when
			///there are portions of the screen with nothing rendered.
			bevy_core_pipeline::clear_color::ClearColor : Value
			: Fields
			(
				0: LuaColor,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_core_pipeline::clear_color::ClearColorConfig : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_core_pipeline::core_2d::Camera2d : Value
			: Fields
			(
				clear_color: LuaClearColorConfig,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Configuration for the "main 3d render graph".
			bevy_core_pipeline::core_3d::Camera3d : Value
			: Fields
			(
				/// The clear color operation to perform for the main 3d pass.
				clear_color: LuaClearColorConfig,
				/// The depth clear operation to perform for the main 3d pass.
				depth_load_op: LuaCamera3dDepthLoadOp,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///How a sprite is positioned relative to its [`Transform`](bevy_transform::components::Transform).
			///It defaults to `Anchor::Center`.
			bevy_sprite::Anchor : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				as_vec(&self) -> LuaVec2,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Component for rendering with meshes in the 2d pipeline, usually with a [2d material](crate::Material2d) such as [`ColorMaterial`](crate::ColorMaterial).
			///
			///It wraps a [`Handle<Mesh>`] to differentiate from the 3d pipelines which use the handles directly as components
			bevy_sprite::Mesh2dHandle : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_sprite::TextureAtlasSprite : Value
			: Fields
			(
				color: LuaColor,
				index: usize,
				flip_x: bool,
				flip_y: bool,
				anchor: LuaAnchor,
			)
			+ AutoMethods
			(
				new(usize) -> LuaTextureAtlasSprite,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_sprite::Sprite : Value
			: Fields
			(
				/// The sprite's color tint
				color: LuaColor,
				/// Flip the sprite along the X axis
				flip_x: bool,
				/// Flip the sprite along the Y axis
				flip_y: bool,
				/// [`Anchor`] point of the sprite in the world
				anchor: LuaAnchor,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A rectangle defined by two points. There is no defined origin, so 0,0 could be anywhere
			///(top-left, bottom-left, etc)
			bevy_sprite::Rect : Value
			: Fields
			(
				/// The beginning point of the rect
				min: LuaVec2,
				/// The ending point of the rect
				max: LuaVec2,
			)
			+ AutoMethods
			(
				width(&self) -> f32,

				height(&self) -> f32,

				size(&self) -> LuaVec2,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Describes which rendering layers an entity belongs to.
			///
			///Cameras with this component will only render entities with intersecting
			///layers.
			///
			///There are 32 layers numbered `0` - [`TOTAL_LAYERS`](RenderLayers::TOTAL_LAYERS). Entities may
			///belong to one or more layers, or no layer at all.
			///
			///The [`Default`] instance of `RenderLayers` contains layer `0`, the first layer.
			///
			///An entity with this component without any layers is invisible.
			///
			///Entities without this component belong to layer `0`.
			bevy_render::view::visibility::RenderLayers : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Create a new `RenderLayers` that belongs to all layers.
				all() -> LuaRenderLayers,

				///Create a new `RenderLayers` that belongs to no layers.
				none() -> LuaRenderLayers,

				///Determine if a `RenderLayers` intersects another.
				///
				///`RenderLayers`s intersect if they share any common layers.
				///
				///A `RenderLayers` with no layers will not match any other
				///`RenderLayers`, even another with no layers.
				intersects(&self,&LuaRenderLayers) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///User indication of whether an entity is visible
			bevy_render::view::visibility::Visibility : Value
			: Fields
			(
				is_visible: bool,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Collection of entities visible from the current view.
			///
			///This component contains all entities which are visible from the currently
			///rendered view. The collection is updated automatically by the [`check_visibility()`]
			///system, and renderers can use it to optimize rendering of a particular view, to
			///prevent drawing items not visible from that view.
			///
			///This component is intended to be attached to the same entity as the [`Camera`] and
			///the [`Frustum`] defining the view.
			///
			///Currently this component is ignored by the sprite renderer, so sprite rendering
			///is not optimized per view.
			bevy_render::view::visibility::VisibleEntities : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				len(&self) -> usize,

				is_empty(&self) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Algorithmically-computed indication of whether an entity is visible and should be extracted for rendering
			bevy_render::view::visibility::ComputedVisibility : Value
			: Fields
			(
				is_visible: bool,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::mesh::skinning::SkinnedMesh : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::camera::ScalingMode : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::camera::WindowOrigin : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::color::Color : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///New `Color` from sRGB colorspace.
				rgb(f32,f32,f32) -> LuaColor,

				///New `Color` from sRGB colorspace.
				rgba(f32,f32,f32,f32) -> LuaColor,

				///New `Color` from linear RGB colorspace.
				rgb_linear(f32,f32,f32) -> LuaColor,

				///New `Color` from linear RGB colorspace.
				rgba_linear(f32,f32,f32,f32) -> LuaColor,

				///New `Color` with HSL representation in sRGB colorspace.
				hsl(f32,f32,f32) -> LuaColor,

				///New `Color` with HSL representation in sRGB colorspace.
				hsla(f32,f32,f32,f32) -> LuaColor,

				///New `Color` from sRGB colorspace.
				rgb_u8(u8,u8,u8) -> LuaColor,

				///New `Color` from sRGB colorspace.
				rgba_u8(u8,u8,u8,u8) -> LuaColor,

				///Get red in sRGB colorspace.
				r(&self) -> f32,

				///Get green in sRGB colorspace.
				g(&self) -> f32,

				///Get blue in sRGB colorspace.
				b(&self) -> f32,

				///Get alpha.
				a(&self) -> f32,

				///Converts a `Color` to variant `Color::Rgba`
				as_rgba(&LuaColor) -> LuaColor,

				///Converts a `Color` to variant `Color::RgbaLinear`
				as_rgba_linear(&LuaColor) -> LuaColor,

				///Converts a `Color` to variant `Color::Hsla`
				as_hsla(&LuaColor) -> LuaColor,

				///Converts Color to a u32 from sRGB colorspace.
				///
				///Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
				///A will be the most significant byte and R the least significant.
				as_rgba_u32(LuaColor) -> u32,

				///Converts Color to a u32 from linear RGB colorspace.
				///
				///Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
				///A will be the most significant byte and R the least significant.
				as_linear_rgba_u32(LuaColor) -> u32,

			)
			+ BinOps
			(
				self Add LuaColor -> LuaColor,
				self Add LuaVec4 -> LuaColor,
				self Mul f32 -> LuaColor,
				self Mul LuaVec4 -> LuaColor,
				self Mul LuaVec3 -> LuaColor,
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///An Axis-Aligned Bounding Box
			bevy_render::primitives::Aabb : Value
			: Fields
			(
				center: LuaVec3A,
				half_extents: LuaVec3A,
			)
			+ AutoMethods
			(
				from_min_max(LuaVec3,LuaVec3) -> LuaAabb,

				min(&self) -> LuaVec3A,

				max(&self) -> LuaVec3A,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::primitives::CubemapFrusta : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A frustum defined by the 6 containing planes
			///Planes are ordered left, right, top, bottom, near, far
			///Normals point into the contained volume
			bevy_render::primitives::Frustum : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				from_view_projection(&LuaMat4,&LuaVec3,&LuaVec3,f32) -> LuaFrustum,

				intersects_obb(&self,&LuaAabb,&LuaMat4,bool) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Configuration resource for [Multi-Sample Anti-Aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing).
			///
			///# Example
			///```
			///# use bevy_app::prelude::App;
			///# use bevy_render::prelude::Msaa;
			///App::new()
			///    .insert_resource(Msaa { samples: 4 })
			///    .run();
			///```
			bevy_render::view::Msaa : Value
			: Fields
			(
				/// The number of samples to run for Multi-Sample Anti-Aliasing. Higher numbers result in
				/// smoother edges.
				/// Defaults to 4.
				/// 
				/// Note that WGPU currently only supports 1 or 4 samples.
				/// Ultimately we plan on supporting whatever is natively supported on a given device.
				/// Check out this issue for more info: <https://github.com/gfx-rs/wgpu/issues/1832>
				samples: u32,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::camera::Camera : Value
			: Fields
			(
				/// Cameras with a lower priority will be rendered before cameras with a higher priority.
				priority: isize,
				/// If this is set to true, this camera will be rendered to its specified [`RenderTarget`]. If false, this
				/// camera will not be rendered.
				is_active: bool,
				/// The method used to calculate this camera's depth. This will be used for projections and visibility.
				depth_calculation: LuaDepthCalculation,
				/// The "target" that this camera will render to.
				target: LuaRenderTarget,
			)
			+ AutoMethods
			(
				///The projection matrix computed using this camera's [`CameraProjection`].
				projection_matrix(&self) -> LuaMat4,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///The "target" that a [`Camera`] will render to. For example, this could be a [`Window`](bevy_window::Window)
			///swapchain or an [`Image`].
			bevy_render::camera::RenderTarget : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Render viewport configuration for the [`Camera`] component.
			///
			///The viewport defines the area on the render target to which the camera renders its image.
			///You can overlay multiple cameras in a single window using viewports to create effects like
			///split screen, minimaps, and character viewers.
			bevy_render::camera::Viewport : Value
			: Fields
			(
				/// The physical position to render this viewport to within the [`RenderTarget`] of this [`Camera`].
				/// (0,0) corresponds to the top-left corner
				physical_position: LuaUVec2,
				/// The physical size of the viewport rectangle to render to within the [`RenderTarget`] of this [`Camera`].
				/// The origin of the rectangle is in the top-left corner.
				physical_size: LuaUVec2,
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A configurable [`CameraProjection`] that can select its projection type at runtime.
			bevy_render::camera::Projection : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				get_projection_matrix(&self) -> LuaMat4,

				depth_calculation(&self) -> LuaDepthCalculation,

				far(&self) -> f32,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::camera::OrthographicProjection : Value
			: Fields
			(
				left: f32,
				right: f32,
				bottom: f32,
				top: f32,
				near: f32,
				far: f32,
				window_origin: LuaWindowOrigin,
				scaling_mode: LuaScalingMode,
				scale: f32,
				depth_calculation: LuaDepthCalculation,
			)
			+ AutoMethods
			(
				get_projection_matrix(&self) -> LuaMat4,

				depth_calculation(&self) -> LuaDepthCalculation,

				far(&self) -> f32,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::camera::PerspectiveProjection : Value
			: Fields
			(
				fov: f32,
				aspect_ratio: f32,
				near: f32,
				far: f32,
			)
			+ AutoMethods
			(
				get_projection_matrix(&self) -> LuaMat4,

				depth_calculation(&self) -> LuaDepthCalculation,

				far(&self) -> f32,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_render::camera::DepthCalculation : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///Configures the [`RenderGraph`](crate::render_graph::RenderGraph) name assigned to be run for a given [`Camera`] entity.
			bevy_render::camera::CameraRenderGraph : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_asset::AssetPathId : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				source_path_id(&self) -> LuaSourcePathId,

				label_id(&self) -> LuaLabelId,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_asset::LabelId : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			bevy_asset::SourcePathId : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A unique, stable asset id
			bevy_asset::HandleId : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 2-dimensional vector.
			glam::f32::vec2::Vec2 : Value
			: Fields
			(
				x: f32,
				y: f32,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(f32,f32) -> LuaVec2,

				///Creates a vector with all elements set to `v`.
				splat(f32) -> LuaVec2,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec2,LuaVec2,LuaVec2) -> LuaVec2,

				///Creates a 3D vector from `self` and the given `z` value.
				extend(self,f32) -> LuaVec3,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaVec2) -> f32,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaVec2) -> LuaVec2,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaVec2) -> LuaVec2,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaVec2,LuaVec2) -> LuaVec2,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> f32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> f32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaVec2) -> LuaBVec2,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaVec2,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaVec2,

				///Returns `true` if, and only if, all elements are finite.  If any element is either
				///`NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(self) -> bool,

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self) -> LuaBVec2,

				///Computes the length of `self`.
				length(self) -> f32,

				///Computes the squared length of `self`.
				///
				///This is faster than `length()` as it avoids a square root operation.
				length_squared(self) -> f32,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f32,

				///Computes the Euclidean distance between two points in space.
				distance(self,LuaVec2) -> f32,

				///Compute the squared euclidean distance between two points in space.
				distance_squared(self,LuaVec2) -> f32,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				///
				///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaVec2,

				///Returns `self` normalized to length 1.0 if possible, else returns zero.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be zero.
				///
				///See also [`Self::try_normalize`].
				normalize_or_zero(self) -> LuaVec2,

				///Returns whether `self` is length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				project_onto(self,LuaVec2) -> LuaVec2,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				reject_from(self,LuaVec2) -> LuaVec2,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				project_onto_normalized(self,LuaVec2) -> LuaVec2,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				reject_from_normalized(self,LuaVec2) -> LuaVec2,

				///Returns a vector containing the nearest integer to a number for each element of `self`.
				///Round half-way cases away from 0.0.
				round(self) -> LuaVec2,

				///Returns a vector containing the largest integer less than or equal to a number for each
				///element of `self`.
				floor(self) -> LuaVec2,

				///Returns a vector containing the smallest integer greater than or equal to a number for
				///each element of `self`.
				ceil(self) -> LuaVec2,

				///Returns a vector containing the fractional part of the vector, e.g. `self -
				///self.floor()`.
				///
				///Note that this is fast but not precise for large numbers.
				fract(self) -> LuaVec2,

				///Returns a vector containing `e^self` (the exponential function) for each element of
				///`self`.
				exp(self) -> LuaVec2,

				///Returns a vector containing each element of `self` raised to the power of `n`.
				powf(self,f32) -> LuaVec2,

				///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				recip(self) -> LuaVec2,

				///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				///extrapolated.
				lerp(self,LuaVec2,f32) -> LuaVec2,

				///Returns true if the absolute difference of all elements between `self` and `rhs` is
				///less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two vectors contain similar elements. It works best when
				///comparing with a known value. The `max_abs_diff` that should be used used depends on
				///the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaVec2,f32) -> bool,

				///Returns a vector with a length no less than `min` and no more than `max`
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp_length(self,f32,f32) -> LuaVec2,

				///Returns a vector with a length no more than `max`
				clamp_length_max(self,f32) -> LuaVec2,

				///Returns a vector with a length no less than `min`
				clamp_length_min(self,f32) -> LuaVec2,

				///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				///error, yielding a more accurate result than an unfused multiply-add.
				///
				///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				///architecture has a dedicated fma CPU instruction. However, this is not always true,
				///and will be heavily dependant on designing algorithms with specific target hardware in
				///mind.
				mul_add(self,LuaVec2,LuaVec2) -> LuaVec2,

				///Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
				///conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will
				///create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.
				from_angle(f32) -> LuaVec2,

				///Returns the angle (in radians) between `self` and `rhs`.
				///
				///The input vectors do not need to be unit length however they must be non-zero.
				angle_between(self,LuaVec2) -> f32,

				///Returns a vector that is equal to `self` rotated by 90 degrees.
				perp(self) -> LuaVec2,

				///The perpendicular dot product of `self` and `rhs`.
				///Also known as the wedge product, 2D cross product, and determinant.
				perp_dot(self,LuaVec2) -> f32,

				///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
				///then this just rotation. This is what you usually want. Otherwise,
				///it will be like a rotation with a multiplication by `self`'s length.
				rotate(self,LuaVec2) -> LuaVec2,

			)
			+ BinOps
			(
				self Add LuaVec2 -> LuaVec2,
				self Add f32 -> LuaVec2,
				f32 Add self -> LuaVec2,
				self Sub LuaVec2 -> LuaVec2,
				self Sub f32 -> LuaVec2,
				f32 Sub self -> LuaVec2,
				self Div LuaVec2 -> LuaVec2,
				self Div f32 -> LuaVec2,
				f32 Div self -> LuaVec2,
				self Mul LuaVec2 -> LuaVec2,
				self Mul f32 -> LuaVec2,
				f32 Mul self -> LuaVec2,
				self Rem LuaVec2 -> LuaVec2,
				self Rem f32 -> LuaVec2,
				f32 Rem self -> LuaVec2,
			)
			+ UnaryOps
			(
				Neg self
			)
			impl
			{
				(MetaMethod::Index) (s=LuaVec2)=> {|_,s,idx: usize| {Ok(s.clone()[idx])}};
				mut (MetaMethod::NewIndex) (n=f32) => {|_,s,(idx,val): (usize,($n))| {Ok(s.val_mut(|s| s[idx] = val))}};
			}
		}
,		{
			///A 3-dimensional vector.
			glam::f32::vec3::Vec3 : Value
			: Fields
			(
				x: f32,
				y: f32,
				z: f32,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(f32,f32,f32) -> LuaVec3,

				///Creates a vector with all elements set to `v`.
				splat(f32) -> LuaVec3,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec3,LuaVec3,LuaVec3) -> LuaVec3,

				///Creates a 4D vector from `self` and the given `w` value.
				extend(self,f32) -> LuaVec4,

				///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				///
				///Truncation may also be performed by using `self.xy()` or `Vec2::from()`.
				truncate(self) -> LuaVec2,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaVec3) -> f32,

				///Computes the cross product of `self` and `rhs`.
				cross(self,LuaVec3) -> LuaVec3,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaVec3) -> LuaVec3,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaVec3) -> LuaVec3,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaVec3,LuaVec3) -> LuaVec3,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> f32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> f32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaVec3) -> LuaBVec3,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaVec3,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaVec3,

				///Returns `true` if, and only if, all elements are finite.  If any element is either
				///`NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(self) -> bool,

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self) -> LuaBVec3,

				///Computes the length of `self`.
				length(self) -> f32,

				///Computes the squared length of `self`.
				///
				///This is faster than `length()` as it avoids a square root operation.
				length_squared(self) -> f32,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f32,

				///Computes the Euclidean distance between two points in space.
				distance(self,LuaVec3) -> f32,

				///Compute the squared euclidean distance between two points in space.
				distance_squared(self,LuaVec3) -> f32,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				///
				///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaVec3,

				///Returns `self` normalized to length 1.0 if possible, else returns zero.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be zero.
				///
				///See also [`Self::try_normalize`].
				normalize_or_zero(self) -> LuaVec3,

				///Returns whether `self` is length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				project_onto(self,LuaVec3) -> LuaVec3,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				reject_from(self,LuaVec3) -> LuaVec3,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				project_onto_normalized(self,LuaVec3) -> LuaVec3,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				reject_from_normalized(self,LuaVec3) -> LuaVec3,

				///Returns a vector containing the nearest integer to a number for each element of `self`.
				///Round half-way cases away from 0.0.
				round(self) -> LuaVec3,

				///Returns a vector containing the largest integer less than or equal to a number for each
				///element of `self`.
				floor(self) -> LuaVec3,

				///Returns a vector containing the smallest integer greater than or equal to a number for
				///each element of `self`.
				ceil(self) -> LuaVec3,

				///Returns a vector containing the fractional part of the vector, e.g. `self -
				///self.floor()`.
				///
				///Note that this is fast but not precise for large numbers.
				fract(self) -> LuaVec3,

				///Returns a vector containing `e^self` (the exponential function) for each element of
				///`self`.
				exp(self) -> LuaVec3,

				///Returns a vector containing each element of `self` raised to the power of `n`.
				powf(self,f32) -> LuaVec3,

				///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				recip(self) -> LuaVec3,

				///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				///extrapolated.
				lerp(self,LuaVec3,f32) -> LuaVec3,

				///Returns true if the absolute difference of all elements between `self` and `rhs` is
				///less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two vectors contain similar elements. It works best when
				///comparing with a known value. The `max_abs_diff` that should be used used depends on
				///the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaVec3,f32) -> bool,

				///Returns a vector with a length no less than `min` and no more than `max`
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp_length(self,f32,f32) -> LuaVec3,

				///Returns a vector with a length no more than `max`
				clamp_length_max(self,f32) -> LuaVec3,

				///Returns a vector with a length no less than `min`
				clamp_length_min(self,f32) -> LuaVec3,

				///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				///error, yielding a more accurate result than an unfused multiply-add.
				///
				///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				///architecture has a dedicated fma CPU instruction. However, this is not always true,
				///and will be heavily dependant on designing algorithms with specific target hardware in
				///mind.
				mul_add(self,LuaVec3,LuaVec3) -> LuaVec3,

				///Returns the angle (in radians) between two vectors.
				///
				///The input vectors do not need to be unit length however they must be non-zero.
				angle_between(self,LuaVec3) -> f32,

				///Returns some vector that is orthogonal to the given one.
				///
				///The input vector must be finite and non-zero.
				///
				///The output vector is not necessarily unit-length.
				///For that use [`Self::any_orthonormal_vector`] instead.
				any_orthogonal_vector(&self) -> LuaVec3,

				///Returns any unit-length vector that is orthogonal to the given one.
				///The input vector must be finite and non-zero.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				any_orthonormal_vector(&self) -> LuaVec3,

			)
			+ BinOps
			(
				self Add LuaVec3 -> LuaVec3,
				self Add f32 -> LuaVec3,
				f32 Add self -> LuaVec3,
				self Sub LuaVec3 -> LuaVec3,
				self Sub f32 -> LuaVec3,
				f32 Sub self -> LuaVec3,
				self Div LuaVec3 -> LuaVec3,
				self Div f32 -> LuaVec3,
				f32 Div self -> LuaVec3,
				self Mul LuaVec3 -> LuaVec3,
				self Mul f32 -> LuaVec3,
				f32 Mul self -> LuaVec3,
				self Rem LuaVec3 -> LuaVec3,
				self Rem f32 -> LuaVec3,
				f32 Rem self -> LuaVec3,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaVec3),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f32))
			    
			impl
			{
			}
		}
,		{
			///A 3-dimensional vector with SIMD support.
			///
			///This type is 16 byte aligned. A SIMD vector type is used for storage on supported platforms for
			///better performance than the `Vec3` type.
			///
			///It is possible to convert between `Vec3` and `Vec3A` types using `From` trait implementations.
			glam::f32::sse2::vec3A::Vec3A : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(f32,f32,f32) -> LuaVec3A,

				///Creates a vector with all elements set to `v`.
				splat(f32) -> LuaVec3A,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec3A,LuaVec3A,LuaVec3A) -> LuaVec3A,

				///Creates a 4D vector from `self` and the given `w` value.
				extend(self,f32) -> LuaVec4,

				///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				///
				///Truncation may also be performed by using `self.xy()` or `Vec2::from()`.
				truncate(self) -> LuaVec2,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaVec3A) -> f32,

				///Computes the cross product of `self` and `rhs`.
				cross(self,LuaVec3A) -> LuaVec3A,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaVec3A) -> LuaVec3A,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaVec3A) -> LuaVec3A,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaVec3A,LuaVec3A) -> LuaVec3A,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> f32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> f32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaVec3A) -> LuaBVec3A,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaVec3A) -> LuaBVec3A,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaVec3A) -> LuaBVec3A,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaVec3A) -> LuaBVec3A,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaVec3A) -> LuaBVec3A,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaVec3A) -> LuaBVec3A,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaVec3A,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaVec3A,

				///Returns `true` if, and only if, all elements are finite.  If any element is either
				///`NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(self) -> bool,

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self) -> LuaBVec3A,

				///Computes the length of `self`.
				length(self) -> f32,

				///Computes the squared length of `self`.
				///
				///This is faster than `length()` as it avoids a square root operation.
				length_squared(self) -> f32,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f32,

				///Computes the Euclidean distance between two points in space.
				distance(self,LuaVec3A) -> f32,

				///Compute the squared euclidean distance between two points in space.
				distance_squared(self,LuaVec3A) -> f32,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				///
				///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaVec3A,

				///Returns `self` normalized to length 1.0 if possible, else returns zero.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be zero.
				///
				///See also [`Self::try_normalize`].
				normalize_or_zero(self) -> LuaVec3A,

				///Returns whether `self` is length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				project_onto(self,LuaVec3A) -> LuaVec3A,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				reject_from(self,LuaVec3A) -> LuaVec3A,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				project_onto_normalized(self,LuaVec3A) -> LuaVec3A,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				reject_from_normalized(self,LuaVec3A) -> LuaVec3A,

				///Returns a vector containing the nearest integer to a number for each element of `self`.
				///Round half-way cases away from 0.0.
				round(self) -> LuaVec3A,

				///Returns a vector containing the largest integer less than or equal to a number for each
				///element of `self`.
				floor(self) -> LuaVec3A,

				///Returns a vector containing the smallest integer greater than or equal to a number for
				///each element of `self`.
				ceil(self) -> LuaVec3A,

				///Returns a vector containing the fractional part of the vector, e.g. `self -
				///self.floor()`.
				///
				///Note that this is fast but not precise for large numbers.
				fract(self) -> LuaVec3A,

				///Returns a vector containing `e^self` (the exponential function) for each element of
				///`self`.
				exp(self) -> LuaVec3A,

				///Returns a vector containing each element of `self` raised to the power of `n`.
				powf(self,f32) -> LuaVec3A,

				///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				recip(self) -> LuaVec3A,

				///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				///extrapolated.
				lerp(self,LuaVec3A,f32) -> LuaVec3A,

				///Returns true if the absolute difference of all elements between `self` and `rhs` is
				///less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two vectors contain similar elements. It works best when
				///comparing with a known value. The `max_abs_diff` that should be used used depends on
				///the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaVec3A,f32) -> bool,

				///Returns a vector with a length no less than `min` and no more than `max`
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp_length(self,f32,f32) -> LuaVec3A,

				///Returns a vector with a length no more than `max`
				clamp_length_max(self,f32) -> LuaVec3A,

				///Returns a vector with a length no less than `min`
				clamp_length_min(self,f32) -> LuaVec3A,

				///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				///error, yielding a more accurate result than an unfused multiply-add.
				///
				///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				///architecture has a dedicated fma CPU instruction. However, this is not always true,
				///and will be heavily dependant on designing algorithms with specific target hardware in
				///mind.
				mul_add(self,LuaVec3A,LuaVec3A) -> LuaVec3A,

				///Returns the angle (in radians) between two vectors.
				///
				///The input vectors do not need to be unit length however they must be non-zero.
				angle_between(self,LuaVec3A) -> f32,

				///Returns some vector that is orthogonal to the given one.
				///
				///The input vector must be finite and non-zero.
				///
				///The output vector is not necessarily unit-length.
				///For that use [`Self::any_orthonormal_vector`] instead.
				any_orthogonal_vector(&self) -> LuaVec3A,

				///Returns any unit-length vector that is orthogonal to the given one.
				///The input vector must be finite and non-zero.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				any_orthonormal_vector(&self) -> LuaVec3A,

			)
			+ BinOps
			(
				self Add LuaVec3A -> LuaVec3A,
				self Add f32 -> LuaVec3A,
				f32 Add self -> LuaVec3A,
				self Sub LuaVec3A -> LuaVec3A,
				self Sub f32 -> LuaVec3A,
				f32 Sub self -> LuaVec3A,
				self Div LuaVec3A -> LuaVec3A,
				self Div f32 -> LuaVec3A,
				f32 Div self -> LuaVec3A,
				self Mul LuaVec3A -> LuaVec3A,
				self Mul f32 -> LuaVec3A,
				f32 Mul self -> LuaVec3A,
				self Rem LuaVec3A -> LuaVec3A,
				self Rem f32 -> LuaVec3A,
				f32 Rem self -> LuaVec3A,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaVec3A),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f32))
			    
			impl
			{
			}
		}
,		{
			///A 4-dimensional vector with SIMD support.
			///
			///This type uses 16 byte aligned SIMD vector type for storage.
			glam::f32::sse2::vec4::Vec4 : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(f32,f32,f32,f32) -> LuaVec4,

				///Creates a vector with all elements set to `v`.
				splat(f32) -> LuaVec4,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec4A,LuaVec4,LuaVec4) -> LuaVec4,

				///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
				///
				///Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.
				///
				///To truncate to `Vec3A` use `Vec3A::from()`.
				truncate(self) -> LuaVec3,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaVec4) -> f32,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaVec4) -> LuaVec4,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaVec4) -> LuaVec4,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaVec4,LuaVec4) -> LuaVec4,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> f32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> f32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaVec4) -> LuaBVec4A,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaVec4) -> LuaBVec4A,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaVec4) -> LuaBVec4A,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaVec4) -> LuaBVec4A,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaVec4) -> LuaBVec4A,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaVec4) -> LuaBVec4A,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaVec4,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaVec4,

				///Returns `true` if, and only if, all elements are finite.  If any element is either
				///`NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(self) -> bool,

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self) -> LuaBVec4A,

				///Computes the length of `self`.
				length(self) -> f32,

				///Computes the squared length of `self`.
				///
				///This is faster than `length()` as it avoids a square root operation.
				length_squared(self) -> f32,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f32,

				///Computes the Euclidean distance between two points in space.
				distance(self,LuaVec4) -> f32,

				///Compute the squared euclidean distance between two points in space.
				distance_squared(self,LuaVec4) -> f32,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				///
				///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaVec4,

				///Returns `self` normalized to length 1.0 if possible, else returns zero.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be zero.
				///
				///See also [`Self::try_normalize`].
				normalize_or_zero(self) -> LuaVec4,

				///Returns whether `self` is length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				project_onto(self,LuaVec4) -> LuaVec4,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				reject_from(self,LuaVec4) -> LuaVec4,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				project_onto_normalized(self,LuaVec4) -> LuaVec4,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				reject_from_normalized(self,LuaVec4) -> LuaVec4,

				///Returns a vector containing the nearest integer to a number for each element of `self`.
				///Round half-way cases away from 0.0.
				round(self) -> LuaVec4,

				///Returns a vector containing the largest integer less than or equal to a number for each
				///element of `self`.
				floor(self) -> LuaVec4,

				///Returns a vector containing the smallest integer greater than or equal to a number for
				///each element of `self`.
				ceil(self) -> LuaVec4,

				///Returns a vector containing the fractional part of the vector, e.g. `self -
				///self.floor()`.
				///
				///Note that this is fast but not precise for large numbers.
				fract(self) -> LuaVec4,

				///Returns a vector containing `e^self` (the exponential function) for each element of
				///`self`.
				exp(self) -> LuaVec4,

				///Returns a vector containing each element of `self` raised to the power of `n`.
				powf(self,f32) -> LuaVec4,

				///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				recip(self) -> LuaVec4,

				///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				///extrapolated.
				lerp(self,LuaVec4,f32) -> LuaVec4,

				///Returns true if the absolute difference of all elements between `self` and `rhs` is
				///less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two vectors contain similar elements. It works best when
				///comparing with a known value. The `max_abs_diff` that should be used used depends on
				///the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaVec4,f32) -> bool,

				///Returns a vector with a length no less than `min` and no more than `max`
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp_length(self,f32,f32) -> LuaVec4,

				///Returns a vector with a length no more than `max`
				clamp_length_max(self,f32) -> LuaVec4,

				///Returns a vector with a length no less than `min`
				clamp_length_min(self,f32) -> LuaVec4,

				///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				///error, yielding a more accurate result than an unfused multiply-add.
				///
				///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				///architecture has a dedicated fma CPU instruction. However, this is not always true,
				///and will be heavily dependant on designing algorithms with specific target hardware in
				///mind.
				mul_add(self,LuaVec4,LuaVec4) -> LuaVec4,

			)
			+ BinOps
			(
				self Add LuaVec4 -> LuaVec4,
				self Add f32 -> LuaVec4,
				f32 Add self -> LuaVec4,
				self Sub LuaVec4 -> LuaVec4,
				self Sub f32 -> LuaVec4,
				f32 Sub self -> LuaVec4,
				self Div LuaVec4 -> LuaVec4,
				self Div f32 -> LuaVec4,
				f32 Div self -> LuaVec4,
				self Mul LuaVec4 -> LuaVec4,
				self Mul f32 -> LuaVec4,
				f32 Mul self -> LuaVec4,
				self Rem LuaVec4 -> LuaVec4,
				self Rem f32 -> LuaVec4,
				f32 Rem self -> LuaVec4,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaVec4),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f32))
			    
			impl
			{
			}
		}
,		{
			///A 2-dimensional boolean vector.
			glam::f32::sse2::vec2::BVec2 : Value
			: Fields
			(
				x: bool,
				y: bool,
			)
			+ AutoMethods
			(
				///Creates a new vector mask.
				new(bool,bool) -> LuaBVec2,

				///Returns a bitmask with the lowest two bits set from the elements of `self`.
				///
				///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
				///into the first lowest bit, element `y` into the second, etc.
				bitmask(self) -> u32,

				///Returns true if any of the elements are true, false otherwise.
				any(self) -> bool,

				///Returns true if all the elements are true, false otherwise.
				all(self) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 3-dimensional boolean vector.
			glam::f32::sse2::vec3::BVec3 : Value
			: Fields
			(
				x: bool,
				y: bool,
				z: bool,
			)
			+ AutoMethods
			(
				///Creates a new vector mask.
				new(bool,bool,bool) -> LuaBVec3,

				///Returns a bitmask with the lowest two bits set from the elements of `self`.
				///
				///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
				///into the first lowest bit, element `y` into the second, etc.
				bitmask(self) -> u32,

				///Returns true if any of the elements are true, false otherwise.
				any(self) -> bool,

				///Returns true if all the elements are true, false otherwise.
				all(self) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 4-dimensional boolean vector.
			glam::f32::sse2::vec4::BVec4 : Value
			: Fields
			(
				x: bool,
				y: bool,
				z: bool,
				w: bool,
			)
			+ AutoMethods
			(
				///Creates a new vector mask.
				new(bool,bool,bool,bool) -> LuaBVec4,

				///Returns a bitmask with the lowest two bits set from the elements of `self`.
				///
				///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
				///into the first lowest bit, element `y` into the second, etc.
				bitmask(self) -> u32,

				///Returns true if any of the elements are true, false otherwise.
				any(self) -> bool,

				///Returns true if all the elements are true, false otherwise.
				all(self) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 3-dimensional SIMD vector mask.
			///
			///This type is 16 byte aligned and is backed by a SIMD vector. If SIMD is not available
			///`BVec3A` will be a type alias for `BVec3`.
			glam::f32::sse2::vec3::BVec3A : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Creates a new vector mask.
				new(bool,bool,bool) -> LuaBVec3A,

				///Returns a bitmask with the lowest two bits set from the elements of `self`.
				///
				///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
				///into the first lowest bit, element `y` into the second, etc.
				bitmask(self) -> u32,

				///Returns true if any of the elements are true, false otherwise.
				any(self) -> bool,

				///Returns true if all the elements are true, false otherwise.
				all(self) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 4-dimensional SIMD vector mask.
			///
			///This type is 16 byte aligned and is backed by a SIMD vector. If SIMD is not available
			///`BVec4A` will be a type alias for `BVec4`.
			glam::f32::sse2::vec4::BVec4A : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Creates a new vector mask.
				new(bool,bool,bool,bool) -> LuaBVec4A,

				///Returns a bitmask with the lowest two bits set from the elements of `self`.
				///
				///A true element results in a `1` bit and a false element in a `0` bit.  Element `x` goes
				///into the first lowest bit, element `y` into the second, etc.
				bitmask(self) -> u32,

				///Returns true if any of the elements are true, false otherwise.
				any(self) -> bool,

				///Returns true if all the elements are true, false otherwise.
				all(self) -> bool,

			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 2-dimensional vector.
			glam::f64::dvec2::DVec2 : Value
			: Fields
			(
				x: f64,
				y: f64,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(f64,f64) -> LuaDVec2,

				///Creates a vector with all elements set to `v`.
				splat(f64) -> LuaDVec2,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec2,LuaDVec2,LuaDVec2) -> LuaDVec2,

				///Creates a 3D vector from `self` and the given `z` value.
				extend(self,f64) -> LuaDVec3,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaDVec2) -> f64,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaDVec2) -> LuaDVec2,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaDVec2) -> LuaDVec2,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaDVec2,LuaDVec2) -> LuaDVec2,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> f64,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> f64,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaDVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaDVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaDVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaDVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaDVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaDVec2) -> LuaBVec2,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaDVec2,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaDVec2,

				///Returns `true` if, and only if, all elements are finite.  If any element is either
				///`NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(self) -> bool,

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self) -> LuaBVec2,

				///Computes the length of `self`.
				length(self) -> f64,

				///Computes the squared length of `self`.
				///
				///This is faster than `length()` as it avoids a square root operation.
				length_squared(self) -> f64,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f64,

				///Computes the Euclidean distance between two points in space.
				distance(self,LuaDVec2) -> f64,

				///Compute the squared euclidean distance between two points in space.
				distance_squared(self,LuaDVec2) -> f64,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				///
				///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaDVec2,

				///Returns `self` normalized to length 1.0 if possible, else returns zero.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be zero.
				///
				///See also [`Self::try_normalize`].
				normalize_or_zero(self) -> LuaDVec2,

				///Returns whether `self` is length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				project_onto(self,LuaDVec2) -> LuaDVec2,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				reject_from(self,LuaDVec2) -> LuaDVec2,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				project_onto_normalized(self,LuaDVec2) -> LuaDVec2,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				reject_from_normalized(self,LuaDVec2) -> LuaDVec2,

				///Returns a vector containing the nearest integer to a number for each element of `self`.
				///Round half-way cases away from 0.0.
				round(self) -> LuaDVec2,

				///Returns a vector containing the largest integer less than or equal to a number for each
				///element of `self`.
				floor(self) -> LuaDVec2,

				///Returns a vector containing the smallest integer greater than or equal to a number for
				///each element of `self`.
				ceil(self) -> LuaDVec2,

				///Returns a vector containing the fractional part of the vector, e.g. `self -
				///self.floor()`.
				///
				///Note that this is fast but not precise for large numbers.
				fract(self) -> LuaDVec2,

				///Returns a vector containing `e^self` (the exponential function) for each element of
				///`self`.
				exp(self) -> LuaDVec2,

				///Returns a vector containing each element of `self` raised to the power of `n`.
				powf(self,f64) -> LuaDVec2,

				///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				recip(self) -> LuaDVec2,

				///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				///extrapolated.
				lerp(self,LuaDVec2,f64) -> LuaDVec2,

				///Returns true if the absolute difference of all elements between `self` and `rhs` is
				///less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two vectors contain similar elements. It works best when
				///comparing with a known value. The `max_abs_diff` that should be used used depends on
				///the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaDVec2,f64) -> bool,

				///Returns a vector with a length no less than `min` and no more than `max`
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp_length(self,f64,f64) -> LuaDVec2,

				///Returns a vector with a length no more than `max`
				clamp_length_max(self,f64) -> LuaDVec2,

				///Returns a vector with a length no less than `min`
				clamp_length_min(self,f64) -> LuaDVec2,

				///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				///error, yielding a more accurate result than an unfused multiply-add.
				///
				///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				///architecture has a dedicated fma CPU instruction. However, this is not always true,
				///and will be heavily dependant on designing algorithms with specific target hardware in
				///mind.
				mul_add(self,LuaDVec2,LuaDVec2) -> LuaDVec2,

				///Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in
				///conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will
				///create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.
				from_angle(f64) -> LuaDVec2,

				///Returns the angle (in radians) between `self` and `rhs`.
				///
				///The input vectors do not need to be unit length however they must be non-zero.
				angle_between(self,LuaDVec2) -> f64,

				///Returns a vector that is equal to `self` rotated by 90 degrees.
				perp(self) -> LuaDVec2,

				///The perpendicular dot product of `self` and `rhs`.
				///Also known as the wedge product, 2D cross product, and determinant.
				perp_dot(self,LuaDVec2) -> f64,

				///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
				///then this just rotation. This is what you usually want. Otherwise,
				///it will be like a rotation with a multiplication by `self`'s length.
				rotate(self,LuaDVec2) -> LuaDVec2,

			)
			+ BinOps
			(
				self Add LuaDVec2 -> LuaDVec2,
				self Add f64 -> LuaDVec2,
				f64 Add self -> LuaDVec2,
				self Sub LuaDVec2 -> LuaDVec2,
				self Sub f64 -> LuaDVec2,
				f64 Sub self -> LuaDVec2,
				self Div LuaDVec2 -> LuaDVec2,
				self Div f64 -> LuaDVec2,
				f64 Div self -> LuaDVec2,
				self Mul LuaDVec2 -> LuaDVec2,
				self Mul f64 -> LuaDVec2,
				f64 Mul self -> LuaDVec2,
				self Rem LuaDVec2 -> LuaDVec2,
				self Rem f64 -> LuaDVec2,
				f64 Rem self -> LuaDVec2,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaDVec2),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f64))
			    
			impl
			{
			}
		}
,		{
			///A 3-dimensional vector.
			glam::f64::dvec3::DVec3 : Value
			: Fields
			(
				x: f64,
				y: f64,
				z: f64,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(f64,f64,f64) -> LuaDVec3,

				///Creates a vector with all elements set to `v`.
				splat(f64) -> LuaDVec3,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec3,LuaDVec3,LuaDVec3) -> LuaDVec3,

				///Creates a 4D vector from `self` and the given `w` value.
				extend(self,f64) -> LuaDVec4,

				///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				///
				///Truncation may also be performed by using `self.xy()` or `DVec2::from()`.
				truncate(self) -> LuaDVec2,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaDVec3) -> f64,

				///Computes the cross product of `self` and `rhs`.
				cross(self,LuaDVec3) -> LuaDVec3,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaDVec3) -> LuaDVec3,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaDVec3) -> LuaDVec3,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaDVec3,LuaDVec3) -> LuaDVec3,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> f64,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> f64,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaDVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaDVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaDVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaDVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaDVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaDVec3) -> LuaBVec3,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaDVec3,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaDVec3,

				///Returns `true` if, and only if, all elements are finite.  If any element is either
				///`NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(self) -> bool,

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self) -> LuaBVec3,

				///Computes the length of `self`.
				length(self) -> f64,

				///Computes the squared length of `self`.
				///
				///This is faster than `length()` as it avoids a square root operation.
				length_squared(self) -> f64,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f64,

				///Computes the Euclidean distance between two points in space.
				distance(self,LuaDVec3) -> f64,

				///Compute the squared euclidean distance between two points in space.
				distance_squared(self,LuaDVec3) -> f64,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				///
				///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaDVec3,

				///Returns `self` normalized to length 1.0 if possible, else returns zero.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be zero.
				///
				///See also [`Self::try_normalize`].
				normalize_or_zero(self) -> LuaDVec3,

				///Returns whether `self` is length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				project_onto(self,LuaDVec3) -> LuaDVec3,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				reject_from(self,LuaDVec3) -> LuaDVec3,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				project_onto_normalized(self,LuaDVec3) -> LuaDVec3,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				reject_from_normalized(self,LuaDVec3) -> LuaDVec3,

				///Returns a vector containing the nearest integer to a number for each element of `self`.
				///Round half-way cases away from 0.0.
				round(self) -> LuaDVec3,

				///Returns a vector containing the largest integer less than or equal to a number for each
				///element of `self`.
				floor(self) -> LuaDVec3,

				///Returns a vector containing the smallest integer greater than or equal to a number for
				///each element of `self`.
				ceil(self) -> LuaDVec3,

				///Returns a vector containing the fractional part of the vector, e.g. `self -
				///self.floor()`.
				///
				///Note that this is fast but not precise for large numbers.
				fract(self) -> LuaDVec3,

				///Returns a vector containing `e^self` (the exponential function) for each element of
				///`self`.
				exp(self) -> LuaDVec3,

				///Returns a vector containing each element of `self` raised to the power of `n`.
				powf(self,f64) -> LuaDVec3,

				///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				recip(self) -> LuaDVec3,

				///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				///extrapolated.
				lerp(self,LuaDVec3,f64) -> LuaDVec3,

				///Returns true if the absolute difference of all elements between `self` and `rhs` is
				///less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two vectors contain similar elements. It works best when
				///comparing with a known value. The `max_abs_diff` that should be used used depends on
				///the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaDVec3,f64) -> bool,

				///Returns a vector with a length no less than `min` and no more than `max`
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp_length(self,f64,f64) -> LuaDVec3,

				///Returns a vector with a length no more than `max`
				clamp_length_max(self,f64) -> LuaDVec3,

				///Returns a vector with a length no less than `min`
				clamp_length_min(self,f64) -> LuaDVec3,

				///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				///error, yielding a more accurate result than an unfused multiply-add.
				///
				///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				///architecture has a dedicated fma CPU instruction. However, this is not always true,
				///and will be heavily dependant on designing algorithms with specific target hardware in
				///mind.
				mul_add(self,LuaDVec3,LuaDVec3) -> LuaDVec3,

				///Returns the angle (in radians) between two vectors.
				///
				///The input vectors do not need to be unit length however they must be non-zero.
				angle_between(self,LuaDVec3) -> f64,

				///Returns some vector that is orthogonal to the given one.
				///
				///The input vector must be finite and non-zero.
				///
				///The output vector is not necessarily unit-length.
				///For that use [`Self::any_orthonormal_vector`] instead.
				any_orthogonal_vector(&self) -> LuaDVec3,

				///Returns any unit-length vector that is orthogonal to the given one.
				///The input vector must be finite and non-zero.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				any_orthonormal_vector(&self) -> LuaDVec3,

			)
			+ BinOps
			(
				self Add LuaDVec3 -> LuaDVec3,
				self Add f64 -> LuaDVec3,
				f64 Add self -> LuaDVec3,
				self Sub LuaDVec3 -> LuaDVec3,
				self Sub f64 -> LuaDVec3,
				f64 Sub self -> LuaDVec3,
				self Div LuaDVec3 -> LuaDVec3,
				self Div f64 -> LuaDVec3,
				f64 Div self -> LuaDVec3,
				self Mul LuaDVec3 -> LuaDVec3,
				self Mul f64 -> LuaDVec3,
				f64 Mul self -> LuaDVec3,
				self Rem LuaDVec3 -> LuaDVec3,
				self Rem f64 -> LuaDVec3,
				f64 Rem self -> LuaDVec3,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaDVec3),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f64))
			    
			impl
			{
			}
		}
,		{
			///A 4-dimensional vector.
			glam::f64::dvec4::DVec4 : Value
			: Fields
			(
				x: f64,
				y: f64,
				z: f64,
				w: f64,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(f64,f64,f64,f64) -> LuaDVec4,

				///Creates a vector with all elements set to `v`.
				splat(f64) -> LuaDVec4,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec4,LuaDVec4,LuaDVec4) -> LuaDVec4,

				///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
				///
				///Truncation to `DVec3` may also be performed by using `self.xyz()` or `DVec3::from()`.
				truncate(self) -> LuaDVec3,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaDVec4) -> f64,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaDVec4) -> LuaDVec4,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaDVec4) -> LuaDVec4,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaDVec4,LuaDVec4) -> LuaDVec4,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> f64,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> f64,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaDVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaDVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaDVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaDVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaDVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaDVec4) -> LuaBVec4,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaDVec4,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaDVec4,

				///Returns `true` if, and only if, all elements are finite.  If any element is either
				///`NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(self) -> bool,

				///Performs `is_nan` on each element of self, returning a vector mask of the results.
				///
				///In other words, this computes `[x.is_nan(), y.is_nan(), z.is_nan(), w.is_nan()]`.
				is_nan_mask(self) -> LuaBVec4,

				///Computes the length of `self`.
				length(self) -> f64,

				///Computes the squared length of `self`.
				///
				///This is faster than `length()` as it avoids a square root operation.
				length_squared(self) -> f64,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f64,

				///Computes the Euclidean distance between two points in space.
				distance(self,LuaDVec4) -> f64,

				///Compute the squared euclidean distance between two points in space.
				distance_squared(self,LuaDVec4) -> f64,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero, nor very close to zero.
				///
				///See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaDVec4,

				///Returns `self` normalized to length 1.0 if possible, else returns zero.
				///
				///In particular, if the input is zero (or very close to zero), or non-finite,
				///the result of this operation will be zero.
				///
				///See also [`Self::try_normalize`].
				normalize_or_zero(self) -> LuaDVec4,

				///Returns whether `self` is length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` is zero length when `glam_assert` is enabled.
				project_onto(self,LuaDVec4) -> LuaDVec4,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be of non-zero length.
				///
				///# Panics
				///
				///Will panic if `rhs` has a length of zero when `glam_assert` is enabled.
				reject_from(self,LuaDVec4) -> LuaDVec4,

				///Returns the vector projection of `self` onto `rhs`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				project_onto_normalized(self,LuaDVec4) -> LuaDVec4,

				///Returns the vector rejection of `self` from `rhs`.
				///
				///The vector rejection is the vector perpendicular to the projection of `self` onto
				///`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.
				///
				///`rhs` must be normalized.
				///
				///# Panics
				///
				///Will panic if `rhs` is not normalized when `glam_assert` is enabled.
				reject_from_normalized(self,LuaDVec4) -> LuaDVec4,

				///Returns a vector containing the nearest integer to a number for each element of `self`.
				///Round half-way cases away from 0.0.
				round(self) -> LuaDVec4,

				///Returns a vector containing the largest integer less than or equal to a number for each
				///element of `self`.
				floor(self) -> LuaDVec4,

				///Returns a vector containing the smallest integer greater than or equal to a number for
				///each element of `self`.
				ceil(self) -> LuaDVec4,

				///Returns a vector containing the fractional part of the vector, e.g. `self -
				///self.floor()`.
				///
				///Note that this is fast but not precise for large numbers.
				fract(self) -> LuaDVec4,

				///Returns a vector containing `e^self` (the exponential function) for each element of
				///`self`.
				exp(self) -> LuaDVec4,

				///Returns a vector containing each element of `self` raised to the power of `n`.
				powf(self,f64) -> LuaDVec4,

				///Returns a vector containing the reciprocal `1.0/n` of each element of `self`.
				recip(self) -> LuaDVec4,

				///Performs a linear interpolation between `self` and `rhs` based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result
				///will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly
				///extrapolated.
				lerp(self,LuaDVec4,f64) -> LuaDVec4,

				///Returns true if the absolute difference of all elements between `self` and `rhs` is
				///less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two vectors contain similar elements. It works best when
				///comparing with a known value. The `max_abs_diff` that should be used used depends on
				///the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaDVec4,f64) -> bool,

				///Returns a vector with a length no less than `min` and no more than `max`
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp_length(self,f64,f64) -> LuaDVec4,

				///Returns a vector with a length no more than `max`
				clamp_length_max(self,f64) -> LuaDVec4,

				///Returns a vector with a length no less than `min`
				clamp_length_min(self,f64) -> LuaDVec4,

				///Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding
				///error, yielding a more accurate result than an unfused multiply-add.
				///
				///Using `mul_add` *may* be more performant than an unfused multiply-add if the target
				///architecture has a dedicated fma CPU instruction. However, this is not always true,
				///and will be heavily dependant on designing algorithms with specific target hardware in
				///mind.
				mul_add(self,LuaDVec4,LuaDVec4) -> LuaDVec4,

			)
			+ BinOps
			(
				self Add LuaDVec4 -> LuaDVec4,
				self Add f64 -> LuaDVec4,
				f64 Add self -> LuaDVec4,
				self Sub LuaDVec4 -> LuaDVec4,
				self Sub f64 -> LuaDVec4,
				f64 Sub self -> LuaDVec4,
				self Div LuaDVec4 -> LuaDVec4,
				self Div f64 -> LuaDVec4,
				f64 Div self -> LuaDVec4,
				self Mul LuaDVec4 -> LuaDVec4,
				self Mul f64 -> LuaDVec4,
				f64 Mul self -> LuaDVec4,
				self Rem LuaDVec4 -> LuaDVec4,
				self Rem f64 -> LuaDVec4,
				f64 Rem self -> LuaDVec4,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaDVec4),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=f64))
			    
			impl
			{
			}
		}
,		{
			///A 2-dimensional vector.
			glam::i32::ivec2::IVec2 : Value
			: Fields
			(
				x: i32,
				y: i32,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(i32,i32) -> LuaIVec2,

				///Creates a vector with all elements set to `v`.
				splat(i32) -> LuaIVec2,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec2,LuaIVec2,LuaIVec2) -> LuaIVec2,

				///Creates a 3D vector from `self` and the given `z` value.
				extend(self,i32) -> LuaIVec3,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaIVec2) -> i32,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaIVec2) -> LuaIVec2,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaIVec2) -> LuaIVec2,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaIVec2,LuaIVec2) -> LuaIVec2,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> i32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> i32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaIVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaIVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaIVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaIVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaIVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaIVec2) -> LuaBVec2,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaIVec2,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaIVec2,

				///Returns a vector that is equal to `self` rotated by 90 degrees.
				perp(self) -> LuaIVec2,

				///The perpendicular dot product of `self` and `rhs`.
				///Also known as the wedge product, 2D cross product, and determinant.
				perp_dot(self,LuaIVec2) -> i32,

				///Returns `rhs` rotated by the angle of `self`. If `self` is normalized,
				///then this just rotation. This is what you usually want. Otherwise,
				///it will be like a rotation with a multiplication by `self`'s length.
				rotate(self,LuaIVec2) -> LuaIVec2,

			)
			+ BinOps
			(
				self Add LuaIVec2 -> LuaIVec2,
				self Add i32 -> LuaIVec2,
				i32 Add self -> LuaIVec2,
				self Sub LuaIVec2 -> LuaIVec2,
				self Sub i32 -> LuaIVec2,
				i32 Sub self -> LuaIVec2,
				self Div LuaIVec2 -> LuaIVec2,
				self Div i32 -> LuaIVec2,
				i32 Div self -> LuaIVec2,
				self Mul LuaIVec2 -> LuaIVec2,
				self Mul i32 -> LuaIVec2,
				i32 Mul self -> LuaIVec2,
				self Rem LuaIVec2 -> LuaIVec2,
				self Rem i32 -> LuaIVec2,
				i32 Rem self -> LuaIVec2,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaIVec2),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=i32))
			    
			impl
			{
			}
		}
,		{
			///A 3-dimensional vector.
			glam::i32::ivec3::IVec3 : Value
			: Fields
			(
				x: i32,
				y: i32,
				z: i32,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(i32,i32,i32) -> LuaIVec3,

				///Creates a vector with all elements set to `v`.
				splat(i32) -> LuaIVec3,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec3,LuaIVec3,LuaIVec3) -> LuaIVec3,

				///Creates a 4D vector from `self` and the given `w` value.
				extend(self,i32) -> LuaIVec4,

				///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				///
				///Truncation may also be performed by using `self.xy()` or `IVec2::from()`.
				truncate(self) -> LuaIVec2,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaIVec3) -> i32,

				///Computes the cross product of `self` and `rhs`.
				cross(self,LuaIVec3) -> LuaIVec3,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaIVec3) -> LuaIVec3,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaIVec3) -> LuaIVec3,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaIVec3,LuaIVec3) -> LuaIVec3,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> i32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> i32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaIVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaIVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaIVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaIVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaIVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaIVec3) -> LuaBVec3,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaIVec3,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaIVec3,

			)
			+ BinOps
			(
				self Add LuaIVec3 -> LuaIVec3,
				self Add i32 -> LuaIVec3,
				i32 Add self -> LuaIVec3,
				self Sub LuaIVec3 -> LuaIVec3,
				self Sub i32 -> LuaIVec3,
				i32 Sub self -> LuaIVec3,
				self Div LuaIVec3 -> LuaIVec3,
				self Div i32 -> LuaIVec3,
				i32 Div self -> LuaIVec3,
				self Mul LuaIVec3 -> LuaIVec3,
				self Mul i32 -> LuaIVec3,
				i32 Mul self -> LuaIVec3,
				self Rem LuaIVec3 -> LuaIVec3,
				self Rem i32 -> LuaIVec3,
				i32 Rem self -> LuaIVec3,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaIVec3),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=i32))
			    
			impl
			{
			}
		}
,		{
			///A 4-dimensional vector.
			glam::i32::ivec4::IVec4 : Value
			: Fields
			(
				x: i32,
				y: i32,
				z: i32,
				w: i32,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(i32,i32,i32,i32) -> LuaIVec4,

				///Creates a vector with all elements set to `v`.
				splat(i32) -> LuaIVec4,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec4,LuaIVec4,LuaIVec4) -> LuaIVec4,

				///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
				///
				///Truncation to `IVec3` may also be performed by using `self.xyz()` or `IVec3::from()`.
				truncate(self) -> LuaIVec3,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaIVec4) -> i32,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaIVec4) -> LuaIVec4,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaIVec4) -> LuaIVec4,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaIVec4,LuaIVec4) -> LuaIVec4,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> i32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> i32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaIVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaIVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaIVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaIVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaIVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaIVec4) -> LuaBVec4,

				///Returns a vector containing the absolute value of each element of `self`.
				abs(self) -> LuaIVec4,

				///Returns a vector with elements representing the sign of `self`.
				///
				///- `1.0` if the number is positive, `+0.0` or `INFINITY`
				///- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
				///- `NAN` if the number is `NAN`
				signum(self) -> LuaIVec4,

			)
			+ BinOps
			(
				self Add LuaIVec4 -> LuaIVec4,
				self Add i32 -> LuaIVec4,
				i32 Add self -> LuaIVec4,
				self Sub LuaIVec4 -> LuaIVec4,
				self Sub i32 -> LuaIVec4,
				i32 Sub self -> LuaIVec4,
				self Div LuaIVec4 -> LuaIVec4,
				self Div i32 -> LuaIVec4,
				i32 Div self -> LuaIVec4,
				self Mul LuaIVec4 -> LuaIVec4,
				self Mul i32 -> LuaIVec4,
				i32 Mul self -> LuaIVec4,
				self Rem LuaIVec4 -> LuaIVec4,
				self Rem i32 -> LuaIVec4,
				i32 Rem self -> LuaIVec4,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaIVec4),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=i32))
			    
			impl
			{
			}
		}
,		{
			///A 2-dimensional vector.
			glam::u32::uvec2::UVec2 : Value
			: Fields
			(
				x: u32,
				y: u32,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(u32,u32) -> LuaUVec2,

				///Creates a vector with all elements set to `v`.
				splat(u32) -> LuaUVec2,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec2,LuaUVec2,LuaUVec2) -> LuaUVec2,

				///Creates a 3D vector from `self` and the given `z` value.
				extend(self,u32) -> LuaUVec3,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaUVec2) -> u32,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaUVec2) -> LuaUVec2,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaUVec2) -> LuaUVec2,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaUVec2,LuaUVec2) -> LuaUVec2,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> u32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> u32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaUVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaUVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaUVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaUVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaUVec2) -> LuaBVec2,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaUVec2) -> LuaBVec2,

			)
			+ BinOps
			(
				self Add LuaUVec2 -> LuaUVec2,
				self Add u32 -> LuaUVec2,
				u32 Add self -> LuaUVec2,
				self Sub LuaUVec2 -> LuaUVec2,
				self Sub u32 -> LuaUVec2,
				u32 Sub self -> LuaUVec2,
				self Div LuaUVec2 -> LuaUVec2,
				self Div u32 -> LuaUVec2,
				u32 Div self -> LuaUVec2,
				self Mul LuaUVec2 -> LuaUVec2,
				self Mul u32 -> LuaUVec2,
				u32 Mul self -> LuaUVec2,
				self Rem LuaUVec2 -> LuaUVec2,
				self Rem u32 -> LuaUVec2,
				u32 Rem self -> LuaUVec2,
			)
			+ UnaryOps
			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaUVec2),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=u32))
			    
			impl
			{
			}
		}
,		{
			///A 3-dimensional vector.
			glam::u32::uvec3::UVec3 : Value
			: Fields
			(
				x: u32,
				y: u32,
				z: u32,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(u32,u32,u32) -> LuaUVec3,

				///Creates a vector with all elements set to `v`.
				splat(u32) -> LuaUVec3,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec3,LuaUVec3,LuaUVec3) -> LuaUVec3,

				///Creates a 4D vector from `self` and the given `w` value.
				extend(self,u32) -> LuaUVec4,

				///Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.
				///
				///Truncation may also be performed by using `self.xy()` or `UVec2::from()`.
				truncate(self) -> LuaUVec2,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaUVec3) -> u32,

				///Computes the cross product of `self` and `rhs`.
				cross(self,LuaUVec3) -> LuaUVec3,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaUVec3) -> LuaUVec3,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaUVec3) -> LuaUVec3,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaUVec3,LuaUVec3) -> LuaUVec3,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> u32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> u32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaUVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaUVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaUVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaUVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaUVec3) -> LuaBVec3,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaUVec3) -> LuaBVec3,

			)
			+ BinOps
			(
				self Add LuaUVec3 -> LuaUVec3,
				self Add u32 -> LuaUVec3,
				u32 Add self -> LuaUVec3,
				self Sub LuaUVec3 -> LuaUVec3,
				self Sub u32 -> LuaUVec3,
				u32 Sub self -> LuaUVec3,
				self Div LuaUVec3 -> LuaUVec3,
				self Div u32 -> LuaUVec3,
				u32 Div self -> LuaUVec3,
				self Mul LuaUVec3 -> LuaUVec3,
				self Mul u32 -> LuaUVec3,
				u32 Mul self -> LuaUVec3,
				self Rem LuaUVec3 -> LuaUVec3,
				self Rem u32 -> LuaUVec3,
				u32 Rem self -> LuaUVec3,
			)
			+ UnaryOps
			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaUVec3),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=u32))
			    
			impl
			{
			}
		}
,		{
			///A 4-dimensional vector.
			glam::u32::uvec4::UVec4 : Value
			: Fields
			(
				x: u32,
				y: u32,
				z: u32,
				w: u32,
			)
			+ AutoMethods
			(
				///Creates a new vector.
				new(u32,u32,u32,u32) -> LuaUVec4,

				///Creates a vector with all elements set to `v`.
				splat(u32) -> LuaUVec4,

				///Creates a vector from the elements in `if_true` and `if_false`, selecting which to use
				///for each element of `self`.
				///
				///A true element in the mask uses the corresponding element from `if_true`, and false
				///uses the element from `if_false`.
				select(LuaBVec4,LuaUVec4,LuaUVec4) -> LuaUVec4,

				///Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.
				///
				///Truncation to `UVec3` may also be performed by using `self.xyz()` or `UVec3::from()`.
				truncate(self) -> LuaUVec3,

				///Computes the dot product of `self` and `rhs`.
				dot(self,LuaUVec4) -> u32,

				///Returns a vector containing the minimum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.
				min(self,LuaUVec4) -> LuaUVec4,

				///Returns a vector containing the maximum values for each element of `self` and `rhs`.
				///
				///In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.
				max(self,LuaUVec4) -> LuaUVec4,

				///Component-wise clamping of values, similar to [`f32::clamp`].
				///
				///Each element in `min` must be less-or-equal to the corresponding element in `max`.
				///
				///# Panics
				///
				///Will panic if `min` is greater than `max` when `glam_assert` is enabled.
				clamp(self,LuaUVec4,LuaUVec4) -> LuaUVec4,

				///Returns the horizontal minimum of `self`.
				///
				///In other words this computes `min(x, y, ..)`.
				min_element(self) -> u32,

				///Returns the horizontal maximum of `self`.
				///
				///In other words this computes `max(x, y, ..)`.
				max_element(self) -> u32,

				///Returns a vector mask containing the result of a `==` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words, this computes `[self.x == rhs.x, self.y == rhs.y, ..]` for all
				///elements.
				cmpeq(self,LuaUVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `!=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x != rhs.x, self.y != rhs.y, ..]` for all
				///elements.
				cmpne(self,LuaUVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `>=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x >= rhs.x, self.y >= rhs.y, ..]` for all
				///elements.
				cmpge(self,LuaUVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `>` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x > rhs.x, self.y > rhs.y, ..]` for all
				///elements.
				cmpgt(self,LuaUVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `<=` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x <= rhs.x, self.y <= rhs.y, ..]` for all
				///elements.
				cmple(self,LuaUVec4) -> LuaBVec4,

				///Returns a vector mask containing the result of a `<` comparison for each element of
				///`self` and `rhs`.
				///
				///In other words this computes `[self.x < rhs.x, self.y < rhs.y, ..]` for all
				///elements.
				cmplt(self,LuaUVec4) -> LuaBVec4,

			)
			+ BinOps
			(
				self Add LuaUVec4 -> LuaUVec4,
				self Add u32 -> LuaUVec4,
				u32 Add self -> LuaUVec4,
				self Sub LuaUVec4 -> LuaUVec4,
				self Sub u32 -> LuaUVec4,
				u32 Sub self -> LuaUVec4,
				self Div LuaUVec4 -> LuaUVec4,
				self Div u32 -> LuaUVec4,
				u32 Div self -> LuaUVec4,
				self Mul LuaUVec4 -> LuaUVec4,
				self Mul u32 -> LuaUVec4,
				u32 Mul self -> LuaUVec4,
				self Rem LuaUVec4 -> LuaUVec4,
				self Rem u32 -> LuaUVec4,
				u32 Rem self -> LuaUVec4,
			)
			+ UnaryOps
			(
			)
+ 			    Copy(LuaVec2 -> (MetaMethod::Index) (s=LuaUVec4),
			        LuaVec2 -> mut (MetaMethod::NewIndex) (n=u32))
			    
			impl
			{
			}
		}
,		{
			///A 3x3 column major matrix.
			///
			///This 3x3 matrix type features convenience methods for creating and using linear and
			///affine transformations. If you are primarily dealing with 2D affine transformations the
			///[`Affine2`](crate::Affine2) type is much faster and more space efficient than
			///using a 3x3 matrix.
			///
			///Linear transformations including 3D rotation and scale can be created using methods
			///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
			///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
			///[`Self::from_rotation_z()`].
			///
			///The resulting matrices can be use to transform 3D vectors using regular vector
			///multiplication.
			///
			///Affine transformations including 2D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
			///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
			///
			///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
			///are provided for performing affine transforms on 2D vectors and points. These multiply
			///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
			///vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
			glam::f32::mat3::Mat3 : Value
			: Fields
			(
				x_axis: LuaVec3,
				y_axis: LuaVec3,
				z_axis: LuaVec3,
			)
			+ AutoMethods
			(
				///Creates a 3x3 matrix from two column vectors.
				from_cols(LuaVec3,LuaVec3,LuaVec3) -> LuaMat3,

				///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				from_diagonal(LuaVec3) -> LuaMat3,

				///Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.
				from_mat4(LuaMat4) -> LuaMat3,

				///Creates a 3D rotation matrix from the given quaternion.
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_quat(LuaQuat) -> LuaMat3,

				///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
				///radians).
				///
				///# Panics
				///
				///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				from_axis_angle(LuaVec3,f32) -> LuaMat3,

				///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
				///radians).
				from_euler(LuaEulerRot,f32,f32,f32) -> LuaMat3,

				///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
				from_rotation_x(f32) -> LuaMat3,

				///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
				from_rotation_y(f32) -> LuaMat3,

				///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
				from_rotation_z(f32) -> LuaMat3,

				///Creates an affine transformation matrix from the given 2D `translation`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_translation(LuaVec2) -> LuaMat3,

				///Creates an affine transformation matrix from the given 2D rotation `angle` (in
				///radians).
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_angle(f32) -> LuaMat3,

				///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
				///radians) and `translation`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_scale_angle_translation(LuaVec2,f32,LuaVec2) -> LuaMat3,

				///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				///
				///# Panics
				///
				///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				from_scale(LuaVec2) -> LuaMat3,

				///Creates an affine transformation matrix from the given 2x2 matrix.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_mat2(LuaMat2) -> LuaMat3,

				///Returns the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 2.
				col(&self,usize) -> LuaVec3,

				///Returns the matrix row for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 2.
				row(&self,usize) -> LuaVec3,

				///Returns `true` if, and only if, all elements are finite.
				///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns the transpose of `self`.
				transpose(&self) -> LuaMat3,

				///Returns the determinant of `self`.
				determinant(&self) -> f32,

				///Returns the inverse of `self`.
				///
				///If the matrix is not invertible the returned matrix will be invalid.
				///
				///# Panics
				///
				///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				inverse(&self) -> LuaMat3,

				///Transforms the given 2D vector as a point.
				///
				///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
				///
				///This method assumes that `self` contains a valid affine transform.
				transform_point2(&self,LuaVec2) -> LuaVec2,

				///Rotates the given 2D vector.
				///
				///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
				///
				///This method assumes that `self` contains a valid affine transform.
				transform_vector2(&self,LuaVec2) -> LuaVec2,

				///Transforms a 3D vector.
				mul_vec3(&self,LuaVec3) -> LuaVec3,

				///Transforms a `Vec3A`.
				mul_vec3a(&self,LuaVec3A) -> LuaVec3A,

				///Multiplies two 3x3 matrices.
				mul_mat3(&self,&LuaMat3) -> LuaMat3,

				///Adds two 3x3 matrices.
				add_mat3(&self,&LuaMat3) -> LuaMat3,

				///Subtracts two 3x3 matrices.
				sub_mat3(&self,&LuaMat3) -> LuaMat3,

				///Multiplies a 3x3 matrix by a scalar.
				mul_scalar(&self,f32) -> LuaMat3,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two matrices contain similar elements. It works best
				///when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaMat3,f32) -> bool,

				as_dmat3(&self) -> LuaDMat3,

			)
			+ BinOps
			(
				self Add LuaMat3 -> LuaMat3,
				self Sub LuaMat3 -> LuaMat3,
				self Mul LuaAffine2 -> LuaMat3,
				self Mul LuaMat3 -> LuaMat3,
				self Mul LuaVec3 -> LuaVec3,
				f32 Mul self -> LuaMat3,
				self Mul f32 -> LuaMat3,
				self Mul LuaVec3A -> LuaVec3A,
			)
			+ UnaryOps
			(
				Neg self
			)
			impl
			{
				    
mut (MetaMethod::Index) (s=LuaMat3,b=Mat3,v=LuaVec3) => {|_,s,idx : usize| {
    match s {
        ($s)::Owned(ref mut v, ref valid) => {
            Ok(($v)::Ref(ScriptRef{
                root: ScriptRefBase::ScriptOwned{valid: Arc::downgrade((valid))},
                r: ReflectPtr::Mut(v.get_mut().col_mut(idx)),
                path: None
            }))
        },
        ($s)::Ref(ref mut r) => {
            r.get_mut(|s,r| {
                Ok(($v)::Ref(ScriptRef{
                    root: r.root.clone(),
                    r: ReflectPtr::Mut(s.downcast_mut::<($b)>().unwrap().col_mut(idx)),
                    path: None
                })) 
            })
        }
    }
}}
;
			}
		}
,		{
			///A 2x2 column major matrix.
			glam::f32::sse2::mat2::Mat2 : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Creates a 2x2 matrix from two column vectors.
				from_cols(LuaVec2,LuaVec2) -> LuaMat2,

				///Creates a 2x2 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				from_diagonal(LuaVec2) -> LuaMat2,

				///Creates a 2x2 matrix containing the combining non-uniform `scale` and rotation of
				///`angle` (in radians).
				from_scale_angle(LuaVec2,f32) -> LuaMat2,

				///Creates a 2x2 matrix containing a rotation of `angle` (in radians).
				from_angle(f32) -> LuaMat2,

				///Creates a 2x2 matrix from a 3x3 matrix, discarding the 2nd row and column.
				from_mat3(LuaMat3) -> LuaMat2,

				///Returns the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 1.
				col(&self,usize) -> LuaVec2,

				///Returns the matrix row for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 1.
				row(&self,usize) -> LuaVec2,

				///Returns `true` if, and only if, all elements are finite.
				///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns the transpose of `self`.
				transpose(&self) -> LuaMat2,

				///Returns the determinant of `self`.
				determinant(&self) -> f32,

				///Returns the inverse of `self`.
				///
				///If the matrix is not invertible the returned matrix will be invalid.
				///
				///# Panics
				///
				///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				inverse(&self) -> LuaMat2,

				///Transforms a 2D vector.
				mul_vec2(&self,LuaVec2) -> LuaVec2,

				///Multiplies two 2x2 matrices.
				mul_mat2(&self,&LuaMat2) -> LuaMat2,

				///Adds two 2x2 matrices.
				add_mat2(&self,&LuaMat2) -> LuaMat2,

				///Subtracts two 2x2 matrices.
				sub_mat2(&self,&LuaMat2) -> LuaMat2,

				///Multiplies a 2x2 matrix by a scalar.
				mul_scalar(&self,f32) -> LuaMat2,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two matrices contain similar elements. It works best
				///when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaMat2,f32) -> bool,

			)
			+ BinOps
			(
				self Add LuaMat2 -> LuaMat2,
				self Sub LuaMat2 -> LuaMat2,
				self Mul LuaMat2 -> LuaMat2,
				self Mul LuaVec2 -> LuaVec2,
				f32 Mul self -> LuaMat2,
				self Mul f32 -> LuaMat2,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			Copy(LuaMat3 -> mut (MetaMethod::Index) (s=LuaMat2,b=Mat2,v=LuaVec2))
			impl
			{
			}
		}
,		{
			///A 3x3 column major matrix.
			///
			///This 3x3 matrix type features convenience methods for creating and using linear and
			///affine transformations. If you are primarily dealing with 2D affine transformations the
			///[`Affine2`](crate::Affine2) type is much faster and more space efficient than
			///using a 3x3 matrix.
			///
			///Linear transformations including 3D rotation and scale can be created using methods
			///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
			///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
			///[`Self::from_rotation_z()`].
			///
			///The resulting matrices can be use to transform 3D vectors using regular vector
			///multiplication.
			///
			///Affine transformations including 2D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
			///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
			///
			///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
			///are provided for performing affine transforms on 2D vectors and points. These multiply
			///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
			///vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
			glam::f32::sse2::mat3::Mat3A : Value
			: Fields
			(
				x_axis: LuaVec3A,
				y_axis: LuaVec3A,
				z_axis: LuaVec3A,
			)
			+ AutoMethods
			(
				///Creates a 3x3 matrix from two column vectors.
				from_cols(LuaVec3A,LuaVec3A,LuaVec3A) -> LuaMat3A,

				///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				from_diagonal(LuaVec3) -> LuaMat3A,

				///Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.
				from_mat4(LuaMat4) -> LuaMat3A,

				///Creates a 3D rotation matrix from the given quaternion.
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_quat(LuaQuat) -> LuaMat3A,

				///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
				///radians).
				///
				///# Panics
				///
				///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				from_axis_angle(LuaVec3,f32) -> LuaMat3A,

				///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
				///radians).
				from_euler(LuaEulerRot,f32,f32,f32) -> LuaMat3A,

				///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
				from_rotation_x(f32) -> LuaMat3A,

				///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
				from_rotation_y(f32) -> LuaMat3A,

				///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
				from_rotation_z(f32) -> LuaMat3A,

				///Creates an affine transformation matrix from the given 2D `translation`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_translation(LuaVec2) -> LuaMat3A,

				///Creates an affine transformation matrix from the given 2D rotation `angle` (in
				///radians).
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_angle(f32) -> LuaMat3A,

				///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
				///radians) and `translation`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_scale_angle_translation(LuaVec2,f32,LuaVec2) -> LuaMat3A,

				///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				///
				///# Panics
				///
				///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				from_scale(LuaVec2) -> LuaMat3A,

				///Creates an affine transformation matrix from the given 2x2 matrix.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_mat2(LuaMat2) -> LuaMat3A,

				///Returns the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 2.
				col(&self,usize) -> LuaVec3A,

				///Returns the matrix row for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 2.
				row(&self,usize) -> LuaVec3A,

				///Returns `true` if, and only if, all elements are finite.
				///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns the transpose of `self`.
				transpose(&self) -> LuaMat3A,

				///Returns the determinant of `self`.
				determinant(&self) -> f32,

				///Returns the inverse of `self`.
				///
				///If the matrix is not invertible the returned matrix will be invalid.
				///
				///# Panics
				///
				///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				inverse(&self) -> LuaMat3A,

				///Transforms the given 2D vector as a point.
				///
				///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
				///
				///This method assumes that `self` contains a valid affine transform.
				transform_point2(&self,LuaVec2) -> LuaVec2,

				///Rotates the given 2D vector.
				///
				///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
				///
				///This method assumes that `self` contains a valid affine transform.
				transform_vector2(&self,LuaVec2) -> LuaVec2,

				///Transforms a 3D vector.
				mul_vec3(&self,LuaVec3) -> LuaVec3,

				///Transforms a `Vec3A`.
				mul_vec3a(&self,LuaVec3A) -> LuaVec3A,

				///Multiplies two 3x3 matrices.
				mul_mat3(&self,&LuaMat3A) -> LuaMat3A,

				///Adds two 3x3 matrices.
				add_mat3(&self,&LuaMat3A) -> LuaMat3A,

				///Subtracts two 3x3 matrices.
				sub_mat3(&self,&LuaMat3A) -> LuaMat3A,

				///Multiplies a 3x3 matrix by a scalar.
				mul_scalar(&self,f32) -> LuaMat3A,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two matrices contain similar elements. It works best
				///when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaMat3A,f32) -> bool,

				as_dmat3(&self) -> LuaDMat3,

			)
			+ BinOps
			(
				self Add LuaMat3A -> LuaMat3A,
				self Sub LuaMat3A -> LuaMat3A,
				self Mul LuaAffine2 -> LuaMat3A,
				self Mul LuaMat3A -> LuaMat3A,
				self Mul LuaVec3A -> LuaVec3A,
				f32 Mul self -> LuaMat3A,
				self Mul f32 -> LuaMat3A,
				self Mul LuaVec3 -> LuaVec3,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			Copy(LuaMat3 -> mut (MetaMethod::Index) (s=LuaMat3A,b=Mat3A,v=LuaVec3A))
			impl
			{
			}
		}
,		{
			///A 4x4 column major matrix.
			///
			///This 4x4 matrix type features convenience methods for creating and using affine transforms and
			///perspective projections. If you are primarily dealing with 3D affine transformations
			///considering using [`Affine3A`](crate::Affine3A) which is faster than a 4x4 matrix
			///for some affine operations.
			///
			///Affine transformations including 3D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_quat()`],
			///[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].
			///
			///Othographic projections can be created using the methods [`Self::orthographic_lh()`] for
			///left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed
			///systems. The resulting matrix is also an affine transformation.
			///
			///The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods
			///are provided for performing affine transformations on 3D vectors and points. These
			///multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`
			///for vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
			///
			///Perspective projections can be created using methods such as
			///[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and
			///[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and
			///[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and
			///[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.
			///
			///The resulting perspective project can be use to transform 3D vectors as points with
			///perspective correction using the [`Self::project_point3()`] convenience method.
			glam::f32::sse2::mat4::Mat4 : Value
			: Fields
			(
				x_axis: LuaVec4,
				y_axis: LuaVec4,
				z_axis: LuaVec4,
				w_axis: LuaVec4,
			)
			+ AutoMethods
			(
				///Creates a 4x4 matrix from two column vectors.
				from_cols(LuaVec4,LuaVec4,LuaVec4,LuaVec4) -> LuaMat4,

				///Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				from_diagonal(LuaVec4) -> LuaMat4,

				///Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
				///`translation`.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_scale_rotation_translation(LuaVec3,LuaQuat,LuaVec3) -> LuaMat4,

				///Creates an affine transformation matrix from the given 3D `translation`.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_rotation_translation(LuaQuat,LuaVec3) -> LuaMat4,

				///Creates an affine transformation matrix from the given `rotation` quaternion.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_quat(LuaQuat) -> LuaMat4,

				///Creates an affine transformation matrix from the given 3x3 linear transformation
				///matrix.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_mat3(LuaMat3) -> LuaMat4,

				///Creates an affine transformation matrix from the given 3D `translation`.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_translation(LuaVec3) -> LuaMat4,

				///Creates an affine transformation matrix containing a 3D rotation around a normalized
				///rotation `axis` of `angle` (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				from_axis_angle(LuaVec3,f32) -> LuaMat4,

				///Creates a affine transformation matrix containing a rotation from the given euler
				///rotation sequence and angles (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_euler(LuaEulerRot,f32,f32,f32) -> LuaMat4,

				///Creates an affine transformation matrix containing a 3D rotation around the x axis of
				///`angle` (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_rotation_x(f32) -> LuaMat4,

				///Creates an affine transformation matrix containing a 3D rotation around the y axis of
				///`angle` (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_rotation_y(f32) -> LuaMat4,

				///Creates an affine transformation matrix containing a 3D rotation around the z axis of
				///`angle` (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_rotation_z(f32) -> LuaMat4,

				///Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				from_scale(LuaVec3) -> LuaMat4,

				///Returns the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 3.
				col(&self,usize) -> LuaVec4,

				///Returns the matrix row for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 3.
				row(&self,usize) -> LuaVec4,

				///Returns `true` if, and only if, all elements are finite.
				///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns the transpose of `self`.
				transpose(&self) -> LuaMat4,

				///Returns the determinant of `self`.
				determinant(&self) -> f32,

				///Returns the inverse of `self`.
				///
				///If the matrix is not invertible the returned matrix will be invalid.
				///
				///# Panics
				///
				///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				inverse(&self) -> LuaMat4,

				///Creates a left-handed view matrix using a camera position, an up direction, and a focal
				///point.
				///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
				///
				///# Panics
				///
				///Will panic if `up` is not normalized when `glam_assert` is enabled.
				look_at_lh(LuaVec3,LuaVec3,LuaVec3) -> LuaMat4,

				///Creates a right-handed view matrix using a camera position, an up direction, and a focal
				///point.
				///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
				///
				///# Panics
				///
				///Will panic if `up` is not normalized when `glam_assert` is enabled.
				look_at_rh(LuaVec3,LuaVec3,LuaVec3) -> LuaMat4,

				///Creates a right-handed perspective projection matrix with [-1,1] depth range.
				///This is the same as the OpenGL `gluPerspective` function.
				///See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
				perspective_rh_gl(f32,f32,f32,f32) -> LuaMat4,

				///Creates a left-handed perspective projection matrix with `[0,1]` depth range.
				///
				///# Panics
				///
				///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
				///enabled.
				perspective_lh(f32,f32,f32,f32) -> LuaMat4,

				///Creates a right-handed perspective projection matrix with `[0,1]` depth range.
				///
				///# Panics
				///
				///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
				///enabled.
				perspective_rh(f32,f32,f32,f32) -> LuaMat4,

				///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
				///
				///# Panics
				///
				///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
				perspective_infinite_lh(f32,f32,f32) -> LuaMat4,

				///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
				///
				///# Panics
				///
				///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
				perspective_infinite_reverse_lh(f32,f32,f32) -> LuaMat4,

				///Creates an infinite right-handed perspective projection matrix with
				///`[0,1]` depth range.
				perspective_infinite_rh(f32,f32,f32) -> LuaMat4,

				///Creates an infinite reverse right-handed perspective projection matrix
				///with `[0,1]` depth range.
				perspective_infinite_reverse_rh(f32,f32,f32) -> LuaMat4,

				///Creates a right-handed orthographic projection matrix with `[-1,1]` depth
				///range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
				///See
				///<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
				orthographic_rh_gl(f32,f32,f32,f32,f32,f32) -> LuaMat4,

				///Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
				orthographic_lh(f32,f32,f32,f32,f32,f32) -> LuaMat4,

				///Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
				orthographic_rh(f32,f32,f32,f32,f32,f32) -> LuaMat4,

				///Transforms the given 3D vector as a point, applying perspective correction.
				///
				///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
				///The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
				///
				///This method assumes that `self` contains a projective transform.
				project_point3(&self,LuaVec3) -> LuaVec3,

				///Transforms the given 3D vector as a point.
				///
				///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
				///`1.0`.
				///
				///This method assumes that `self` contains a valid affine transform. It does not perform
				///a persective divide, if `self` contains a perspective transform, or if you are unsure,
				///the [`Self::project_point3()`] method should be used instead.
				///
				///# Panics
				///
				///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
				transform_point3(&self,LuaVec3) -> LuaVec3,

				///Transforms the give 3D vector as a direction.
				///
				///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
				///`0.0`.
				///
				///This method assumes that `self` contains a valid affine transform.
				///
				///# Panics
				///
				///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
				transform_vector3(&self,LuaVec3) -> LuaVec3,

				///Transforms the given `Vec3A` as 3D point.
				///
				///This is the equivalent of multiplying the `Vec3A` as a 4D vector where `w` is `1.0`.
				transform_point3a(&self,LuaVec3A) -> LuaVec3A,

				///Transforms the give `Vec3A` as 3D vector.
				///
				///This is the equivalent of multiplying the `Vec3A` as a 4D vector where `w` is `0.0`.
				transform_vector3a(&self,LuaVec3A) -> LuaVec3A,

				///Transforms a 4D vector.
				mul_vec4(&self,LuaVec4) -> LuaVec4,

				///Multiplies two 4x4 matrices.
				mul_mat4(&self,&LuaMat4) -> LuaMat4,

				///Adds two 4x4 matrices.
				add_mat4(&self,&LuaMat4) -> LuaMat4,

				///Subtracts two 4x4 matrices.
				sub_mat4(&self,&LuaMat4) -> LuaMat4,

				///Multiplies a 4x4 matrix by a scalar.
				mul_scalar(&self,f32) -> LuaMat4,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two matrices contain similar elements. It works best
				///when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaMat4,f32) -> bool,

				as_dmat4(&self) -> LuaDMat4,

			)
			+ BinOps
			(
				self Add LuaMat4 -> LuaMat4,
				self Sub LuaMat4 -> LuaMat4,
				self Mul LuaAffine3A -> LuaMat4,
				self Mul LuaMat4 -> LuaMat4,
				self Mul LuaVec4 -> LuaVec4,
				f32 Mul self -> LuaMat4,
				self Mul f32 -> LuaMat4,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			Copy(LuaMat3 -> mut (MetaMethod::Index) (s=LuaMat4,b=Mat4,v=LuaVec4))
			impl
			{
			}
		}
,		{
			///A 3x3 column major matrix.
			///
			///This 3x3 matrix type features convenience methods for creating and using linear and
			///affine transformations. If you are primarily dealing with 2D affine transformations the
			///[`DAffine2`](crate::DAffine2) type is much faster and more space efficient than
			///using a 3x3 matrix.
			///
			///Linear transformations including 3D rotation and scale can be created using methods
			///such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],
			///[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or
			///[`Self::from_rotation_z()`].
			///
			///The resulting matrices can be use to transform 3D vectors using regular vector
			///multiplication.
			///
			///Affine transformations including 2D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_angle()`],
			///[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].
			///
			///The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods
			///are provided for performing affine transforms on 2D vectors and points. These multiply
			///2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for
			///vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
			glam::f64::dmat3::DMat3 : Value
			: Fields
			(
				x_axis: LuaDVec3,
				y_axis: LuaDVec3,
				z_axis: LuaDVec3,
			)
			+ AutoMethods
			(
				///Creates a 3x3 matrix from two column vectors.
				from_cols(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDMat3,

				///Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				from_diagonal(LuaDVec3) -> LuaDMat3,

				///Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.
				from_mat4(LuaDMat4) -> LuaDMat3,

				///Creates a 3D rotation matrix from the given quaternion.
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_quat(LuaDQuat) -> LuaDMat3,

				///Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in
				///radians).
				///
				///# Panics
				///
				///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				from_axis_angle(LuaDVec3,f64) -> LuaDMat3,

				///Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in
				///radians).
				from_euler(LuaEulerRot,f64,f64,f64) -> LuaDMat3,

				///Creates a 3D rotation matrix from `angle` (in radians) around the x axis.
				from_rotation_x(f64) -> LuaDMat3,

				///Creates a 3D rotation matrix from `angle` (in radians) around the y axis.
				from_rotation_y(f64) -> LuaDMat3,

				///Creates a 3D rotation matrix from `angle` (in radians) around the z axis.
				from_rotation_z(f64) -> LuaDMat3,

				///Creates an affine transformation matrix from the given 2D `translation`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_translation(LuaDVec2) -> LuaDMat3,

				///Creates an affine transformation matrix from the given 2D rotation `angle` (in
				///radians).
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_angle(f64) -> LuaDMat3,

				///Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in
				///radians) and `translation`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				from_scale_angle_translation(LuaDVec2,f64,LuaDVec2) -> LuaDMat3,

				///Creates an affine transformation matrix from the given non-uniform 2D `scale`.
				///
				///The resulting matrix can be used to transform 2D points and vectors. See
				///[`Self::transform_point2()`] and [`Self::transform_vector2()`].
				///
				///# Panics
				///
				///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				from_scale(LuaDVec2) -> LuaDMat3,

				///Returns the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 2.
				col(&self,usize) -> LuaDVec3,

				///Returns the matrix row for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 2.
				row(&self,usize) -> LuaDVec3,

				///Returns `true` if, and only if, all elements are finite.
				///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns the transpose of `self`.
				transpose(&self) -> LuaDMat3,

				///Returns the determinant of `self`.
				determinant(&self) -> f64,

				///Returns the inverse of `self`.
				///
				///If the matrix is not invertible the returned matrix will be invalid.
				///
				///# Panics
				///
				///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				inverse(&self) -> LuaDMat3,

				///Transforms the given 2D vector as a point.
				///
				///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.
				///
				///This method assumes that `self` contains a valid affine transform.
				transform_point2(&self,LuaDVec2) -> LuaDVec2,

				///Rotates the given 2D vector.
				///
				///This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.
				///
				///This method assumes that `self` contains a valid affine transform.
				transform_vector2(&self,LuaDVec2) -> LuaDVec2,

				///Transforms a 3D vector.
				mul_vec3(&self,LuaDVec3) -> LuaDVec3,

				///Multiplies two 3x3 matrices.
				mul_mat3(&self,&LuaDMat3) -> LuaDMat3,

				///Adds two 3x3 matrices.
				add_mat3(&self,&LuaDMat3) -> LuaDMat3,

				///Subtracts two 3x3 matrices.
				sub_mat3(&self,&LuaDMat3) -> LuaDMat3,

				///Multiplies a 3x3 matrix by a scalar.
				mul_scalar(&self,f64) -> LuaDMat3,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two matrices contain similar elements. It works best
				///when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaDMat3,f64) -> bool,

				as_mat3(&self) -> LuaMat3,

			)
			+ BinOps
			(
				self Add LuaDMat3 -> LuaDMat3,
				self Sub LuaDMat3 -> LuaDMat3,
				self Mul LuaDAffine2 -> LuaDMat3,
				self Mul LuaDMat3 -> LuaDMat3,
				self Mul LuaDVec3 -> LuaDVec3,
				f64 Mul self -> LuaDMat3,
				self Mul f64 -> LuaDMat3,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			Copy(LuaMat3 -> mut (MetaMethod::Index) (s=LuaDMat3,b=DMat3,v=LuaDVec3))
			impl
			{
			}
		}
,		{
			///A 4x4 column major matrix.
			///
			///This 4x4 matrix type features convenience methods for creating and using affine transforms and
			///perspective projections. If you are primarily dealing with 3D affine transformations
			///considering using [`DAffine3`](crate::DAffine3) which is faster than a 4x4 matrix
			///for some affine operations.
			///
			///Affine transformations including 3D translation, rotation and scale can be created
			///using methods such as [`Self::from_translation()`], [`Self::from_quat()`],
			///[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].
			///
			///Othographic projections can be created using the methods [`Self::orthographic_lh()`] for
			///left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed
			///systems. The resulting matrix is also an affine transformation.
			///
			///The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods
			///are provided for performing affine transformations on 3D vectors and points. These
			///multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`
			///for vectors respectively. These methods assume that `Self` contains a valid affine
			///transform.
			///
			///Perspective projections can be created using methods such as
			///[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and
			///[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and
			///[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and
			///[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.
			///
			///The resulting perspective project can be use to transform 3D vectors as points with
			///perspective correction using the [`Self::project_point3()`] convenience method.
			glam::f64::dmat4::DMat4 : Value
			: Fields
			(
				x_axis: LuaDVec4,
				y_axis: LuaDVec4,
				z_axis: LuaDVec4,
				w_axis: LuaDVec4,
			)
			+ AutoMethods
			(
				///Creates a 4x4 matrix from two column vectors.
				from_cols(LuaDVec4,LuaDVec4,LuaDVec4,LuaDVec4) -> LuaDMat4,

				///Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.
				from_diagonal(LuaDVec4) -> LuaDMat4,

				///Creates an affine transformation matrix from the given 3D `scale`, `rotation` and
				///`translation`.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_scale_rotation_translation(LuaDVec3,LuaDQuat,LuaDVec3) -> LuaDMat4,

				///Creates an affine transformation matrix from the given 3D `translation`.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_rotation_translation(LuaDQuat,LuaDVec3) -> LuaDMat4,

				///Creates an affine transformation matrix from the given `rotation` quaternion.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if `rotation` is not normalized when `glam_assert` is enabled.
				from_quat(LuaDQuat) -> LuaDMat4,

				///Creates an affine transformation matrix from the given 3x3 linear transformation
				///matrix.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_mat3(LuaDMat3) -> LuaDMat4,

				///Creates an affine transformation matrix from the given 3D `translation`.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_translation(LuaDVec3) -> LuaDMat4,

				///Creates an affine transformation matrix containing a 3D rotation around a normalized
				///rotation `axis` of `angle` (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				from_axis_angle(LuaDVec3,f64) -> LuaDMat4,

				///Creates a affine transformation matrix containing a rotation from the given euler
				///rotation sequence and angles (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_euler(LuaEulerRot,f64,f64,f64) -> LuaDMat4,

				///Creates an affine transformation matrix containing a 3D rotation around the x axis of
				///`angle` (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_rotation_x(f64) -> LuaDMat4,

				///Creates an affine transformation matrix containing a 3D rotation around the y axis of
				///`angle` (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_rotation_y(f64) -> LuaDMat4,

				///Creates an affine transformation matrix containing a 3D rotation around the z axis of
				///`angle` (in radians).
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				from_rotation_z(f64) -> LuaDMat4,

				///Creates an affine transformation matrix containing the given 3D non-uniform `scale`.
				///
				///The resulting matrix can be used to transform 3D points and vectors. See
				///[`Self::transform_point3()`] and [`Self::transform_vector3()`].
				///
				///# Panics
				///
				///Will panic if all elements of `scale` are zero when `glam_assert` is enabled.
				from_scale(LuaDVec3) -> LuaDMat4,

				///Returns the matrix column for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 3.
				col(&self,usize) -> LuaDVec4,

				///Returns the matrix row for the given `index`.
				///
				///# Panics
				///
				///Panics if `index` is greater than 3.
				row(&self,usize) -> LuaDVec4,

				///Returns `true` if, and only if, all elements are finite.
				///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns the transpose of `self`.
				transpose(&self) -> LuaDMat4,

				///Returns the determinant of `self`.
				determinant(&self) -> f64,

				///Returns the inverse of `self`.
				///
				///If the matrix is not invertible the returned matrix will be invalid.
				///
				///# Panics
				///
				///Will panic if the determinant of `self` is zero when `glam_assert` is enabled.
				inverse(&self) -> LuaDMat4,

				///Creates a left-handed view matrix using a camera position, an up direction, and a focal
				///point.
				///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
				///
				///# Panics
				///
				///Will panic if `up` is not normalized when `glam_assert` is enabled.
				look_at_lh(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDMat4,

				///Creates a right-handed view matrix using a camera position, an up direction, and a focal
				///point.
				///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
				///
				///# Panics
				///
				///Will panic if `up` is not normalized when `glam_assert` is enabled.
				look_at_rh(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDMat4,

				///Creates a right-handed perspective projection matrix with [-1,1] depth range.
				///This is the same as the OpenGL `gluPerspective` function.
				///See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>
				perspective_rh_gl(f64,f64,f64,f64) -> LuaDMat4,

				///Creates a left-handed perspective projection matrix with `[0,1]` depth range.
				///
				///# Panics
				///
				///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
				///enabled.
				perspective_lh(f64,f64,f64,f64) -> LuaDMat4,

				///Creates a right-handed perspective projection matrix with `[0,1]` depth range.
				///
				///# Panics
				///
				///Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is
				///enabled.
				perspective_rh(f64,f64,f64,f64) -> LuaDMat4,

				///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
				///
				///# Panics
				///
				///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
				perspective_infinite_lh(f64,f64,f64) -> LuaDMat4,

				///Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.
				///
				///# Panics
				///
				///Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.
				perspective_infinite_reverse_lh(f64,f64,f64) -> LuaDMat4,

				///Creates an infinite right-handed perspective projection matrix with
				///`[0,1]` depth range.
				perspective_infinite_rh(f64,f64,f64) -> LuaDMat4,

				///Creates an infinite reverse right-handed perspective projection matrix
				///with `[0,1]` depth range.
				perspective_infinite_reverse_rh(f64,f64,f64) -> LuaDMat4,

				///Creates a right-handed orthographic projection matrix with `[-1,1]` depth
				///range.  This is the same as the OpenGL `glOrtho` function in OpenGL.
				///See
				///<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>
				orthographic_rh_gl(f64,f64,f64,f64,f64,f64) -> LuaDMat4,

				///Creates a left-handed orthographic projection matrix with `[0,1]` depth range.
				orthographic_lh(f64,f64,f64,f64,f64,f64) -> LuaDMat4,

				///Creates a right-handed orthographic projection matrix with `[0,1]` depth range.
				orthographic_rh(f64,f64,f64,f64,f64,f64) -> LuaDMat4,

				///Transforms the given 3D vector as a point, applying perspective correction.
				///
				///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.
				///The perspective divide is performed meaning the resulting 3D vector is divided by `w`.
				///
				///This method assumes that `self` contains a projective transform.
				project_point3(&self,LuaDVec3) -> LuaDVec3,

				///Transforms the given 3D vector as a point.
				///
				///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
				///`1.0`.
				///
				///This method assumes that `self` contains a valid affine transform. It does not perform
				///a persective divide, if `self` contains a perspective transform, or if you are unsure,
				///the [`Self::project_point3()`] method should be used instead.
				///
				///# Panics
				///
				///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
				transform_point3(&self,LuaDVec3) -> LuaDVec3,

				///Transforms the give 3D vector as a direction.
				///
				///This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is
				///`0.0`.
				///
				///This method assumes that `self` contains a valid affine transform.
				///
				///# Panics
				///
				///Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.
				transform_vector3(&self,LuaDVec3) -> LuaDVec3,

				///Transforms a 4D vector.
				mul_vec4(&self,LuaDVec4) -> LuaDVec4,

				///Multiplies two 4x4 matrices.
				mul_mat4(&self,&LuaDMat4) -> LuaDMat4,

				///Adds two 4x4 matrices.
				add_mat4(&self,&LuaDMat4) -> LuaDMat4,

				///Subtracts two 4x4 matrices.
				sub_mat4(&self,&LuaDMat4) -> LuaDMat4,

				///Multiplies a 4x4 matrix by a scalar.
				mul_scalar(&self,f64) -> LuaDMat4,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two matrices contain similar elements. It works best
				///when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaDMat4,f64) -> bool,

				as_mat4(&self) -> LuaMat4,

			)
			+ BinOps
			(
				self Add LuaDMat4 -> LuaDMat4,
				self Sub LuaDMat4 -> LuaDMat4,
				self Mul LuaDAffine3 -> LuaDMat4,
				self Mul LuaDMat4 -> LuaDMat4,
				self Mul LuaDVec4 -> LuaDVec4,
				f64 Mul self -> LuaDMat4,
				self Mul f64 -> LuaDMat4,
			)
			+ UnaryOps
			(
				Neg self
			)
+ 			Copy(LuaMat3 -> mut (MetaMethod::Index) (s=LuaDMat4,b=DMat4,v=LuaDVec4))
			impl
			{
			}
		}
,		{
			///A 2D affine transform, which can represent translation, rotation, scaling and shear.
			glam::f32::sse2::mat2::Affine2 : Value
			: Fields
			(
				matrix2: LuaMat2,
				translation: LuaVec2,
			)
			+ AutoMethods
			(
				///Creates an affine transform from three column vectors.
				from_cols(LuaVec2,LuaVec2,LuaVec2) -> LuaAffine2,

				///Creates an affine transform that changes scale.
				///Note that if any scale is zero the transform will be non-invertible.
				from_scale(LuaVec2) -> LuaAffine2,

				///Creates an affine transform from the given rotation `angle`.
				from_angle(f32) -> LuaAffine2,

				///Creates an affine transformation from the given 2D `translation`.
				from_translation(LuaVec2) -> LuaAffine2,

				///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation)
				from_mat2(LuaMat2) -> LuaAffine2,

				///Creates an affine transform from a 2x2 matrix (expressing scale, shear and rotation) and a
				///translation vector.
				///
				///Equivalent to
				///`Affine2::from_translation(translation) * Affine2::from_mat2(mat2)`
				from_mat2_translation(LuaMat2,LuaVec2) -> LuaAffine2,

				///Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
				///`translation`.
				///
				///Equivalent to `Affine2::from_translation(translation) *
				///Affine2::from_angle(angle) * Affine2::from_scale(scale)`
				from_scale_angle_translation(LuaVec2,f32,LuaVec2) -> LuaAffine2,

				///Creates an affine transform from the given 2D rotation `angle` (in radians) and
				///`translation`.
				///
				///Equivalent to `Affine2::from_translation(translation) * Affine2::from_angle(angle)`
				from_angle_translation(f32,LuaVec2) -> LuaAffine2,

				///The given `Mat3` must be an affine transform,
				from_mat3(LuaMat3) -> LuaAffine2,

				///Transforms the given 2D point, applying shear, scale, rotation and translation.
				transform_point2(&self,LuaVec2) -> LuaVec2,

				///Transforms the given 2D vector, applying shear, scale and rotation (but NOT
				///translation).
				///
				///To also apply translation, use [`Self::transform_point2`] instead.
				transform_vector2(&self,LuaVec2) -> LuaVec2,

				///Returns `true` if, and only if, all elements are finite.
				///
				///If any element is either `NaN`, positive or negative infinity, this will return
				///`false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two 3x4 matrices contain similar elements. It works
				///best when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaAffine2,f32) -> bool,

				///Return the inverse of this transform.
				///
				///Note that if the transform is not invertible the result will be invalid.
				inverse(&self) -> LuaAffine2,

			)
			+ BinOps
			(
				self Add LuaAffine2 -> LuaAffine2,
				self Sub LuaAffine2 -> LuaAffine2,
				self Mul LuaAffine2 -> LuaAffine2,
				f32 Mul self -> LuaAffine2,
				self Mul f32 -> LuaAffine2,
				self Mul LuaMat3 -> LuaMat3,
				self Mul LuaMat3A -> LuaMat3A,
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 3D affine transform, which can represent translation, rotation, scaling and shear.
			glam::f32::sse2::mat3::Affine3A : Value
			: Fields
			(
				matrix3: LuaMat3A,
				translation: LuaVec3A,
			)
			+ AutoMethods
			(
				///Creates an affine transform from three column vectors.
				from_cols(LuaVec3A,LuaVec3A,LuaVec3A,LuaVec3A) -> LuaAffine3A,

				///Creates an affine transform that changes scale.
				///Note that if any scale is zero the transform will be non-invertible.
				from_scale(LuaVec3) -> LuaAffine3A,

				///Creates an affine transform from the given `rotation` quaternion.
				from_quat(LuaQuat) -> LuaAffine3A,

				///Creates an affine transform containing a 3D rotation around a normalized
				///rotation `axis` of `angle` (in radians).
				from_axis_angle(LuaVec3,f32) -> LuaAffine3A,

				///Creates an affine transform containing a 3D rotation around the x axis of
				///`angle` (in radians).
				from_rotation_x(f32) -> LuaAffine3A,

				///Creates an affine transform containing a 3D rotation around the y axis of
				///`angle` (in radians).
				from_rotation_y(f32) -> LuaAffine3A,

				///Creates an affine transform containing a 3D rotation around the z axis of
				///`angle` (in radians).
				from_rotation_z(f32) -> LuaAffine3A,

				///Creates an affine transformation from the given 3D `translation`.
				from_translation(LuaVec3) -> LuaAffine3A,

				///Creates an affine transform from a 3x3 matrix (expressing scale, shear and
				///rotation)
				from_mat3(LuaMat3) -> LuaAffine3A,

				///Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
				///and a translation vector.
				///
				///Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_mat3(mat3)`
				from_mat3_translation(LuaMat3,LuaVec3) -> LuaAffine3A,

				///Creates an affine transform from the given 3D `scale`, `rotation` and
				///`translation`.
				///
				///Equivalent to `Affine3A::from_translation(translation) *
				///Affine3A::from_quat(rotation) * Affine3A::from_scale(scale)`
				from_scale_rotation_translation(LuaVec3,LuaQuat,LuaVec3) -> LuaAffine3A,

				///Creates an affine transform from the given 3D `rotation` and `translation`.
				///
				///Equivalent to `Affine3A::from_translation(translation) * Affine3A::from_quat(rotation)`
				from_rotation_translation(LuaQuat,LuaVec3) -> LuaAffine3A,

				///The given `Mat4` must be an affine transform,
				///i.e. contain no perspective transform.
				from_mat4(LuaMat4) -> LuaAffine3A,

				///Creates a left-handed view transform using a camera position, an up direction, and
				///a focal point.
				///
				///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
				///
				///# Panics
				///
				///Will panic if `up` is not normalized when `glam_assert` is enabled.
				look_at_lh(LuaVec3,LuaVec3,LuaVec3) -> LuaAffine3A,

				///Creates a right-handed view transform using a camera position, an up direction, and
				///a focal point.
				///
				///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
				///
				///# Panics
				///
				///Will panic if `up` is not normalized when `glam_assert` is enabled.
				look_at_rh(LuaVec3,LuaVec3,LuaVec3) -> LuaAffine3A,

				///Transforms the given 3D points, applying shear, scale, rotation and translation.
				transform_point3(&self,LuaVec3) -> LuaVec3,

				///Transforms the given 3D vector, applying shear, scale and rotation (but NOT
				///translation).
				///
				///To also apply translation, use [`Self::transform_point3`] instead.
				transform_vector3(&self,LuaVec3) -> LuaVec3,

				///Transforms the given `Vec3A`, applying shear, scale, rotation and translation.
				transform_point3a(&self,LuaVec3A) -> LuaVec3A,

				///Transforms the given `Vec3A`, applying shear, scale and rotation (but NOT
				///translation).
				///
				///To also apply translation, use [`Self::transform_point3`] instead.
				transform_vector3a(&self,LuaVec3A) -> LuaVec3A,

				///Returns `true` if, and only if, all elements are finite.
				///
				///If any element is either `NaN`, positive or negative infinity, this will return
				///`false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two 3x4 matrices contain similar elements. It works
				///best when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaAffine3A,f32) -> bool,

				///Return the inverse of this transform.
				///
				///Note that if the transform is not invertible the result will be invalid.
				inverse(&self) -> LuaAffine3A,

			)
			+ BinOps
			(
				self Add LuaAffine3A -> LuaAffine3A,
				self Sub LuaAffine3A -> LuaAffine3A,
				self Mul LuaAffine3A -> LuaAffine3A,
				f32 Mul self -> LuaAffine3A,
				self Mul f32 -> LuaAffine3A,
				self Mul LuaMat4 -> LuaMat4,
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 2D affine transform, which can represent translation, rotation, scaling and shear.
			glam::f64::sse2::mat2::DAffine2 : Value
			: Fields
			(
				translation: LuaDVec2,
			)
			+ AutoMethods
			(
				///Creates an affine transform from three column vectors.
				from_cols(LuaDVec2,LuaDVec2,LuaDVec2) -> LuaDAffine2,

				///Creates an affine transform that changes scale.
				///Note that if any scale is zero the transform will be non-invertible.
				from_scale(LuaDVec2) -> LuaDAffine2,

				///Creates an affine transform from the given rotation `angle`.
				from_angle(f64) -> LuaDAffine2,

				///Creates an affine transformation from the given 2D `translation`.
				from_translation(LuaDVec2) -> LuaDAffine2,

				///Creates an affine transform from the given 2D `scale`, rotation `angle` (in radians) and
				///`translation`.
				///
				///Equivalent to `DAffine2::from_translation(translation) *
				///DAffine2::from_angle(angle) * DAffine2::from_scale(scale)`
				from_scale_angle_translation(LuaDVec2,f64,LuaDVec2) -> LuaDAffine2,

				///Creates an affine transform from the given 2D rotation `angle` (in radians) and
				///`translation`.
				///
				///Equivalent to `DAffine2::from_translation(translation) * DAffine2::from_angle(angle)`
				from_angle_translation(f64,LuaDVec2) -> LuaDAffine2,

				///The given `DMat3` must be an affine transform,
				from_mat3(LuaDMat3) -> LuaDAffine2,

				///Transforms the given 2D point, applying shear, scale, rotation and translation.
				transform_point2(&self,LuaDVec2) -> LuaDVec2,

				///Transforms the given 2D vector, applying shear, scale and rotation (but NOT
				///translation).
				///
				///To also apply translation, use [`Self::transform_point2`] instead.
				transform_vector2(&self,LuaDVec2) -> LuaDVec2,

				///Returns `true` if, and only if, all elements are finite.
				///
				///If any element is either `NaN`, positive or negative infinity, this will return
				///`false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two 3x4 matrices contain similar elements. It works
				///best when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaDAffine2,f64) -> bool,

				///Return the inverse of this transform.
				///
				///Note that if the transform is not invertible the result will be invalid.
				inverse(&self) -> LuaDAffine2,

			)
			+ BinOps
			(
				self Add LuaDAffine2 -> LuaDAffine2,
				self Sub LuaDAffine2 -> LuaDAffine2,
				self Mul LuaDAffine2 -> LuaDAffine2,
				f64 Mul self -> LuaDAffine2,
				self Mul f64 -> LuaDAffine2,
				self Mul LuaDMat3 -> LuaDMat3,
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A 3D affine transform, which can represent translation, rotation, scaling and shear.
			glam::f64::sse2::mat3::DAffine3 : Value
			: Fields
			(
				matrix3: LuaDMat3,
				translation: LuaDVec3,
			)
			+ AutoMethods
			(
				///Creates an affine transform from three column vectors.
				from_cols(LuaDVec3,LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDAffine3,

				///Creates an affine transform that changes scale.
				///Note that if any scale is zero the transform will be non-invertible.
				from_scale(LuaDVec3) -> LuaDAffine3,

				///Creates an affine transform from the given `rotation` quaternion.
				from_quat(LuaDQuat) -> LuaDAffine3,

				///Creates an affine transform containing a 3D rotation around a normalized
				///rotation `axis` of `angle` (in radians).
				from_axis_angle(LuaDVec3,f64) -> LuaDAffine3,

				///Creates an affine transform containing a 3D rotation around the x axis of
				///`angle` (in radians).
				from_rotation_x(f64) -> LuaDAffine3,

				///Creates an affine transform containing a 3D rotation around the y axis of
				///`angle` (in radians).
				from_rotation_y(f64) -> LuaDAffine3,

				///Creates an affine transform containing a 3D rotation around the z axis of
				///`angle` (in radians).
				from_rotation_z(f64) -> LuaDAffine3,

				///Creates an affine transformation from the given 3D `translation`.
				from_translation(LuaDVec3) -> LuaDAffine3,

				///Creates an affine transform from a 3x3 matrix (expressing scale, shear and
				///rotation)
				from_mat3(LuaDMat3) -> LuaDAffine3,

				///Creates an affine transform from a 3x3 matrix (expressing scale, shear and rotation)
				///and a translation vector.
				///
				///Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_mat3(mat3)`
				from_mat3_translation(LuaDMat3,LuaDVec3) -> LuaDAffine3,

				///Creates an affine transform from the given 3D `scale`, `rotation` and
				///`translation`.
				///
				///Equivalent to `DAffine3::from_translation(translation) *
				///DAffine3::from_quat(rotation) * DAffine3::from_scale(scale)`
				from_scale_rotation_translation(LuaDVec3,LuaDQuat,LuaDVec3) -> LuaDAffine3,

				///Creates an affine transform from the given 3D `rotation` and `translation`.
				///
				///Equivalent to `DAffine3::from_translation(translation) * DAffine3::from_quat(rotation)`
				from_rotation_translation(LuaDQuat,LuaDVec3) -> LuaDAffine3,

				///The given `DMat4` must be an affine transform,
				///i.e. contain no perspective transform.
				from_mat4(LuaDMat4) -> LuaDAffine3,

				///Creates a left-handed view transform using a camera position, an up direction, and
				///a focal point.
				///
				///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.
				///
				///# Panics
				///
				///Will panic if `up` is not normalized when `glam_assert` is enabled.
				look_at_lh(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDAffine3,

				///Creates a right-handed view transform using a camera position, an up direction, and
				///a focal point.
				///
				///For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.
				///
				///# Panics
				///
				///Will panic if `up` is not normalized when `glam_assert` is enabled.
				look_at_rh(LuaDVec3,LuaDVec3,LuaDVec3) -> LuaDAffine3,

				///Transforms the given 3D points, applying shear, scale, rotation and translation.
				transform_point3(&self,LuaDVec3) -> LuaDVec3,

				///Transforms the given 3D vector, applying shear, scale and rotation (but NOT
				///translation).
				///
				///To also apply translation, use [`Self::transform_point3`] instead.
				transform_vector3(&self,LuaDVec3) -> LuaDVec3,

				///Returns `true` if, and only if, all elements are finite.
				///
				///If any element is either `NaN`, positive or negative infinity, this will return
				///`false`.
				is_finite(&self) -> bool,

				///Returns `true` if any elements are `NaN`.
				is_nan(&self) -> bool,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two 3x4 matrices contain similar elements. It works
				///best when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(&self,LuaDAffine3,f64) -> bool,

				///Return the inverse of this transform.
				///
				///Note that if the transform is not invertible the result will be invalid.
				inverse(&self) -> LuaDAffine3,

			)
			+ BinOps
			(
				self Add LuaDAffine3 -> LuaDAffine3,
				self Sub LuaDAffine3 -> LuaDAffine3,
				self Mul LuaDAffine3 -> LuaDAffine3,
				f64 Mul self -> LuaDAffine3,
				self Mul f64 -> LuaDAffine3,
				self Mul LuaDMat4 -> LuaDMat4,
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,		{
			///A quaternion representing an orientation.
			///
			///This quaternion is intended to be of unit length but may denormalize due to
			///floating point "error creep" which can occur when successive quaternion
			///operations are applied.
			///
			///This type is 16 byte aligned.
			glam::f32::sse2::quat::Quat : Value
			: Fields
			(
			)
			+ AutoMethods
			(
				///Creates a new rotation quaternion.
				///
				///This should generally not be called manually unless you know what you are doing.
				///Use one of the other constructors instead such as `identity` or `from_axis_angle`.
				///
				///`from_xyzw` is mostly used by unit tests and `serde` deserialization.
				///
				///# Preconditions
				///
				///This function does not check if the input is normalized, it is up to the user to
				///provide normalized input or to normalized the resulting quaternion.
				from_xyzw(f32,f32,f32,f32) -> LuaQuat,

				///Creates a new rotation quaternion from a 4D vector.
				///
				///# Preconditions
				///
				///This function does not check if the input is normalized, it is up to the user to
				///provide normalized input or to normalized the resulting quaternion.
				from_vec4(LuaVec4) -> LuaQuat,

				///Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
				///The axis must be normalized (unit-length).
				///
				///# Panics
				///
				///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				from_axis_angle(LuaVec3,f32) -> LuaQuat,

				///Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
				///
				///`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
				from_scaled_axis(LuaVec3) -> LuaQuat,

				///Creates a quaternion from the `angle` (in radians) around the x axis.
				from_rotation_x(f32) -> LuaQuat,

				///Creates a quaternion from the `angle` (in radians) around the y axis.
				from_rotation_y(f32) -> LuaQuat,

				///Creates a quaternion from the `angle` (in radians) around the z axis.
				from_rotation_z(f32) -> LuaQuat,

				///Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
				from_euler(LuaEulerRot,f32,f32,f32) -> LuaQuat,

				///Creates a quaternion from a 3x3 rotation matrix.
				from_mat3(&LuaMat3) -> LuaQuat,

				///Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.
				from_mat4(&LuaMat4) -> LuaQuat,

				///Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
				///plane spanned by the two vectors.  Will rotate at most 180 degrees.
				///
				///The input vectors must be normalized (unit-length).
				///
				///`from_rotation_arc(from, to) * from ≈ to`.
				///
				///For near-singular cases (from≈to and from≈-to) the current implementation
				///is only accurate to about 0.001 (for `f32`).
				///
				///# Panics
				///
				///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				from_rotation_arc(LuaVec3,LuaVec3) -> LuaQuat,

				///Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
				///that the resulting quaternion will rotate `from` so that it is colinear with `to`.
				///
				///The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
				///degrees.
				///
				///The input vectors must be normalized (unit-length).
				///
				///`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
				///
				///# Panics
				///
				///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				from_rotation_arc_colinear(LuaVec3,LuaVec3) -> LuaQuat,

				///Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
				///around the z axis. Will rotate at most 180 degrees.
				///
				///The input vectors must be normalized (unit-length).
				///
				///`from_rotation_arc_2d(from, to) * from ≈ to`.
				///
				///For near-singular cases (from≈to and from≈-to) the current implementation
				///is only accurate to about 0.001 (for `f32`).
				///
				///# Panics
				///
				///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				from_rotation_arc_2d(LuaVec2,LuaVec2) -> LuaQuat,

				///Returns the rotation axis scaled by the rotation in radians.
				to_scaled_axis(self) -> LuaVec3,

				///Returns the vector part of the quaternion.
				xyz(self) -> LuaVec3,

				///Returns the quaternion conjugate of `self`. For a unit quaternion the
				///conjugate is also the inverse.
				conjugate(self) -> LuaQuat,

				///Returns the inverse of a normalized quaternion.
				///
				///Typically quaternion inverse returns the conjugate of a normalized quaternion.
				///Because `self` is assumed to already be unit length this method *does not* normalize
				///before returning the conjugate.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				inverse(self) -> LuaQuat,

				///Computes the dot product of `self` and `rhs`. The dot product is
				///equal to the cosine of the angle between two quaternion rotations.
				dot(self,LuaQuat) -> f32,

				///Computes the length of `self`.
				length(self) -> f32,

				///Computes the squared length of `self`.
				///
				///This is generally faster than `length()` as it avoids a square
				///root operation.
				length_squared(self) -> f32,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f32,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero.
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaQuat,

				///Returns `true` if, and only if, all elements are finite.
				///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				is_nan(self) -> bool,

				///Returns whether `self` of length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				is_near_identity(self) -> bool,

				///Returns the angle (in radians) for the minimal rotation
				///for transforming this quaternion into another.
				///
				///Both quaternions must be normalized.
				///
				///# Panics
				///
				///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				angle_between(self,LuaQuat) -> f32,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two quaternions contain similar elements. It works
				///best when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaQuat,f32) -> bool,

				///Performs a linear interpolation between `self` and `rhs` based on
				///the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s`
				///is `1.0`, the result will be equal to `rhs`.
				///
				///# Panics
				///
				///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
				lerp(self,LuaQuat,f32) -> LuaQuat,

				///Performs a spherical linear interpolation between `self` and `end`
				///based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s`
				///is `1.0`, the result will be equal to `end`.
				///
				///# Panics
				///
				///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
				slerp(self,LuaQuat,f32) -> LuaQuat,

				///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				mul_vec3(self,LuaVec3) -> LuaVec3,

				///Multiplies two quaternions. If they each represent a rotation, the result will
				///represent the combined rotation.
				///
				///Note that due to floating point rounding the result may not be perfectly normalized.
				///
				///# Panics
				///
				///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				mul_quat(self,LuaQuat) -> LuaQuat,

				///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				mul_vec3a(self,LuaVec3A) -> LuaVec3A,

				as_f64(self) -> LuaDQuat,

			)
			+ BinOps
			(
				self Add LuaQuat -> LuaQuat,
				self Sub LuaQuat -> LuaQuat,
				self Div f32 -> LuaQuat,
				self Mul f32 -> LuaQuat,
				self Mul LuaQuat -> LuaQuat,
				self Mul LuaVec3 -> LuaVec3,
				self Mul LuaVec3A -> LuaVec3A,
			)
			+ UnaryOps
			(
				Neg self
			)
			impl
			{
			}
		}
,		{
			///A quaternion representing an orientation.
			///
			///This quaternion is intended to be of unit length but may denormalize due to
			///floating point "error creep" which can occur when successive quaternion
			///operations are applied.
			glam::f64::dquat::DQuat : Value
			: Fields
			(
				x: f64,
				y: f64,
				z: f64,
				w: f64,
			)
			+ AutoMethods
			(
				///Creates a new rotation quaternion.
				///
				///This should generally not be called manually unless you know what you are doing.
				///Use one of the other constructors instead such as `identity` or `from_axis_angle`.
				///
				///`from_xyzw` is mostly used by unit tests and `serde` deserialization.
				///
				///# Preconditions
				///
				///This function does not check if the input is normalized, it is up to the user to
				///provide normalized input or to normalized the resulting quaternion.
				from_xyzw(f64,f64,f64,f64) -> LuaDQuat,

				///Creates a new rotation quaternion from a 4D vector.
				///
				///# Preconditions
				///
				///This function does not check if the input is normalized, it is up to the user to
				///provide normalized input or to normalized the resulting quaternion.
				from_vec4(LuaDVec4) -> LuaDQuat,

				///Create a quaternion for a normalized rotation `axis` and `angle` (in radians).
				///The axis must be normalized (unit-length).
				///
				///# Panics
				///
				///Will panic if `axis` is not normalized when `glam_assert` is enabled.
				from_axis_angle(LuaDVec3,f64) -> LuaDQuat,

				///Create a quaternion that rotates `v.length()` radians around `v.normalize()`.
				///
				///`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.
				from_scaled_axis(LuaDVec3) -> LuaDQuat,

				///Creates a quaternion from the `angle` (in radians) around the x axis.
				from_rotation_x(f64) -> LuaDQuat,

				///Creates a quaternion from the `angle` (in radians) around the y axis.
				from_rotation_y(f64) -> LuaDQuat,

				///Creates a quaternion from the `angle` (in radians) around the z axis.
				from_rotation_z(f64) -> LuaDQuat,

				///Creates a quaternion from the given Euler rotation sequence and the angles (in radians).
				from_euler(LuaEulerRot,f64,f64,f64) -> LuaDQuat,

				///Creates a quaternion from a 3x3 rotation matrix.
				from_mat3(&LuaDMat3) -> LuaDQuat,

				///Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.
				from_mat4(&LuaDMat4) -> LuaDQuat,

				///Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
				///plane spanned by the two vectors.  Will rotate at most 180 degrees.
				///
				///The input vectors must be normalized (unit-length).
				///
				///`from_rotation_arc(from, to) * from ≈ to`.
				///
				///For near-singular cases (from≈to and from≈-to) the current implementation
				///is only accurate to about 0.001 (for `f32`).
				///
				///# Panics
				///
				///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				from_rotation_arc(LuaDVec3,LuaDVec3) -> LuaDQuat,

				///Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means
				///that the resulting quaternion will rotate `from` so that it is colinear with `to`.
				///
				///The rotation is in the plane spanned by the two vectors.  Will rotate at most 90
				///degrees.
				///
				///The input vectors must be normalized (unit-length).
				///
				///`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.
				///
				///# Panics
				///
				///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				from_rotation_arc_colinear(LuaDVec3,LuaDVec3) -> LuaDQuat,

				///Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is
				///around the z axis. Will rotate at most 180 degrees.
				///
				///The input vectors must be normalized (unit-length).
				///
				///`from_rotation_arc_2d(from, to) * from ≈ to`.
				///
				///For near-singular cases (from≈to and from≈-to) the current implementation
				///is only accurate to about 0.001 (for `f32`).
				///
				///# Panics
				///
				///Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.
				from_rotation_arc_2d(LuaDVec2,LuaDVec2) -> LuaDQuat,

				///Returns the rotation axis scaled by the rotation in radians.
				to_scaled_axis(self) -> LuaDVec3,

				///Returns the vector part of the quaternion.
				xyz(self) -> LuaDVec3,

				///Returns the quaternion conjugate of `self`. For a unit quaternion the
				///conjugate is also the inverse.
				conjugate(self) -> LuaDQuat,

				///Returns the inverse of a normalized quaternion.
				///
				///Typically quaternion inverse returns the conjugate of a normalized quaternion.
				///Because `self` is assumed to already be unit length this method *does not* normalize
				///before returning the conjugate.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				inverse(self) -> LuaDQuat,

				///Computes the dot product of `self` and `rhs`. The dot product is
				///equal to the cosine of the angle between two quaternion rotations.
				dot(self,LuaDQuat) -> f64,

				///Computes the length of `self`.
				length(self) -> f64,

				///Computes the squared length of `self`.
				///
				///This is generally faster than `length()` as it avoids a square
				///root operation.
				length_squared(self) -> f64,

				///Computes `1.0 / length()`.
				///
				///For valid results, `self` must _not_ be of length zero.
				length_recip(self) -> f64,

				///Returns `self` normalized to length 1.0.
				///
				///For valid results, `self` must _not_ be of length zero.
				///
				///Panics
				///
				///Will panic if `self` is zero length when `glam_assert` is enabled.
				normalize(self) -> LuaDQuat,

				///Returns `true` if, and only if, all elements are finite.
				///If any element is either `NaN`, positive or negative infinity, this will return `false`.
				is_finite(self) -> bool,

				is_nan(self) -> bool,

				///Returns whether `self` of length `1.0` or not.
				///
				///Uses a precision threshold of `1e-6`.
				is_normalized(self) -> bool,

				is_near_identity(self) -> bool,

				///Returns the angle (in radians) for the minimal rotation
				///for transforming this quaternion into another.
				///
				///Both quaternions must be normalized.
				///
				///# Panics
				///
				///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				angle_between(self,LuaDQuat) -> f64,

				///Returns true if the absolute difference of all elements between `self` and `rhs`
				///is less than or equal to `max_abs_diff`.
				///
				///This can be used to compare if two quaternions contain similar elements. It works
				///best when comparing with a known value. The `max_abs_diff` that should be used used
				///depends on the values being compared against.
				///
				///For more see
				///[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).
				abs_diff_eq(self,LuaDQuat,f64) -> bool,

				///Performs a linear interpolation between `self` and `rhs` based on
				///the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s`
				///is `1.0`, the result will be equal to `rhs`.
				///
				///# Panics
				///
				///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
				lerp(self,LuaDQuat,f64) -> LuaDQuat,

				///Performs a spherical linear interpolation between `self` and `end`
				///based on the value `s`.
				///
				///When `s` is `0.0`, the result will be equal to `self`.  When `s`
				///is `1.0`, the result will be equal to `end`.
				///
				///# Panics
				///
				///Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.
				slerp(self,LuaDQuat,f64) -> LuaDQuat,

				///Multiplies a quaternion and a 3D vector, returning the rotated vector.
				///
				///# Panics
				///
				///Will panic if `self` is not normalized when `glam_assert` is enabled.
				mul_vec3(self,LuaDVec3) -> LuaDVec3,

				///Multiplies two quaternions. If they each represent a rotation, the result will
				///represent the combined rotation.
				///
				///Note that due to floating point rounding the result may not be perfectly normalized.
				///
				///# Panics
				///
				///Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.
				mul_quat(self,LuaDQuat) -> LuaDQuat,

				as_f32(self) -> LuaQuat,

			)
			+ BinOps
			(
				self Add LuaDQuat -> LuaDQuat,
				self Sub LuaDQuat -> LuaDQuat,
				self Div f64 -> LuaDQuat,
				self Mul f64 -> LuaDQuat,
				self Mul LuaDQuat -> LuaDQuat,
				self Mul LuaDVec3 -> LuaDVec3,
			)
			+ UnaryOps
			(
				Neg self
			)
			impl
			{
			}
		}
,		{
			///Euler rotation sequences.
			///
			///The angles are applied starting from the right.
			///E.g. XYZ will first apply the z-axis rotation.
			///
			///YXZ can be used for yaw (y-axis), pitch (x-axis), roll (z-axis).
			///
			///The two-axis rotations (e.g. ZYZ) are not fully tested and have to be treated with caution.
			glam::euler::EulerRot : Value
			: Fields
			(
			)
			+ AutoMethods
			(
			)
			+ BinOps
			(
			)
			+ UnaryOps
			(
			)
			impl
			{
			}
		}
,	]
)
;
