pub mod generated {
    #![allow(unused_variables, unused_parens)]
    use bevy::prelude::*;
    use bevy::math::*;
    use std::sync::Weak;
    use std::ops::*;
    use phf::{phf_map, Map};
    use crate::LuaFile;
    use crate::LuaRefBase;
    use crate::ReflectPtr;
    use crate::Script;
    use crate::ScriptCollection;
    use crate::LuaRef;
    use crate::get_type_data;
    use crate::{LuaComponent, LuaResource, LuaWorld};
    use std::sync::Arc;
    use parking_lot::RwLock;
    use crate::util::impl_tealr_type;
    use num_traits::cast::ToPrimitive;
    use bevy_mod_scripting_derive::{impl_lua_newtypes, replace};
    use tealr::{
        mlu::{
            mlua,
            mlua::{prelude::*, Error, MetaMethod, Value},
        },
        create_union_mlua,
    };
    pub type LuaEntity = crate::LuaWrapper<Entity>;
    impl tealr::mlu::TealData for LuaEntity {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Lightweight identifier of an [entity](crate::entity).");
            methods.document_type("");
            methods . document_type ("The identifier is implemented using a [generational index]: a combination of an ID and a generation.") ;
            methods . document_type ("This allows fast insertion after data removal in an array while minimizing loss of spatial locality.") ;
            methods.document_type("");
            methods . document_type ("[generational index]: https://lucassardois.medium.com/generational-indices-guide-8e3c5f7fd594") ;
            methods.document_type("");
            methods.document_type("# Usage");
            methods.document_type("");
            methods . document_type ("This data type is returned by iterating a `Query` that has `Entity` as part of its query fetch type parameter ([learn more]).") ;
            methods.document_type(
                "It can also be obtained by calling [`EntityCommands::id`] or [`EntityMut::id`].",
            );
            methods.document_type("");
            methods.document_type("```");
            methods.document_type("# use bevy_ecs::prelude::*;");
            methods.document_type("#");
            methods.document_type("fn setup(mut commands: Commands) {");
            methods.document_type("    // Calling `spawn` returns `EntityCommands`.");
            methods.document_type("    let entity = commands.spawn().id();");
            methods.document_type("}");
            methods.document_type("");
            methods.document_type("fn exclusive_system(world: &mut World) {");
            methods.document_type("    // Calling `spawn` returns `EntityMut`.");
            methods.document_type("    let entity = world.spawn().id();");
            methods.document_type("}");
            methods.document_type("#");
            methods.document_type("# bevy_ecs::system::assert_is_system(setup);");
            methods.document_type(
                "# bevy_ecs::system::IntoExclusiveSystem::exclusive_system(exclusive_system);",
            );
            methods.document_type("```");
            methods.document_type("");
            methods . document_type ("It can be used to refer to a specific entity to apply [`EntityCommands`], or to call [`Query::get`] (or similar methods) to access its components.") ;
            methods.document_type("");
            methods.document_type("```");
            methods.document_type("# use bevy_ecs::prelude::*;");
            methods.document_type("#");
            methods.document_type("# #[derive(Component)]");
            methods.document_type("# struct Expired;");
            methods.document_type("#");
            methods . document_type ("fn dispose_expired_food(mut commands: Commands, query: Query<Entity, With<Expired>>) {") ;
            methods.document_type("    for food_entity in query.iter() {");
            methods.document_type("        commands.entity(food_entity).despawn();");
            methods.document_type("    }");
            methods.document_type("}");
            methods.document_type("#");
            methods.document_type("# bevy_ecs::system::assert_is_system(dispose_expired_food);");
            methods.document_type("```");
            methods.document_type("");
            methods.document_type("[learn more]: crate::system::Query#entity-id-access");
            methods.document_type("[`EntityCommands::id`]: crate::system::EntityCommands::id");
            methods.document_type("[`EntityMut::id`]: crate::world::EntityMut::id");
            methods.document_type("[`EntityCommands`]: crate::system::EntityCommands");
            methods.document_type("[`Query::get`]: crate::system::Query::get");
            methods.document("Convert to a form convenient for passing outside of rust.");
            methods.document("");
            methods . document ("Only useful for identifying entities within the same instance of an application. Do not use") ;
            methods.document("for serialization between runs.");
            methods.document("");
            methods.document("No particular structure is guaranteed for the returned bits.");
            methods.add_method("to_bits", |_, s, a: ()| Ok(s.inner().to_bits()));
            methods.document("Return a transiently unique identifier.");
            methods.document("");
            methods . document ("No two simultaneously-live entities share the same ID, but dead entities\' IDs may collide") ;
            methods . document ("with both live and dead entities. Useful for compactly representing entities within a") ;
            methods.document("specific snapshot of the world, such as when serializing.");
            methods.add_method("id", |_, s, a: ()| Ok(s.inner().id()));
            methods . document ("Returns the generation of this Entity\'s id. The generation is incremented each time an") ;
            methods . document ("entity with a given id is despawned. This serves as a \"count\" of the number of times a") ;
            methods.document(
                "given id has been reused (id, generation) pairs uniquely identify a given Entity.",
            );
            methods.add_method("generation", |_, s, a: ()| Ok(s.inner().generation()));
        }
    }
    impl tealr::TypeName for LuaEntity {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaEntity"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaEntity {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaEntity {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaVec2 = crate::LuaWrapper<Vec2>;
    impl tealr::mlu::TealData for LuaVec2 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 2-dimensional vector.");
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaVec2::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.add((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaVec2f32::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.inner()).add(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.sub((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaVec2f32::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.inner()).sub(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.div((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaVec2f32::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.inner()).div(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.mul((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaVec2f32::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.inner()).mul(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.rem((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaVec2f32::f32(v) => {
                                return Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.inner()).rem(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Creates a 3D vector from `self` and the given `z` value.");
            methods.add_method("extend", |_, s, a: (f32)| {
                Ok(LuaVec3::new(s.inner().extend(a)))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaVec2)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaVec2)| {
                Ok(LuaVec2::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaVec2)| {
                Ok(LuaVec2::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaVec2, LuaVec2)| {
                Ok(LuaVec2::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaVec2::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| Ok(LuaVec2::new(s.inner().signum())));
            methods.document("Returns a vector that is equal to `self` rotated by 90 degrees.");
            methods.add_method("perp", |_, s, a: ()| Ok(LuaVec2::new(s.inner().perp())));
            methods.document("The perpendicular dot product of `self` and `other`.");
            methods.document("Also known as the wedge product, 2d cross product, and determinant.");
            methods.add_method("perp_dot", |_, s, a: (LuaVec2)| {
                Ok(s.inner().perp_dot(a.inner()))
            });
            methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
            methods.document("`NaN`, positive or negative infinity, this will return `false`.");
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Computes the length of `self`.");
            methods.add_method("length", |_, s, a: ()| Ok(s.inner().length()));
            methods.document("Computes the squared length of `self`.");
            methods.document("");
            methods
                .document("This is faster than `length()` as it avoids a square root operation.");
            methods.add_method("length_squared", |_, s, a: ()| {
                Ok(s.inner().length_squared())
            });
            methods.document("Computes `1.0 / length()`.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.add_method("length_recip", |_, s, a: ()| Ok(s.inner().length_recip()));
            methods.document("Computes the Euclidean distance between two points in space.");
            methods.add_method("distance", |_, s, a: (LuaVec2)| {
                Ok(s.inner().distance(a.inner()))
            });
            methods.document("Compute the squared euclidean distance between two points in space.");
            methods.add_method("distance_squared", |_, s, a: (LuaVec2)| {
                Ok(s.inner().distance_squared(a.inner()))
            });
            methods.document("Returns `self` normalized to length 1.0.");
            methods.document("");
            methods.document(
                "For valid results, `self` must _not_ be of length zero, nor very close to zero.",
            );
            methods.document("");
            methods.document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
            methods.document("");
            methods.document("Panics");
            methods.document("");
            methods.document("Will panic if `self` is zero length when `glam_assert` is enabled.");
            methods.add_method("normalize", |_, s, a: ()| {
                Ok(LuaVec2::new(s.inner().normalize()))
            });
            methods.document(
                "Returns `self` normalized to length 1.0 if possible, else returns zero.",
            );
            methods.document("");
            methods.document(
                "In particular, if the input is zero (or very close to zero), or non-finite,",
            );
            methods.document("the result of this operation will be zero.");
            methods.document("");
            methods.document("See also [`Self::try_normalize`].");
            methods.add_method("normalize_or_zero", |_, s, a: ()| {
                Ok(LuaVec2::new(s.inner().normalize_or_zero()))
            });
            methods.document("Returns whether `self` is length `1.0` or not.");
            methods.document("");
            methods.document("Uses a precision threshold of `1e-6`.");
            methods.add_method("is_normalized", |_, s, a: ()| Ok(s.inner().is_normalized()));
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `other` is zero length when `glam_assert` is enabled.");
            methods.add_method("project_onto", |_, s, a: (LuaVec2)| {
                Ok(LuaVec2::new(s.inner().project_onto(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `other` has a length of zero when `glam_assert` is enabled.",
            );
            methods.add_method("reject_from", |_, s, a: (LuaVec2)| {
                Ok(LuaVec2::new(s.inner().reject_from(a.inner())))
            });
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("project_onto_normalized", |_, s, a: (LuaVec2)| {
                Ok(LuaVec2::new(s.inner().project_onto_normalized(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("reject_from_normalized", |_, s, a: (LuaVec2)| {
                Ok(LuaVec2::new(s.inner().reject_from_normalized(a.inner())))
            });
            methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
            methods.document("Round half-way cases away from 0.0.");
            methods.add_method("round", |_, s, a: ()| Ok(LuaVec2::new(s.inner().round())));
            methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
            methods.document("element of `self`.");
            methods.add_method("floor", |_, s, a: ()| Ok(LuaVec2::new(s.inner().floor())));
            methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
            methods.document("each element of `self`.");
            methods.add_method("ceil", |_, s, a: ()| Ok(LuaVec2::new(s.inner().ceil())));
            methods.document(
                "Returns a vector containing the fractional part of the vector, e.g. `self -",
            );
            methods.document("self.floor()`.");
            methods.document("");
            methods.document("Note that this is fast but not precise for large numbers.");
            methods.add_method("fract", |_, s, a: ()| Ok(LuaVec2::new(s.inner().fract())));
            methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
            methods.document("`self`.");
            methods.add_method("exp", |_, s, a: ()| Ok(LuaVec2::new(s.inner().exp())));
            methods.document(
                "Returns a vector containing each element of `self` raised to the power of `n`.",
            );
            methods.add_method("powf", |_, s, a: (f32)| Ok(LuaVec2::new(s.inner().powf(a))));
            methods.document(
                "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
            );
            methods.add_method("recip", |_, s, a: ()| Ok(LuaVec2::new(s.inner().recip())));
            methods . document ("Performs a linear interpolation between `self` and `other` based on the value `s`.") ;
            methods.document("");
            methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
            methods . document ("will be equal to `other`. When `s` is outside of range [0,1], the result is linearly") ;
            methods.document("extrapolated.");
            methods.add_method("lerp", |_, s, a: (LuaVec2, f32)| {
                Ok(LuaVec2::new(s.inner().lerp(a.0.inner(), a.1)))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other` is") ;
            methods.document("less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
            methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
            methods.document("the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaVec2, f32)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.document(
                "Returns a vector with a length no less than `min` and no more than `max`",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp_length", |_, s, a: (f32, f32)| {
                Ok(LuaVec2::new(s.inner().clamp_length(a.0, a.1)))
            });
            methods.document("Returns a vector with a length no more than `max`");
            methods.add_method("clamp_length_max", |_, s, a: (f32)| {
                Ok(LuaVec2::new(s.inner().clamp_length_max(a)))
            });
            methods.document("Returns a vector with a length no less than `min`");
            methods.add_method("clamp_length_min", |_, s, a: (f32)| {
                Ok(LuaVec2::new(s.inner().clamp_length_min(a)))
            });
            methods.document(
                "Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding",
            );
            methods
                .document("error, yielding a more accurate result than an unfused multiply-add.");
            methods.document("");
            methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
            methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
            methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
            methods.document("mind.");
            methods.add_method("mul_add", |_, s, a: (LuaVec2, LuaVec2)| {
                Ok(LuaVec2::new(s.inner().mul_add(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the angle (in radians) between `self` and `other`.");
            methods.document("");
            methods.document(
                "The input vectors do not need to be unit length however they must be non-zero.",
            );
            methods.add_method("angle_between", |_, s, a: (LuaVec2)| {
                Ok(s.inner().angle_between(a.inner()))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec2", |_, s, a: ()| {
                Ok(LuaDVec2::new(s.inner().as_dvec2()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec2", |_, s, a: ()| {
                Ok(LuaIVec2::new(s.inner().as_ivec2()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec2", |_, s, a: ()| {
                Ok(LuaUVec2::new(s.inner().as_uvec2()))
            });
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
        }
    }
    impl tealr::TypeName for LuaVec2 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaVec2"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaVec2 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaVec2 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaVec3 = crate::LuaWrapper<Vec3>;
    impl tealr::mlu::TealData for LuaVec3 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 3-dimensional vector without SIMD support.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaVec3::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.add((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaVec3f32::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.inner()).add(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.sub((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaVec3f32::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.inner()).sub(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.div((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaVec3f32::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.inner()).div(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.mul((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaVec3f32::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.inner()).mul(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.rem((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaVec3f32::f32(v) => {
                                return Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.inner()).rem(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Creates a 4D vector from `self` and the given `w` value.");
            methods.add_method("extend", |_, s, a: (f32)| {
                Ok(LuaVec4::new(s.inner().extend(a)))
            });
            methods.document(
                "Creates a `Vec2` from the `x` and `y` elements of `self`, discarding `z`.",
            );
            methods.document("");
            methods.document(
                "Truncation may also be performed by using `self.xy()` or `Vec2::from()`.",
            );
            methods.add_method("truncate", |_, s, a: ()| {
                Ok(LuaVec2::new(s.inner().truncate()))
            });
            methods.document("Computes the cross product of `self` and `other`.");
            methods.add_method("cross", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().cross(a.inner())))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaVec3)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaVec3, LuaVec3)| {
                Ok(LuaVec3::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaVec3::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| Ok(LuaVec3::new(s.inner().signum())));
            methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
            methods.document("`NaN`, positive or negative infinity, this will return `false`.");
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Computes the length of `self`.");
            methods.add_method("length", |_, s, a: ()| Ok(s.inner().length()));
            methods.document("Computes the squared length of `self`.");
            methods.document("");
            methods
                .document("This is faster than `length()` as it avoids a square root operation.");
            methods.add_method("length_squared", |_, s, a: ()| {
                Ok(s.inner().length_squared())
            });
            methods.document("Computes `1.0 / length()`.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.add_method("length_recip", |_, s, a: ()| Ok(s.inner().length_recip()));
            methods.document("Computes the Euclidean distance between two points in space.");
            methods.add_method("distance", |_, s, a: (LuaVec3)| {
                Ok(s.inner().distance(a.inner()))
            });
            methods.document("Compute the squared euclidean distance between two points in space.");
            methods.add_method("distance_squared", |_, s, a: (LuaVec3)| {
                Ok(s.inner().distance_squared(a.inner()))
            });
            methods.document("Returns `self` normalized to length 1.0.");
            methods.document("");
            methods.document(
                "For valid results, `self` must _not_ be of length zero, nor very close to zero.",
            );
            methods.document("");
            methods.document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
            methods.document("");
            methods.document("Panics");
            methods.document("");
            methods.document("Will panic if `self` is zero length when `glam_assert` is enabled.");
            methods.add_method("normalize", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().normalize()))
            });
            methods.document(
                "Returns `self` normalized to length 1.0 if possible, else returns zero.",
            );
            methods.document("");
            methods.document(
                "In particular, if the input is zero (or very close to zero), or non-finite,",
            );
            methods.document("the result of this operation will be zero.");
            methods.document("");
            methods.document("See also [`Self::try_normalize`].");
            methods.add_method("normalize_or_zero", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().normalize_or_zero()))
            });
            methods.document("Returns whether `self` is length `1.0` or not.");
            methods.document("");
            methods.document("Uses a precision threshold of `1e-6`.");
            methods.add_method("is_normalized", |_, s, a: ()| Ok(s.inner().is_normalized()));
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `other` is zero length when `glam_assert` is enabled.");
            methods.add_method("project_onto", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().project_onto(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `other` has a length of zero when `glam_assert` is enabled.",
            );
            methods.add_method("reject_from", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().reject_from(a.inner())))
            });
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("project_onto_normalized", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().project_onto_normalized(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("reject_from_normalized", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().reject_from_normalized(a.inner())))
            });
            methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
            methods.document("Round half-way cases away from 0.0.");
            methods.add_method("round", |_, s, a: ()| Ok(LuaVec3::new(s.inner().round())));
            methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
            methods.document("element of `self`.");
            methods.add_method("floor", |_, s, a: ()| Ok(LuaVec3::new(s.inner().floor())));
            methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
            methods.document("each element of `self`.");
            methods.add_method("ceil", |_, s, a: ()| Ok(LuaVec3::new(s.inner().ceil())));
            methods.document(
                "Returns a vector containing the fractional part of the vector, e.g. `self -",
            );
            methods.document("self.floor()`.");
            methods.document("");
            methods.document("Note that this is fast but not precise for large numbers.");
            methods.add_method("fract", |_, s, a: ()| Ok(LuaVec3::new(s.inner().fract())));
            methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
            methods.document("`self`.");
            methods.add_method("exp", |_, s, a: ()| Ok(LuaVec3::new(s.inner().exp())));
            methods.document(
                "Returns a vector containing each element of `self` raised to the power of `n`.",
            );
            methods.add_method("powf", |_, s, a: (f32)| Ok(LuaVec3::new(s.inner().powf(a))));
            methods.document(
                "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
            );
            methods.add_method("recip", |_, s, a: ()| Ok(LuaVec3::new(s.inner().recip())));
            methods . document ("Performs a linear interpolation between `self` and `other` based on the value `s`.") ;
            methods.document("");
            methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
            methods . document ("will be equal to `other`. When `s` is outside of range [0,1], the result is linearly") ;
            methods.document("extrapolated.");
            methods.add_method("lerp", |_, s, a: (LuaVec3, f32)| {
                Ok(LuaVec3::new(s.inner().lerp(a.0.inner(), a.1)))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other` is") ;
            methods.document("less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
            methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
            methods.document("the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaVec3, f32)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.document(
                "Returns a vector with a length no less than `min` and no more than `max`",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp_length", |_, s, a: (f32, f32)| {
                Ok(LuaVec3::new(s.inner().clamp_length(a.0, a.1)))
            });
            methods.document("Returns a vector with a length no more than `max`");
            methods.add_method("clamp_length_max", |_, s, a: (f32)| {
                Ok(LuaVec3::new(s.inner().clamp_length_max(a)))
            });
            methods.document("Returns a vector with a length no less than `min`");
            methods.add_method("clamp_length_min", |_, s, a: (f32)| {
                Ok(LuaVec3::new(s.inner().clamp_length_min(a)))
            });
            methods.document(
                "Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding",
            );
            methods
                .document("error, yielding a more accurate result than an unfused multiply-add.");
            methods.document("");
            methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
            methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
            methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
            methods.document("mind.");
            methods.add_method("mul_add", |_, s, a: (LuaVec3, LuaVec3)| {
                Ok(LuaVec3::new(s.inner().mul_add(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the angle (in radians) between two vectors.");
            methods.document("");
            methods.document(
                "The input vectors do not need to be unit length however they must be non-zero.",
            );
            methods.add_method("angle_between", |_, s, a: (LuaVec3)| {
                Ok(s.inner().angle_between(a.inner()))
            });
            methods.document("Returns some vector that is orthogonal to the given one.");
            methods.document("");
            methods.document("The input vector must be finite and non-zero.");
            methods.document("");
            methods.document("The output vector is not necessarily unit-length.");
            methods.document("For that use [`Self::any_orthonormal_vector`] instead.");
            methods.add_method("any_orthogonal_vector", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().any_orthogonal_vector()))
            });
            methods.document("Returns any unit-length vector that is orthogonal to the given one.");
            methods.document("The input vector must be finite and non-zero.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `self` is not normalized when `glam_assert` is enabled.");
            methods.add_method("any_orthonormal_vector", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().any_orthonormal_vector()))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec3", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().as_dvec3()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec3", |_, s, a: ()| {
                Ok(LuaIVec3::new(s.inner().as_ivec3()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec3", |_, s, a: ()| {
                Ok(LuaUVec3::new(s.inner().as_uvec3()))
            });
        }
    }
    impl tealr::TypeName for LuaVec3 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaVec3"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaVec3 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaVec3 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaVec4 = crate::LuaWrapper<Vec4>;
    impl tealr::mlu::TealData for LuaVec4 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 4-dimensional vector.");
            methods.document_type("");
            methods . document_type ("This type uses 16 byte aligned SIMD vector type for storage on supported platforms.") ;
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaVec4::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.add((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaVec4f32::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.inner()).add(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.sub((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaVec4f32::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.inner()).sub(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.div((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaVec4f32::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.inner()).div(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.mul((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaVec4f32::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.inner()).mul(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.rem((ud.inner())))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaVec4f32::f32(v) => {
                                return Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.inner()).rem(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document(
                "Creates a `Vec3` from the `x`, `y` and `z` elements of `self`, discarding `w`.",
            );
            methods.document("");
            methods . document ("Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.") ;
            methods.document("");
            methods.document("To truncate to `Vec3A` use `Vec3A::from()`.");
            methods.add_method("truncate", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().truncate()))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaVec4)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaVec4)| {
                Ok(LuaVec4::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaVec4)| {
                Ok(LuaVec4::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaVec4, LuaVec4)| {
                Ok(LuaVec4::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaVec4::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| Ok(LuaVec4::new(s.inner().signum())));
            methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
            methods.document("`NaN`, positive or negative infinity, this will return `false`.");
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Computes the length of `self`.");
            methods.add_method("length", |_, s, a: ()| Ok(s.inner().length()));
            methods.document("Computes the squared length of `self`.");
            methods.document("");
            methods
                .document("This is faster than `length()` as it avoids a square root operation.");
            methods.add_method("length_squared", |_, s, a: ()| {
                Ok(s.inner().length_squared())
            });
            methods.document("Computes `1.0 / length()`.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.add_method("length_recip", |_, s, a: ()| Ok(s.inner().length_recip()));
            methods.document("Computes the Euclidean distance between two points in space.");
            methods.add_method("distance", |_, s, a: (LuaVec4)| {
                Ok(s.inner().distance(a.inner()))
            });
            methods.document("Compute the squared euclidean distance between two points in space.");
            methods.add_method("distance_squared", |_, s, a: (LuaVec4)| {
                Ok(s.inner().distance_squared(a.inner()))
            });
            methods.document("Returns `self` normalized to length 1.0.");
            methods.document("");
            methods.document(
                "For valid results, `self` must _not_ be of length zero, nor very close to zero.",
            );
            methods.document("");
            methods.document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
            methods.document("");
            methods.document("Panics");
            methods.document("");
            methods.document("Will panic if `self` is zero length when `glam_assert` is enabled.");
            methods.add_method("normalize", |_, s, a: ()| {
                Ok(LuaVec4::new(s.inner().normalize()))
            });
            methods.document(
                "Returns `self` normalized to length 1.0 if possible, else returns zero.",
            );
            methods.document("");
            methods.document(
                "In particular, if the input is zero (or very close to zero), or non-finite,",
            );
            methods.document("the result of this operation will be zero.");
            methods.document("");
            methods.document("See also [`Self::try_normalize`].");
            methods.add_method("normalize_or_zero", |_, s, a: ()| {
                Ok(LuaVec4::new(s.inner().normalize_or_zero()))
            });
            methods.document("Returns whether `self` is length `1.0` or not.");
            methods.document("");
            methods.document("Uses a precision threshold of `1e-6`.");
            methods.add_method("is_normalized", |_, s, a: ()| Ok(s.inner().is_normalized()));
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `other` is zero length when `glam_assert` is enabled.");
            methods.add_method("project_onto", |_, s, a: (LuaVec4)| {
                Ok(LuaVec4::new(s.inner().project_onto(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `other` has a length of zero when `glam_assert` is enabled.",
            );
            methods.add_method("reject_from", |_, s, a: (LuaVec4)| {
                Ok(LuaVec4::new(s.inner().reject_from(a.inner())))
            });
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("project_onto_normalized", |_, s, a: (LuaVec4)| {
                Ok(LuaVec4::new(s.inner().project_onto_normalized(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("reject_from_normalized", |_, s, a: (LuaVec4)| {
                Ok(LuaVec4::new(s.inner().reject_from_normalized(a.inner())))
            });
            methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
            methods.document("Round half-way cases away from 0.0.");
            methods.add_method("round", |_, s, a: ()| Ok(LuaVec4::new(s.inner().round())));
            methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
            methods.document("element of `self`.");
            methods.add_method("floor", |_, s, a: ()| Ok(LuaVec4::new(s.inner().floor())));
            methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
            methods.document("each element of `self`.");
            methods.add_method("ceil", |_, s, a: ()| Ok(LuaVec4::new(s.inner().ceil())));
            methods.document(
                "Returns a vector containing the fractional part of the vector, e.g. `self -",
            );
            methods.document("self.floor()`.");
            methods.document("");
            methods.document("Note that this is fast but not precise for large numbers.");
            methods.add_method("fract", |_, s, a: ()| Ok(LuaVec4::new(s.inner().fract())));
            methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
            methods.document("`self`.");
            methods.add_method("exp", |_, s, a: ()| Ok(LuaVec4::new(s.inner().exp())));
            methods.document(
                "Returns a vector containing each element of `self` raised to the power of `n`.",
            );
            methods.add_method("powf", |_, s, a: (f32)| Ok(LuaVec4::new(s.inner().powf(a))));
            methods.document(
                "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
            );
            methods.add_method("recip", |_, s, a: ()| Ok(LuaVec4::new(s.inner().recip())));
            methods . document ("Performs a linear interpolation between `self` and `other` based on the value `s`.") ;
            methods.document("");
            methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
            methods . document ("will be equal to `other`. When `s` is outside of range [0,1], the result is linearly") ;
            methods.document("extrapolated.");
            methods.add_method("lerp", |_, s, a: (LuaVec4, f32)| {
                Ok(LuaVec4::new(s.inner().lerp(a.0.inner(), a.1)))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other` is") ;
            methods.document("less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
            methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
            methods.document("the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaVec4, f32)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.document(
                "Returns a vector with a length no less than `min` and no more than `max`",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp_length", |_, s, a: (f32, f32)| {
                Ok(LuaVec4::new(s.inner().clamp_length(a.0, a.1)))
            });
            methods.document("Returns a vector with a length no more than `max`");
            methods.add_method("clamp_length_max", |_, s, a: (f32)| {
                Ok(LuaVec4::new(s.inner().clamp_length_max(a)))
            });
            methods.document("Returns a vector with a length no less than `min`");
            methods.add_method("clamp_length_min", |_, s, a: (f32)| {
                Ok(LuaVec4::new(s.inner().clamp_length_min(a)))
            });
            methods.document(
                "Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding",
            );
            methods
                .document("error, yielding a more accurate result than an unfused multiply-add.");
            methods.document("");
            methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
            methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
            methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
            methods.document("mind.");
            methods.add_method("mul_add", |_, s, a: (LuaVec4, LuaVec4)| {
                Ok(LuaVec4::new(s.inner().mul_add(a.0.inner(), a.1.inner())))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec4", |_, s, a: ()| {
                Ok(LuaDVec4::new(s.inner().as_dvec4()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec4", |_, s, a: ()| {
                Ok(LuaIVec4::new(s.inner().as_ivec4()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec4", |_, s, a: ()| {
                Ok(LuaUVec4::new(s.inner().as_uvec4()))
            });
        }
    }
    impl tealr::TypeName for LuaVec4 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaVec4"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaVec4 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaVec4 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaDVec2 = crate::LuaWrapper<DVec2>;
    impl tealr::mlu::TealData for LuaDVec2 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 2-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f64)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaDVec2::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaDVec2f64::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaDVec2f64::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaDVec2f64::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaDVec2f64::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaDVec2f64::f64(v) => {
                                return Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Creates a 3D vector from `self` and the given `z` value.");
            methods.add_method("extend", |_, s, a: (f64)| {
                Ok(LuaDVec3::new(s.inner().extend(a)))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaDVec2)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaDVec2, LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaDVec2::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| {
                Ok(LuaDVec2::new(s.inner().signum()))
            });
            methods.document("Returns a vector that is equal to `self` rotated by 90 degrees.");
            methods.add_method("perp", |_, s, a: ()| Ok(LuaDVec2::new(s.inner().perp())));
            methods.document("The perpendicular dot product of `self` and `other`.");
            methods.document("Also known as the wedge product, 2d cross product, and determinant.");
            methods.add_method("perp_dot", |_, s, a: (LuaDVec2)| {
                Ok(s.inner().perp_dot(a.inner()))
            });
            methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
            methods.document("`NaN`, positive or negative infinity, this will return `false`.");
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Computes the length of `self`.");
            methods.add_method("length", |_, s, a: ()| Ok(s.inner().length()));
            methods.document("Computes the squared length of `self`.");
            methods.document("");
            methods
                .document("This is faster than `length()` as it avoids a square root operation.");
            methods.add_method("length_squared", |_, s, a: ()| {
                Ok(s.inner().length_squared())
            });
            methods.document("Computes `1.0 / length()`.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.add_method("length_recip", |_, s, a: ()| Ok(s.inner().length_recip()));
            methods.document("Computes the Euclidean distance between two points in space.");
            methods.add_method("distance", |_, s, a: (LuaDVec2)| {
                Ok(s.inner().distance(a.inner()))
            });
            methods.document("Compute the squared euclidean distance between two points in space.");
            methods.add_method("distance_squared", |_, s, a: (LuaDVec2)| {
                Ok(s.inner().distance_squared(a.inner()))
            });
            methods.document("Returns `self` normalized to length 1.0.");
            methods.document("");
            methods.document(
                "For valid results, `self` must _not_ be of length zero, nor very close to zero.",
            );
            methods.document("");
            methods.document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
            methods.document("");
            methods.document("Panics");
            methods.document("");
            methods.document("Will panic if `self` is zero length when `glam_assert` is enabled.");
            methods.add_method("normalize", |_, s, a: ()| {
                Ok(LuaDVec2::new(s.inner().normalize()))
            });
            methods.document(
                "Returns `self` normalized to length 1.0 if possible, else returns zero.",
            );
            methods.document("");
            methods.document(
                "In particular, if the input is zero (or very close to zero), or non-finite,",
            );
            methods.document("the result of this operation will be zero.");
            methods.document("");
            methods.document("See also [`Self::try_normalize`].");
            methods.add_method("normalize_or_zero", |_, s, a: ()| {
                Ok(LuaDVec2::new(s.inner().normalize_or_zero()))
            });
            methods.document("Returns whether `self` is length `1.0` or not.");
            methods.document("");
            methods.document("Uses a precision threshold of `1e-6`.");
            methods.add_method("is_normalized", |_, s, a: ()| Ok(s.inner().is_normalized()));
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `other` is zero length when `glam_assert` is enabled.");
            methods.add_method("project_onto", |_, s, a: (LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().project_onto(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `other` has a length of zero when `glam_assert` is enabled.",
            );
            methods.add_method("reject_from", |_, s, a: (LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().reject_from(a.inner())))
            });
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("project_onto_normalized", |_, s, a: (LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().project_onto_normalized(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("reject_from_normalized", |_, s, a: (LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().reject_from_normalized(a.inner())))
            });
            methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
            methods.document("Round half-way cases away from 0.0.");
            methods.add_method("round", |_, s, a: ()| Ok(LuaDVec2::new(s.inner().round())));
            methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
            methods.document("element of `self`.");
            methods.add_method("floor", |_, s, a: ()| Ok(LuaDVec2::new(s.inner().floor())));
            methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
            methods.document("each element of `self`.");
            methods.add_method("ceil", |_, s, a: ()| Ok(LuaDVec2::new(s.inner().ceil())));
            methods.document(
                "Returns a vector containing the fractional part of the vector, e.g. `self -",
            );
            methods.document("self.floor()`.");
            methods.document("");
            methods.document("Note that this is fast but not precise for large numbers.");
            methods.add_method("fract", |_, s, a: ()| Ok(LuaDVec2::new(s.inner().fract())));
            methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
            methods.document("`self`.");
            methods.add_method("exp", |_, s, a: ()| Ok(LuaDVec2::new(s.inner().exp())));
            methods.document(
                "Returns a vector containing each element of `self` raised to the power of `n`.",
            );
            methods.add_method("powf", |_, s, a: (f64)| {
                Ok(LuaDVec2::new(s.inner().powf(a)))
            });
            methods.document(
                "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
            );
            methods.add_method("recip", |_, s, a: ()| Ok(LuaDVec2::new(s.inner().recip())));
            methods . document ("Performs a linear interpolation between `self` and `other` based on the value `s`.") ;
            methods.document("");
            methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
            methods . document ("will be equal to `other`. When `s` is outside of range [0,1], the result is linearly") ;
            methods.document("extrapolated.");
            methods.add_method("lerp", |_, s, a: (LuaDVec2, f64)| {
                Ok(LuaDVec2::new(s.inner().lerp(a.0.inner(), a.1)))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other` is") ;
            methods.document("less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
            methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
            methods.document("the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaDVec2, f64)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.document(
                "Returns a vector with a length no less than `min` and no more than `max`",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp_length", |_, s, a: (f64, f64)| {
                Ok(LuaDVec2::new(s.inner().clamp_length(a.0, a.1)))
            });
            methods.document("Returns a vector with a length no more than `max`");
            methods.add_method("clamp_length_max", |_, s, a: (f64)| {
                Ok(LuaDVec2::new(s.inner().clamp_length_max(a)))
            });
            methods.document("Returns a vector with a length no less than `min`");
            methods.add_method("clamp_length_min", |_, s, a: (f64)| {
                Ok(LuaDVec2::new(s.inner().clamp_length_min(a)))
            });
            methods.document(
                "Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding",
            );
            methods
                .document("error, yielding a more accurate result than an unfused multiply-add.");
            methods.document("");
            methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
            methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
            methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
            methods.document("mind.");
            methods.add_method("mul_add", |_, s, a: (LuaDVec2, LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().mul_add(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the angle (in radians) between `self` and `other`.");
            methods.document("");
            methods.document(
                "The input vectors do not need to be unit length however they must be non-zero.",
            );
            methods.add_method("angle_between", |_, s, a: (LuaDVec2)| {
                Ok(s.inner().angle_between(a.inner()))
            });
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec2", |_, s, a: ()| {
                Ok(LuaVec2::new(s.inner().as_vec2()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec2", |_, s, a: ()| {
                Ok(LuaIVec2::new(s.inner().as_ivec2()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec2", |_, s, a: ()| {
                Ok(LuaUVec2::new(s.inner().as_uvec2()))
            });
        }
    }
    impl tealr::TypeName for LuaDVec2 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDVec2"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDVec2 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDVec2 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaDVec3 = crate::LuaWrapper<DVec3>;
    impl tealr::mlu::TealData for LuaDVec3 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 3-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f64)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaDVec3::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaDVec3f64::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaDVec3f64::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaDVec3f64::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaDVec3f64::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaDVec3f64::f64(v) => {
                                return Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Creates a 4D vector from `self` and the given `w` value.");
            methods.add_method("extend", |_, s, a: (f64)| {
                Ok(LuaDVec4::new(s.inner().extend(a)))
            });
            methods.document(
                "Creates a `Vec2` from the `x` and `y` elements of `self`, discarding `z`.",
            );
            methods.document("");
            methods.document(
                "Truncation may also be performed by using `self.xy()` or `Vec2::from()`.",
            );
            methods.add_method("truncate", |_, s, a: ()| {
                Ok(LuaDVec2::new(s.inner().truncate()))
            });
            methods.document("Computes the cross product of `self` and `other`.");
            methods.add_method("cross", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().cross(a.inner())))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaDVec3)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaDVec3, LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaDVec3::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().signum()))
            });
            methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
            methods.document("`NaN`, positive or negative infinity, this will return `false`.");
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Computes the length of `self`.");
            methods.add_method("length", |_, s, a: ()| Ok(s.inner().length()));
            methods.document("Computes the squared length of `self`.");
            methods.document("");
            methods
                .document("This is faster than `length()` as it avoids a square root operation.");
            methods.add_method("length_squared", |_, s, a: ()| {
                Ok(s.inner().length_squared())
            });
            methods.document("Computes `1.0 / length()`.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.add_method("length_recip", |_, s, a: ()| Ok(s.inner().length_recip()));
            methods.document("Computes the Euclidean distance between two points in space.");
            methods.add_method("distance", |_, s, a: (LuaDVec3)| {
                Ok(s.inner().distance(a.inner()))
            });
            methods.document("Compute the squared euclidean distance between two points in space.");
            methods.add_method("distance_squared", |_, s, a: (LuaDVec3)| {
                Ok(s.inner().distance_squared(a.inner()))
            });
            methods.document("Returns `self` normalized to length 1.0.");
            methods.document("");
            methods.document(
                "For valid results, `self` must _not_ be of length zero, nor very close to zero.",
            );
            methods.document("");
            methods.document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
            methods.document("");
            methods.document("Panics");
            methods.document("");
            methods.document("Will panic if `self` is zero length when `glam_assert` is enabled.");
            methods.add_method("normalize", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().normalize()))
            });
            methods.document(
                "Returns `self` normalized to length 1.0 if possible, else returns zero.",
            );
            methods.document("");
            methods.document(
                "In particular, if the input is zero (or very close to zero), or non-finite,",
            );
            methods.document("the result of this operation will be zero.");
            methods.document("");
            methods.document("See also [`Self::try_normalize`].");
            methods.add_method("normalize_or_zero", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().normalize_or_zero()))
            });
            methods.document("Returns whether `self` is length `1.0` or not.");
            methods.document("");
            methods.document("Uses a precision threshold of `1e-6`.");
            methods.add_method("is_normalized", |_, s, a: ()| Ok(s.inner().is_normalized()));
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `other` is zero length when `glam_assert` is enabled.");
            methods.add_method("project_onto", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().project_onto(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `other` has a length of zero when `glam_assert` is enabled.",
            );
            methods.add_method("reject_from", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().reject_from(a.inner())))
            });
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("project_onto_normalized", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().project_onto_normalized(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("reject_from_normalized", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().reject_from_normalized(a.inner())))
            });
            methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
            methods.document("Round half-way cases away from 0.0.");
            methods.add_method("round", |_, s, a: ()| Ok(LuaDVec3::new(s.inner().round())));
            methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
            methods.document("element of `self`.");
            methods.add_method("floor", |_, s, a: ()| Ok(LuaDVec3::new(s.inner().floor())));
            methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
            methods.document("each element of `self`.");
            methods.add_method("ceil", |_, s, a: ()| Ok(LuaDVec3::new(s.inner().ceil())));
            methods.document(
                "Returns a vector containing the fractional part of the vector, e.g. `self -",
            );
            methods.document("self.floor()`.");
            methods.document("");
            methods.document("Note that this is fast but not precise for large numbers.");
            methods.add_method("fract", |_, s, a: ()| Ok(LuaDVec3::new(s.inner().fract())));
            methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
            methods.document("`self`.");
            methods.add_method("exp", |_, s, a: ()| Ok(LuaDVec3::new(s.inner().exp())));
            methods.document(
                "Returns a vector containing each element of `self` raised to the power of `n`.",
            );
            methods.add_method("powf", |_, s, a: (f64)| {
                Ok(LuaDVec3::new(s.inner().powf(a)))
            });
            methods.document(
                "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
            );
            methods.add_method("recip", |_, s, a: ()| Ok(LuaDVec3::new(s.inner().recip())));
            methods . document ("Performs a linear interpolation between `self` and `other` based on the value `s`.") ;
            methods.document("");
            methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
            methods . document ("will be equal to `other`. When `s` is outside of range [0,1], the result is linearly") ;
            methods.document("extrapolated.");
            methods.add_method("lerp", |_, s, a: (LuaDVec3, f64)| {
                Ok(LuaDVec3::new(s.inner().lerp(a.0.inner(), a.1)))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other` is") ;
            methods.document("less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
            methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
            methods.document("the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaDVec3, f64)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.document(
                "Returns a vector with a length no less than `min` and no more than `max`",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp_length", |_, s, a: (f64, f64)| {
                Ok(LuaDVec3::new(s.inner().clamp_length(a.0, a.1)))
            });
            methods.document("Returns a vector with a length no more than `max`");
            methods.add_method("clamp_length_max", |_, s, a: (f64)| {
                Ok(LuaDVec3::new(s.inner().clamp_length_max(a)))
            });
            methods.document("Returns a vector with a length no less than `min`");
            methods.add_method("clamp_length_min", |_, s, a: (f64)| {
                Ok(LuaDVec3::new(s.inner().clamp_length_min(a)))
            });
            methods.document(
                "Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding",
            );
            methods
                .document("error, yielding a more accurate result than an unfused multiply-add.");
            methods.document("");
            methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
            methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
            methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
            methods.document("mind.");
            methods.add_method("mul_add", |_, s, a: (LuaDVec3, LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().mul_add(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the angle (in radians) between two vectors.");
            methods.document("");
            methods.document(
                "The input vectors do not need to be unit length however they must be non-zero.",
            );
            methods.add_method("angle_between", |_, s, a: (LuaDVec3)| {
                Ok(s.inner().angle_between(a.inner()))
            });
            methods.document("Returns some vector that is orthogonal to the given one.");
            methods.document("");
            methods.document("The input vector must be finite and non-zero.");
            methods.document("");
            methods.document("The output vector is not necessarily unit-length.");
            methods.document("For that use [`Self::any_orthonormal_vector`] instead.");
            methods.add_method("any_orthogonal_vector", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().any_orthogonal_vector()))
            });
            methods.document("Returns any unit-length vector that is orthogonal to the given one.");
            methods.document("The input vector must be finite and non-zero.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `self` is not normalized when `glam_assert` is enabled.");
            methods.add_method("any_orthonormal_vector", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().any_orthonormal_vector()))
            });
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec3", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().as_vec3()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec3", |_, s, a: ()| {
                Ok(LuaIVec3::new(s.inner().as_ivec3()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec3", |_, s, a: ()| {
                Ok(LuaUVec3::new(s.inner().as_uvec3()))
            });
        }
    }
    impl tealr::TypeName for LuaDVec3 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDVec3"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDVec3 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDVec3 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaDVec4 = crate::LuaWrapper<DVec4>;
    impl tealr::mlu::TealData for LuaDVec4 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 4-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f64)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaDVec4::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaDVec4f64::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaDVec4f64::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaDVec4f64::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaDVec4f64::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaDVec4f64::f64(v) => {
                                return Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document(
                "Creates a `Vec3` from the `x`, `y` and `z` elements of `self`, discarding `w`.",
            );
            methods.document("");
            methods . document ("Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.") ;
            methods.document("");
            methods.document("To truncate to `Vec3A` use `Vec3A::from()`.");
            methods.add_method("truncate", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().truncate()))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaDVec4)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaDVec4, LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaDVec4::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| {
                Ok(LuaDVec4::new(s.inner().signum()))
            });
            methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
            methods.document("`NaN`, positive or negative infinity, this will return `false`.");
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Computes the length of `self`.");
            methods.add_method("length", |_, s, a: ()| Ok(s.inner().length()));
            methods.document("Computes the squared length of `self`.");
            methods.document("");
            methods
                .document("This is faster than `length()` as it avoids a square root operation.");
            methods.add_method("length_squared", |_, s, a: ()| {
                Ok(s.inner().length_squared())
            });
            methods.document("Computes `1.0 / length()`.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.add_method("length_recip", |_, s, a: ()| Ok(s.inner().length_recip()));
            methods.document("Computes the Euclidean distance between two points in space.");
            methods.add_method("distance", |_, s, a: (LuaDVec4)| {
                Ok(s.inner().distance(a.inner()))
            });
            methods.document("Compute the squared euclidean distance between two points in space.");
            methods.add_method("distance_squared", |_, s, a: (LuaDVec4)| {
                Ok(s.inner().distance_squared(a.inner()))
            });
            methods.document("Returns `self` normalized to length 1.0.");
            methods.document("");
            methods.document(
                "For valid results, `self` must _not_ be of length zero, nor very close to zero.",
            );
            methods.document("");
            methods.document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
            methods.document("");
            methods.document("Panics");
            methods.document("");
            methods.document("Will panic if `self` is zero length when `glam_assert` is enabled.");
            methods.add_method("normalize", |_, s, a: ()| {
                Ok(LuaDVec4::new(s.inner().normalize()))
            });
            methods.document(
                "Returns `self` normalized to length 1.0 if possible, else returns zero.",
            );
            methods.document("");
            methods.document(
                "In particular, if the input is zero (or very close to zero), or non-finite,",
            );
            methods.document("the result of this operation will be zero.");
            methods.document("");
            methods.document("See also [`Self::try_normalize`].");
            methods.add_method("normalize_or_zero", |_, s, a: ()| {
                Ok(LuaDVec4::new(s.inner().normalize_or_zero()))
            });
            methods.document("Returns whether `self` is length `1.0` or not.");
            methods.document("");
            methods.document("Uses a precision threshold of `1e-6`.");
            methods.add_method("is_normalized", |_, s, a: ()| Ok(s.inner().is_normalized()));
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `other` is zero length when `glam_assert` is enabled.");
            methods.add_method("project_onto", |_, s, a: (LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().project_onto(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be of non-zero length.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `other` has a length of zero when `glam_assert` is enabled.",
            );
            methods.add_method("reject_from", |_, s, a: (LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().reject_from(a.inner())))
            });
            methods.document("Returns the vector projection of `self` onto `other`.");
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("project_onto_normalized", |_, s, a: (LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().project_onto_normalized(a.inner())))
            });
            methods.document("Returns the vector rejection of `self` from `other`.");
            methods.document("");
            methods.document(
                "The vector rejection is the vector perpendicular to the projection of `self` onto",
            );
            methods.document(
                "`other`, in other words the result of `self - self.project_onto(other)`.",
            );
            methods.document("");
            methods.document("`other` must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `other` is not normalized when `glam_assert` is enabled.");
            methods.add_method("reject_from_normalized", |_, s, a: (LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().reject_from_normalized(a.inner())))
            });
            methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
            methods.document("Round half-way cases away from 0.0.");
            methods.add_method("round", |_, s, a: ()| Ok(LuaDVec4::new(s.inner().round())));
            methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
            methods.document("element of `self`.");
            methods.add_method("floor", |_, s, a: ()| Ok(LuaDVec4::new(s.inner().floor())));
            methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
            methods.document("each element of `self`.");
            methods.add_method("ceil", |_, s, a: ()| Ok(LuaDVec4::new(s.inner().ceil())));
            methods.document(
                "Returns a vector containing the fractional part of the vector, e.g. `self -",
            );
            methods.document("self.floor()`.");
            methods.document("");
            methods.document("Note that this is fast but not precise for large numbers.");
            methods.add_method("fract", |_, s, a: ()| Ok(LuaDVec4::new(s.inner().fract())));
            methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
            methods.document("`self`.");
            methods.add_method("exp", |_, s, a: ()| Ok(LuaDVec4::new(s.inner().exp())));
            methods.document(
                "Returns a vector containing each element of `self` raised to the power of `n`.",
            );
            methods.add_method("powf", |_, s, a: (f64)| {
                Ok(LuaDVec4::new(s.inner().powf(a)))
            });
            methods.document(
                "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
            );
            methods.add_method("recip", |_, s, a: ()| Ok(LuaDVec4::new(s.inner().recip())));
            methods . document ("Performs a linear interpolation between `self` and `other` based on the value `s`.") ;
            methods.document("");
            methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
            methods . document ("will be equal to `other`. When `s` is outside of range [0,1], the result is linearly") ;
            methods.document("extrapolated.");
            methods.add_method("lerp", |_, s, a: (LuaDVec4, f64)| {
                Ok(LuaDVec4::new(s.inner().lerp(a.0.inner(), a.1)))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other` is") ;
            methods.document("less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
            methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
            methods.document("the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaDVec4, f64)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.document(
                "Returns a vector with a length no less than `min` and no more than `max`",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp_length", |_, s, a: (f64, f64)| {
                Ok(LuaDVec4::new(s.inner().clamp_length(a.0, a.1)))
            });
            methods.document("Returns a vector with a length no more than `max`");
            methods.add_method("clamp_length_max", |_, s, a: (f64)| {
                Ok(LuaDVec4::new(s.inner().clamp_length_max(a)))
            });
            methods.document("Returns a vector with a length no less than `min`");
            methods.add_method("clamp_length_min", |_, s, a: (f64)| {
                Ok(LuaDVec4::new(s.inner().clamp_length_min(a)))
            });
            methods.document(
                "Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding",
            );
            methods
                .document("error, yielding a more accurate result than an unfused multiply-add.");
            methods.document("");
            methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
            methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
            methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
            methods.document("mind.");
            methods.add_method("mul_add", |_, s, a: (LuaDVec4, LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().mul_add(a.0.inner(), a.1.inner())))
            });
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec4", |_, s, a: ()| {
                Ok(LuaVec4::new(s.inner().as_vec4()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec4", |_, s, a: ()| {
                Ok(LuaIVec4::new(s.inner().as_ivec4()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec4", |_, s, a: ()| {
                Ok(LuaUVec4::new(s.inner().as_uvec4()))
            });
        }
    }
    impl tealr::TypeName for LuaDVec4 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDVec4"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDVec4 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDVec4 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaIVec2 = crate::LuaWrapper<IVec2>;
    impl tealr::mlu::TealData for LuaIVec2 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 2-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, i32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaIVec2::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaIVec2i32::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaIVec2i32::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaIVec2i32::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaIVec2i32::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaIVec2i32::i32(v) => {
                                return Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Creates a 3D vector from `self` and the given `z` value.");
            methods.add_method("extend", |_, s, a: (i32)| {
                Ok(LuaIVec3::new(s.inner().extend(a)))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaIVec2)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaIVec2)| {
                Ok(LuaIVec2::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaIVec2)| {
                Ok(LuaIVec2::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaIVec2, LuaIVec2)| {
                Ok(LuaIVec2::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaIVec2::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| {
                Ok(LuaIVec2::new(s.inner().signum()))
            });
            methods.document("Returns a vector that is equal to `self` rotated by 90 degrees.");
            methods.add_method("perp", |_, s, a: ()| Ok(LuaIVec2::new(s.inner().perp())));
            methods.document("The perpendicular dot product of `self` and `other`.");
            methods.document("Also known as the wedge product, 2d cross product, and determinant.");
            methods.add_method("perp_dot", |_, s, a: (LuaIVec2)| {
                Ok(s.inner().perp_dot(a.inner()))
            });
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec2", |_, s, a: ()| {
                Ok(LuaVec2::new(s.inner().as_vec2()))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec2", |_, s, a: ()| {
                Ok(LuaDVec2::new(s.inner().as_dvec2()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec2", |_, s, a: ()| {
                Ok(LuaUVec2::new(s.inner().as_uvec2()))
            });
        }
    }
    impl tealr::TypeName for LuaIVec2 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaIVec2"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaIVec2 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaIVec2 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaIVec3 = crate::LuaWrapper<IVec3>;
    impl tealr::mlu::TealData for LuaIVec3 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 3-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, i32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaIVec3::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaIVec3i32::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaIVec3i32::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaIVec3i32::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaIVec3i32::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaIVec3i32::i32(v) => {
                                return Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Creates a 4D vector from `self` and the given `w` value.");
            methods.add_method("extend", |_, s, a: (i32)| {
                Ok(LuaIVec4::new(s.inner().extend(a)))
            });
            methods.document(
                "Creates a `Vec2` from the `x` and `y` elements of `self`, discarding `z`.",
            );
            methods.document("");
            methods.document(
                "Truncation may also be performed by using `self.xy()` or `Vec2::from()`.",
            );
            methods.add_method("truncate", |_, s, a: ()| {
                Ok(LuaIVec2::new(s.inner().truncate()))
            });
            methods.document("Computes the cross product of `self` and `other`.");
            methods.add_method("cross", |_, s, a: (LuaIVec3)| {
                Ok(LuaIVec3::new(s.inner().cross(a.inner())))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaIVec3)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaIVec3)| {
                Ok(LuaIVec3::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaIVec3)| {
                Ok(LuaIVec3::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaIVec3, LuaIVec3)| {
                Ok(LuaIVec3::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaIVec3::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| {
                Ok(LuaIVec3::new(s.inner().signum()))
            });
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec3", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().as_vec3()))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec3", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().as_dvec3()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec3", |_, s, a: ()| {
                Ok(LuaUVec3::new(s.inner().as_uvec3()))
            });
        }
    }
    impl tealr::TypeName for LuaIVec3 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaIVec3"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaIVec3 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaIVec3 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaIVec4 = crate::LuaWrapper<IVec4>;
    impl tealr::mlu::TealData for LuaIVec4 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 4-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, i32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaIVec4::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaIVec4i32::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaIVec4i32::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaIVec4i32::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaIVec4i32::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaIVec4i32::i32(v) => {
                                return Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document(
                "Creates a `Vec3` from the `x`, `y` and `z` elements of `self`, discarding `w`.",
            );
            methods.document("");
            methods . document ("Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.") ;
            methods.document("");
            methods.document("To truncate to `Vec3A` use `Vec3A::from()`.");
            methods.add_method("truncate", |_, s, a: ()| {
                Ok(LuaIVec3::new(s.inner().truncate()))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaIVec4)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaIVec4)| {
                Ok(LuaIVec4::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaIVec4)| {
                Ok(LuaIVec4::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaIVec4, LuaIVec4)| {
                Ok(LuaIVec4::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document(
                "Returns a vector containing the absolute value of each element of `self`.",
            );
            methods.add_method("abs", |_, s, a: ()| Ok(LuaIVec4::new(s.inner().abs())));
            methods.document("Returns a vector with elements representing the sign of `self`.");
            methods.document("");
            methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
            methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
            methods.document("- `NAN` if the number is `NAN`");
            methods.add_method("signum", |_, s, a: ()| {
                Ok(LuaIVec4::new(s.inner().signum()))
            });
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec4", |_, s, a: ()| {
                Ok(LuaVec4::new(s.inner().as_vec4()))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec4", |_, s, a: ()| {
                Ok(LuaDVec4::new(s.inner().as_dvec4()))
            });
            methods.document("Casts all elements of `self` to `u32`.");
            methods.add_method("as_uvec4", |_, s, a: ()| {
                Ok(LuaUVec4::new(s.inner().as_uvec4()))
            });
        }
    }
    impl tealr::TypeName for LuaIVec4 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaIVec4"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaIVec4 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaIVec4 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaUVec2 = crate::LuaWrapper<UVec2>;
    impl tealr::mlu::TealData for LuaUVec2 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 2-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, u32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaUVec2u32::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaUVec2u32::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaUVec2u32::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaUVec2u32::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaUVec2u32::u32(v) => {
                                return Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Creates a 3D vector from `self` and the given `z` value.");
            methods.add_method("extend", |_, s, a: (u32)| {
                Ok(LuaUVec3::new(s.inner().extend(a)))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaUVec2)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaUVec2)| {
                Ok(LuaUVec2::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaUVec2)| {
                Ok(LuaUVec2::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaUVec2, LuaUVec2)| {
                Ok(LuaUVec2::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec2", |_, s, a: ()| {
                Ok(LuaVec2::new(s.inner().as_vec2()))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec2", |_, s, a: ()| {
                Ok(LuaDVec2::new(s.inner().as_dvec2()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec2", |_, s, a: ()| {
                Ok(LuaIVec2::new(s.inner().as_ivec2()))
            });
        }
    }
    impl tealr::TypeName for LuaUVec2 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaUVec2"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaUVec2 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaUVec2 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaUVec3 = crate::LuaWrapper<UVec3>;
    impl tealr::mlu::TealData for LuaUVec3 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 3-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, u32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaUVec3u32::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaUVec3u32::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaUVec3u32::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaUVec3u32::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaUVec3u32::u32(v) => {
                                return Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Creates a 4D vector from `self` and the given `w` value.");
            methods.add_method("extend", |_, s, a: (u32)| {
                Ok(LuaUVec4::new(s.inner().extend(a)))
            });
            methods.document(
                "Creates a `Vec2` from the `x` and `y` elements of `self`, discarding `z`.",
            );
            methods.document("");
            methods.document(
                "Truncation may also be performed by using `self.xy()` or `Vec2::from()`.",
            );
            methods.add_method("truncate", |_, s, a: ()| {
                Ok(LuaUVec2::new(s.inner().truncate()))
            });
            methods.document("Computes the cross product of `self` and `other`.");
            methods.add_method("cross", |_, s, a: (LuaUVec3)| {
                Ok(LuaUVec3::new(s.inner().cross(a.inner())))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaUVec3)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaUVec3)| {
                Ok(LuaUVec3::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaUVec3)| {
                Ok(LuaUVec3::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaUVec3, LuaUVec3)| {
                Ok(LuaUVec3::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec3", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().as_vec3()))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec3", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().as_dvec3()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec3", |_, s, a: ()| {
                Ok(LuaIVec3::new(s.inner().as_ivec3()))
            });
        }
    }
    impl tealr::TypeName for LuaUVec3 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaUVec3"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaUVec3 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaUVec3 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaUVec4 = crate::LuaWrapper<UVec4>;
    impl tealr::mlu::TealData for LuaUVec4 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 4-dimensional vector.");
            methods.add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.inner()[idx - 1]));
            methods.add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, u32)| {
                Ok(s.val_mut(|s| s[idx - 1] = val))
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    v.add((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            UnionLuaUVec4u32::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).add(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    v.sub((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            UnionLuaUVec4u32::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).sub(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    v.div((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).div(v.inner()),
                                )))
                            }
                            UnionLuaUVec4u32::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaUVec4u32::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mod,
                |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    v.rem((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).rem(v.inner()),
                                )))
                            }
                            UnionLuaUVec4u32::u32(v) => {
                                return Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(
                                    (ud.inner()).rem(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document(
                "Creates a `Vec3` from the `x`, `y` and `z` elements of `self`, discarding `w`.",
            );
            methods.document("");
            methods . document ("Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.") ;
            methods.document("");
            methods.document("To truncate to `Vec3A` use `Vec3A::from()`.");
            methods.add_method("truncate", |_, s, a: ()| {
                Ok(LuaUVec3::new(s.inner().truncate()))
            });
            methods.document("Computes the dot product of `self` and `other`.");
            methods.add_method("dot", |_, s, a: (LuaUVec4)| Ok(s.inner().dot(a.inner())));
            methods . document ("Returns a vector containing the minimum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.min(other.x), self.y.min(other.y), ..]`.",
            );
            methods.add_method("min", |_, s, a: (LuaUVec4)| {
                Ok(LuaUVec4::new(s.inner().min(a.inner())))
            });
            methods . document ("Returns a vector containing the maximum values for each element of `self` and `other`.") ;
            methods.document("");
            methods.document(
                "In other words this computes `[self.x.max(other.x), self.y.max(other.y), ..]`.",
            );
            methods.add_method("max", |_, s, a: (LuaUVec4)| {
                Ok(LuaUVec4::new(s.inner().max(a.inner())))
            });
            methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
            methods.document("");
            methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
            );
            methods.add_method("clamp", |_, s, a: (LuaUVec4, LuaUVec4)| {
                Ok(LuaUVec4::new(s.inner().clamp(a.0.inner(), a.1.inner())))
            });
            methods.document("Returns the horizontal minimum of `self`.");
            methods.document("");
            methods.document("In other words this computes `min(x, y, ..)`.");
            methods.add_method("min_element", |_, s, a: ()| Ok(s.inner().min_element()));
            methods.document("Returns the horizontal maximum of `self`.");
            methods.document("");
            methods.document("In other words this computes `max(x, y, ..)`.");
            methods.add_method("max_element", |_, s, a: ()| Ok(s.inner().max_element()));
            methods.document("Casts all elements of `self` to `f32`.");
            methods.add_method("as_vec4", |_, s, a: ()| {
                Ok(LuaVec4::new(s.inner().as_vec4()))
            });
            methods.document("Casts all elements of `self` to `f64`.");
            methods.add_method("as_dvec4", |_, s, a: ()| {
                Ok(LuaDVec4::new(s.inner().as_dvec4()))
            });
            methods.document("Casts all elements of `self` to `i32`.");
            methods.add_method("as_ivec4", |_, s, a: ()| {
                Ok(LuaIVec4::new(s.inner().as_ivec4()))
            });
        }
    }
    impl tealr::TypeName for LuaUVec4 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaUVec4"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaUVec4 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaUVec4 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaMat3 = crate::LuaWrapper<Mat3>;
    impl tealr::mlu::TealData for LuaMat3 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 3x3 column major matrix.");
            methods.document_type("");
            methods . document_type ("This 3x3 matrix type features convenience methods for creating and using linear and") ;
            methods . document_type ("affine transformations. If you are primarily dealing with 2D affine transformations the") ;
            methods . document_type ("[`Affine2`](crate::Affine2) type is much faster and more space efficient than using a") ;
            methods.document_type("3x3 matrix.");
            methods.document_type("");
            methods . document_type ("Linear transformations including 3D rotation and scale can be created using methods") ;
            methods . document_type ("such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],") ;
            methods.document_type("[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or");
            methods.document_type("[`Self::from_rotation_z()`].");
            methods.document_type("");
            methods.document_type(
                "The resulting matrices can be use to transform 3D vectors using regular vector",
            );
            methods.document_type("multiplication.");
            methods.document_type("");
            methods . document_type ("Affine transformations including 2D translation, rotation and scale can be created") ;
            methods.document_type(
                "using methods such as [`Self::from_translation()`], [`Self::from_angle()`],",
            );
            methods.document_type(
                "[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].",
            );
            methods.document_type("");
            methods . document_type ("The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods") ;
            methods . document_type ("are provided for performing affine transforms on 2D vectors and points. These multiply") ;
            methods.document_type(
                "2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for",
            );
            methods.document_type(
                "vectors respectively. These methods assume that `Self` contains a valid affine",
            );
            methods.document_type("transform.");
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaMat3::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (UnionLuaMat3, UnionLuaMat3)| {
                    match (lhs, rhs) {
                        (v, UnionLuaMat3::LuaMat3(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaMat3::LuaMat3(ud), v) => match v {
                            UnionLuaMat3::LuaMat3(v) => {
                                return Ok(UnionLuaMat3::LuaMat3(LuaMat3::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (UnionLuaMat3, UnionLuaMat3)| {
                    match (lhs, rhs) {
                        (v, UnionLuaMat3::LuaMat3(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaMat3::LuaMat3(ud), v) => match v {
                            UnionLuaMat3::LuaMat3(v) => {
                                return Ok(UnionLuaMat3::LuaMat3(LuaMat3::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf32LuaMat3, UnionLuaMat3LuaVec3f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaMat3LuaVec3f32::LuaMat3(ud)) => match v {
                            Unionf32LuaMat3::f32(v) => {
                                return Ok(UnionLuaMat3LuaVec3::LuaMat3(LuaMat3::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaMat3::LuaMat3(ud), v) => match v {
                            UnionLuaMat3LuaVec3f32::LuaMat3(v) => {
                                return Ok(UnionLuaMat3LuaVec3::LuaMat3(LuaMat3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaMat3LuaVec3f32::LuaVec3(v) => {
                                return Ok(UnionLuaMat3LuaVec3::LuaVec3(LuaVec3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaMat3LuaVec3f32::f32(v) => {
                                return Ok(UnionLuaMat3LuaVec3::LuaMat3(LuaMat3::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Returns the matrix column for the given `index`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Panics if `index` is greater than 2.");
            methods.add_method("col", |_, s, a: (usize)| Ok(LuaVec3::new(s.inner().col(a))));
            methods.document("Returns the matrix row for the given `index`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Panics if `index` is greater than 2.");
            methods.add_method("row", |_, s, a: (usize)| Ok(LuaVec3::new(s.inner().row(a))));
            methods.document("Returns `true` if, and only if, all elements are finite.");
            methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Returns the transpose of `self`.");
            methods.add_method("transpose", |_, s, a: ()| {
                Ok(LuaMat3::new(s.inner().transpose()))
            });
            methods.document("Returns the determinant of `self`.");
            methods.add_method("determinant", |_, s, a: ()| Ok(s.inner().determinant()));
            methods.document("Returns the inverse of `self`.");
            methods.document("");
            methods
                .document("If the matrix is not invertible the returned matrix will be invalid.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
            );
            methods.add_method("inverse", |_, s, a: ()| {
                Ok(LuaMat3::new(s.inner().inverse()))
            });
            methods.document("Transforms a 3D vector.");
            methods.add_method("mul_vec3", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().mul_vec3(a.inner())))
            });
            methods.document("Multiplies a 3x3 matrix by a scalar.");
            methods.add_method("mul_scalar", |_, s, a: (f32)| {
                Ok(LuaMat3::new(s.inner().mul_scalar(a)))
            });
            methods.document("Transforms the given 2D vector as a point.");
            methods.document("");
            methods.document(
                "This is the equivalent of multiplying `other` as a 3D vector where `z` is `1`.",
            );
            methods.document("");
            methods.document("This method assumes that `self` contains a valid affine transform.");
            methods.add_method("transform_point2", |_, s, a: (LuaVec2)| {
                Ok(LuaVec2::new(s.inner().transform_point2(a.inner())))
            });
            methods.document("Rotates the given 2D vector.");
            methods.document("");
            methods.document(
                "This is the equivalent of multiplying `other` as a 3D vector where `z` is `0`.",
            );
            methods.document("");
            methods.document("This method assumes that `self` contains a valid affine transform.");
            methods.add_method("transform_vector2", |_, s, a: (LuaVec2)| {
                Ok(LuaVec2::new(s.inner().transform_vector2(a.inner())))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other`") ;
            methods.document("is less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two matrices contain similar elements. It works best") ;
            methods.document(
                "when comparing with a known value. The `max_abs_diff` that should be used used",
            );
            methods.document("depends on the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaMat3, f32)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.add_method("as_dmat3", |_, s, a: ()| {
                Ok(LuaDMat3::new(s.inner().as_dmat3()))
            });
            methods.add_meta_method_mut(MetaMethod::Index, |_, s, idx: usize| match s {
                LuaMat3::Owned(ref mut v, ref valid) => Ok(LuaVec3::Ref(LuaRef {
                    root: LuaRefBase::LuaOwned {
                        valid: Arc::downgrade((valid)),
                    },
                    r: ReflectPtr::Mut(v.col_mut(idx - 1)),
                    path: None,
                })),
                LuaMat3::Ref(ref mut r) => r.get_mut(|s, r| {
                    Ok(LuaVec3::Ref(LuaRef {
                        root: r.root.clone(),
                        r: ReflectPtr::Mut(s.downcast_mut::<Mat3>().unwrap().col_mut(idx - 1)),
                        path: None,
                    }))
                }),
            });
        }
    }
    impl tealr::TypeName for LuaMat3 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaMat3"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaMat3 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaMat3 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaMat4 = crate::LuaWrapper<Mat4>;
    impl tealr::mlu::TealData for LuaMat4 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 4x4 column major matrix.");
            methods.document_type("");
            methods . document_type ("This 4x4 matrix type features convenience methods for creating and using affine transforms and") ;
            methods . document_type ("perspective projections. If you are primarily dealing with 3D affine transformations") ;
            methods . document_type ("considering using [`Affine3A`](crate::Affine3A) which is faster than a 4x4 matrix for some") ;
            methods.document_type("affine operations.");
            methods.document_type("");
            methods . document_type ("Affine transformations including 3D translation, rotation and scale can be created") ;
            methods.document_type(
                "using methods such as [`Self::from_translation()`], [`Self::from_quat()`],",
            );
            methods.document_type(
                "[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].",
            );
            methods.document_type("");
            methods . document_type ("Othographic projections can be created using the methods [`Self::orthographic_lh()`] for") ;
            methods.document_type(
                "left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed",
            );
            methods
                .document_type("systems. The resulting matrix is also an affine transformation.");
            methods.document_type("");
            methods . document_type ("The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods") ;
            methods . document_type ("are provided for performing affine transformations on 3D vectors and points. These") ;
            methods . document_type ("multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`") ;
            methods . document_type ("for vectors respectively. These methods assume that `Self` contains a valid affine") ;
            methods.document_type("transform.");
            methods.document_type("");
            methods.document_type("Perspective projections can be created using methods such as");
            methods.document_type(
                "[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and",
            );
            methods . document_type ("[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and") ;
            methods.document_type(
                "[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and",
            );
            methods.document_type(
                "[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.",
            );
            methods.document_type("");
            methods . document_type ("The resulting perspective project can be use to transform 3D vectors as points with") ;
            methods.document_type(
                "perspective correction using the [`Self::project_point3()`] convenience method.",
            );
            methods.add_meta_method_mut(MetaMethod::Index, |_, s, idx: usize| match s {
                LuaMat4::Owned(ref mut v, ref valid) => Ok(LuaVec4::Ref(LuaRef {
                    root: LuaRefBase::LuaOwned {
                        valid: Arc::downgrade((valid)),
                    },
                    r: ReflectPtr::Mut(v.col_mut(idx - 1)),
                    path: None,
                })),
                LuaMat4::Ref(ref mut r) => r.get_mut(|s, r| {
                    Ok(LuaVec4::Ref(LuaRef {
                        root: r.root.clone(),
                        r: ReflectPtr::Mut(s.downcast_mut::<Mat4>().unwrap().col_mut(idx - 1)),
                        path: None,
                    }))
                }),
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaMat4::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (UnionLuaMat4, UnionLuaMat4)| {
                    match (lhs, rhs) {
                        (v, UnionLuaMat4::LuaMat4(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaMat4::LuaMat4(ud), v) => match v {
                            UnionLuaMat4::LuaMat4(v) => {
                                return Ok(UnionLuaMat4::LuaMat4(LuaMat4::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (UnionLuaMat4, UnionLuaMat4)| {
                    match (lhs, rhs) {
                        (v, UnionLuaMat4::LuaMat4(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaMat4::LuaMat4(ud), v) => match v {
                            UnionLuaMat4::LuaMat4(v) => {
                                return Ok(UnionLuaMat4::LuaMat4(LuaMat4::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf32LuaMat4, UnionLuaMat4LuaVec4f32)| {
                    match (lhs, rhs) {
                        (v, UnionLuaMat4LuaVec4f32::LuaMat4(ud)) => match v {
                            Unionf32LuaMat4::f32(v) => {
                                return Ok(UnionLuaMat4LuaVec4::LuaMat4(LuaMat4::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf32LuaMat4::LuaMat4(ud), v) => match v {
                            UnionLuaMat4LuaVec4f32::LuaMat4(v) => {
                                return Ok(UnionLuaMat4LuaVec4::LuaMat4(LuaMat4::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaMat4LuaVec4f32::LuaVec4(v) => {
                                return Ok(UnionLuaMat4LuaVec4::LuaVec4(LuaVec4::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaMat4LuaVec4f32::f32(v) => {
                                return Ok(UnionLuaMat4LuaVec4::LuaMat4(LuaMat4::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Returns the matrix column for the given `index`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Panics if `index` is greater than 3.");
            methods.add_method("col", |_, s, a: (usize)| Ok(LuaVec4::new(s.inner().col(a))));
            methods.document("Returns the matrix row for the given `index`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Panics if `index` is greater than 3.");
            methods.add_method("row", |_, s, a: (usize)| Ok(LuaVec4::new(s.inner().row(a))));
            methods.document("Returns `true` if, and only if, all elements are finite.");
            methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Returns the transpose of `self`.");
            methods.add_method("transpose", |_, s, a: ()| {
                Ok(LuaMat4::new(s.inner().transpose()))
            });
            methods.document("Returns the determinant of `self`.");
            methods.add_method("determinant", |_, s, a: ()| Ok(s.inner().determinant()));
            methods.document("Returns the inverse of `self`.");
            methods.document("");
            methods
                .document("If the matrix is not invertible the returned matrix will be invalid.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
            );
            methods.add_method("inverse", |_, s, a: ()| {
                Ok(LuaMat4::new(s.inner().inverse()))
            });
            methods.document("Transforms a 4D vector.");
            methods.add_method("mul_vec4", |_, s, a: (LuaVec4)| {
                Ok(LuaVec4::new(s.inner().mul_vec4(a.inner())))
            });
            methods.document("Multiplies this matrix by a scalar value.");
            methods.add_method("mul_scalar", |_, s, a: (f32)| {
                Ok(LuaMat4::new(s.inner().mul_scalar(a)))
            });
            methods.document(
                "Transforms the given 3D vector as a point, applying perspective correction.",
            );
            methods.document("");
            methods . document ("This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.") ;
            methods . document ("The perspective divide is performed meaning the resulting 3D vector is divided by `w`.") ;
            methods.document("");
            methods.document("This method assumes that `self` contains a projective transform.");
            methods.add_method("project_point3", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().project_point3(a.inner())))
            });
            methods.document("Transforms the given 3D vector as a point.");
            methods.document("");
            methods.document(
                "This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is",
            );
            methods.document("`1.0`.");
            methods.document("");
            methods . document ("This method assumes that `self` contains a valid affine transform. It does not perform") ;
            methods . document ("a persective divide, if `self` contains a perspective transform, or if you are unsure,") ;
            methods.document("the [`Self::project_point3()`] method should be used instead.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.") ;
            methods.add_method("transform_point3", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().transform_point3(a.inner())))
            });
            methods.document("Transforms the give 3D vector as a direction.");
            methods.document("");
            methods.document(
                "This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is",
            );
            methods.document("`0.0`.");
            methods.document("");
            methods.document("This method assumes that `self` contains a valid affine transform.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.") ;
            methods.add_method("transform_vector3", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().transform_vector3(a.inner())))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other`") ;
            methods.document("is less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two 4x4 matrices contain similar elements. It works") ;
            methods . document ("best when comparing with a known value. The `max_abs_diff` that should be used used") ;
            methods.document("depends on the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaMat4, f32)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.add_method("as_dmat4", |_, s, a: ()| {
                Ok(LuaDMat4::new(s.inner().as_dmat4()))
            });
        }
    }
    impl tealr::TypeName for LuaMat4 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaMat4"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaMat4 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaMat4 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaDMat3 = crate::LuaWrapper<DMat3>;
    impl tealr::mlu::TealData for LuaDMat3 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 3x3 column major matrix.");
            methods.document_type("");
            methods . document_type ("This 3x3 matrix type features convenience methods for creating and using linear and") ;
            methods . document_type ("affine transformations. If you are primarily dealing with 2D affine transformations the") ;
            methods . document_type ("[`Affine2`](crate::Affine2) type is much faster and more space efficient than using a") ;
            methods.document_type("3x3 matrix.");
            methods.document_type("");
            methods . document_type ("Linear transformations including 3D rotation and scale can be created using methods") ;
            methods . document_type ("such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],") ;
            methods.document_type("[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or");
            methods.document_type("[`Self::from_rotation_z()`].");
            methods.document_type("");
            methods.document_type(
                "The resulting matrices can be use to transform 3D vectors using regular vector",
            );
            methods.document_type("multiplication.");
            methods.document_type("");
            methods . document_type ("Affine transformations including 2D translation, rotation and scale can be created") ;
            methods.document_type(
                "using methods such as [`Self::from_translation()`], [`Self::from_angle()`],",
            );
            methods.document_type(
                "[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].",
            );
            methods.document_type("");
            methods . document_type ("The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods") ;
            methods . document_type ("are provided for performing affine transforms on 2D vectors and points. These multiply") ;
            methods.document_type(
                "2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for",
            );
            methods.document_type(
                "vectors respectively. These methods assume that `Self` contains a valid affine",
            );
            methods.document_type("transform.");
            methods.add_meta_method_mut(MetaMethod::Index, |_, s, idx: usize| match s {
                LuaDMat3::Owned(ref mut v, ref valid) => Ok(LuaDVec3::Ref(LuaRef {
                    root: LuaRefBase::LuaOwned {
                        valid: Arc::downgrade((valid)),
                    },
                    r: ReflectPtr::Mut(v.col_mut(idx - 1)),
                    path: None,
                })),
                LuaDMat3::Ref(ref mut r) => r.get_mut(|s, r| {
                    Ok(LuaDVec3::Ref(LuaRef {
                        root: r.root.clone(),
                        r: ReflectPtr::Mut(s.downcast_mut::<DMat3>().unwrap().col_mut(idx - 1)),
                        path: None,
                    }))
                }),
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaDMat3::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (UnionLuaDMat3, UnionLuaDMat3)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDMat3::LuaDMat3(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaDMat3::LuaDMat3(ud), v) => match v {
                            UnionLuaDMat3::LuaDMat3(v) => {
                                return Ok(UnionLuaDMat3::LuaDMat3(LuaDMat3::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (UnionLuaDMat3, UnionLuaDMat3)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDMat3::LuaDMat3(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaDMat3::LuaDMat3(ud), v) => match v {
                            UnionLuaDMat3::LuaDMat3(v) => {
                                return Ok(UnionLuaDMat3::LuaDMat3(LuaDMat3::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf64LuaDMat3, UnionLuaDMat3LuaDVec3f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDMat3LuaDVec3f64::LuaDMat3(ud)) => match v {
                            Unionf64LuaDMat3::f64(v) => {
                                return Ok(UnionLuaDMat3LuaDVec3::LuaDMat3(LuaDMat3::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDMat3::LuaDMat3(ud), v) => match v {
                            UnionLuaDMat3LuaDVec3f64::LuaDMat3(v) => {
                                return Ok(UnionLuaDMat3LuaDVec3::LuaDMat3(LuaDMat3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaDMat3LuaDVec3f64::LuaDVec3(v) => {
                                return Ok(UnionLuaDMat3LuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaDMat3LuaDVec3f64::f64(v) => {
                                return Ok(UnionLuaDMat3LuaDVec3::LuaDMat3(LuaDMat3::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Returns the matrix column for the given `index`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Panics if `index` is greater than 2.");
            methods.add_method("col", |_, s, a: (usize)| {
                Ok(LuaDVec3::new(s.inner().col(a)))
            });
            methods.document("Returns the matrix row for the given `index`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Panics if `index` is greater than 2.");
            methods.add_method("row", |_, s, a: (usize)| {
                Ok(LuaDVec3::new(s.inner().row(a)))
            });
            methods.document("Returns `true` if, and only if, all elements are finite.");
            methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Returns the transpose of `self`.");
            methods.add_method("transpose", |_, s, a: ()| {
                Ok(LuaDMat3::new(s.inner().transpose()))
            });
            methods.document("Returns the determinant of `self`.");
            methods.add_method("determinant", |_, s, a: ()| Ok(s.inner().determinant()));
            methods.document("Returns the inverse of `self`.");
            methods.document("");
            methods
                .document("If the matrix is not invertible the returned matrix will be invalid.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
            );
            methods.add_method("inverse", |_, s, a: ()| {
                Ok(LuaDMat3::new(s.inner().inverse()))
            });
            methods.document("Transforms a 3D vector.");
            methods.add_method("mul_vec3", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().mul_vec3(a.inner())))
            });
            methods.document("Multiplies a 3x3 matrix by a scalar.");
            methods.add_method("mul_scalar", |_, s, a: (f64)| {
                Ok(LuaDMat3::new(s.inner().mul_scalar(a)))
            });
            methods.document("Transforms the given 2D vector as a point.");
            methods.document("");
            methods.document(
                "This is the equivalent of multiplying `other` as a 3D vector where `z` is `1`.",
            );
            methods.document("");
            methods.document("This method assumes that `self` contains a valid affine transform.");
            methods.add_method("transform_point2", |_, s, a: (LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().transform_point2(a.inner())))
            });
            methods.document("Rotates the given 2D vector.");
            methods.document("");
            methods.document(
                "This is the equivalent of multiplying `other` as a 3D vector where `z` is `0`.",
            );
            methods.document("");
            methods.document("This method assumes that `self` contains a valid affine transform.");
            methods.add_method("transform_vector2", |_, s, a: (LuaDVec2)| {
                Ok(LuaDVec2::new(s.inner().transform_vector2(a.inner())))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other`") ;
            methods.document("is less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two matrices contain similar elements. It works best") ;
            methods.document(
                "when comparing with a known value. The `max_abs_diff` that should be used used",
            );
            methods.document("depends on the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaDMat3, f64)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.add_method("as_mat3", |_, s, a: ()| {
                Ok(LuaMat3::new(s.inner().as_mat3()))
            });
        }
    }
    impl tealr::TypeName for LuaDMat3 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDMat3"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDMat3 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDMat3 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaDMat4 = crate::LuaWrapper<DMat4>;
    impl tealr::mlu::TealData for LuaDMat4 {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A 4x4 column major matrix.");
            methods.document_type("");
            methods . document_type ("This 4x4 matrix type features convenience methods for creating and using affine transforms and") ;
            methods . document_type ("perspective projections. If you are primarily dealing with 3D affine transformations") ;
            methods . document_type ("considering using [`DAffine3`](crate::DAffine3) which is faster than a 4x4 matrix for some") ;
            methods.document_type("affine operations.");
            methods.document_type("");
            methods . document_type ("Affine transformations including 3D translation, rotation and scale can be created") ;
            methods.document_type(
                "using methods such as [`Self::from_translation()`], [`Self::from_quat()`],",
            );
            methods.document_type(
                "[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].",
            );
            methods.document_type("");
            methods . document_type ("Othographic projections can be created using the methods [`Self::orthographic_lh()`] for") ;
            methods.document_type(
                "left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed",
            );
            methods
                .document_type("systems. The resulting matrix is also an affine transformation.");
            methods.document_type("");
            methods . document_type ("The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods") ;
            methods . document_type ("are provided for performing affine transformations on 3D vectors and points. These") ;
            methods . document_type ("multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`") ;
            methods . document_type ("for vectors respectively. These methods assume that `Self` contains a valid affine") ;
            methods.document_type("transform.");
            methods.document_type("");
            methods.document_type("Perspective projections can be created using methods such as");
            methods.document_type(
                "[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and",
            );
            methods . document_type ("[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and") ;
            methods.document_type(
                "[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and",
            );
            methods.document_type(
                "[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.",
            );
            methods.document_type("");
            methods . document_type ("The resulting perspective project can be use to transform 3D vectors as points with") ;
            methods.document_type(
                "perspective correction using the [`Self::project_point3()`] convenience method.",
            );
            methods.add_meta_method_mut(MetaMethod::Index, |_, s, idx: usize| match s {
                LuaDMat4::Owned(ref mut v, ref valid) => Ok(LuaDVec4::Ref(LuaRef {
                    root: LuaRefBase::LuaOwned {
                        valid: Arc::downgrade((valid)),
                    },
                    r: ReflectPtr::Mut(v.col_mut(idx - 1)),
                    path: None,
                })),
                LuaDMat4::Ref(ref mut r) => r.get_mut(|s, r| {
                    Ok(LuaDVec4::Ref(LuaRef {
                        root: r.root.clone(),
                        r: ReflectPtr::Mut(s.downcast_mut::<DMat4>().unwrap().col_mut(idx - 1)),
                        path: None,
                    }))
                }),
            });
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaDMat4::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (UnionLuaDMat4, UnionLuaDMat4)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDMat4::LuaDMat4(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaDMat4::LuaDMat4(ud), v) => match v {
                            UnionLuaDMat4::LuaDMat4(v) => {
                                return Ok(UnionLuaDMat4::LuaDMat4(LuaDMat4::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (UnionLuaDMat4, UnionLuaDMat4)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDMat4::LuaDMat4(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaDMat4::LuaDMat4(ud), v) => match v {
                            UnionLuaDMat4::LuaDMat4(v) => {
                                return Ok(UnionLuaDMat4::LuaDMat4(LuaDMat4::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (Unionf64LuaDMat4, UnionLuaDMat4LuaDVec4f64)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDMat4LuaDVec4f64::LuaDMat4(ud)) => match v {
                            Unionf64LuaDMat4::f64(v) => {
                                return Ok(UnionLuaDMat4LuaDVec4::LuaDMat4(LuaDMat4::new(
                                    v.mul((ud.inner())),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (Unionf64LuaDMat4::LuaDMat4(ud), v) => match v {
                            UnionLuaDMat4LuaDVec4f64::LuaDMat4(v) => {
                                return Ok(UnionLuaDMat4LuaDVec4::LuaDMat4(LuaDMat4::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaDMat4LuaDVec4f64::LuaDVec4(v) => {
                                return Ok(UnionLuaDMat4LuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            UnionLuaDMat4LuaDVec4f64::f64(v) => {
                                return Ok(UnionLuaDMat4LuaDVec4::LuaDMat4(LuaDMat4::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Returns the matrix column for the given `index`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Panics if `index` is greater than 3.");
            methods.add_method("col", |_, s, a: (usize)| {
                Ok(LuaDVec4::new(s.inner().col(a)))
            });
            methods.document("Returns the matrix row for the given `index`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Panics if `index` is greater than 3.");
            methods.add_method("row", |_, s, a: (usize)| {
                Ok(LuaDVec4::new(s.inner().row(a)))
            });
            methods.document("Returns `true` if, and only if, all elements are finite.");
            methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.document("Returns `true` if any elements are `NaN`.");
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Returns the transpose of `self`.");
            methods.add_method("transpose", |_, s, a: ()| {
                Ok(LuaDMat4::new(s.inner().transpose()))
            });
            methods.document("Returns the determinant of `self`.");
            methods.add_method("determinant", |_, s, a: ()| Ok(s.inner().determinant()));
            methods.document("Returns the inverse of `self`.");
            methods.document("");
            methods
                .document("If the matrix is not invertible the returned matrix will be invalid.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if the determinant of `self` is zero when `glam_assert` is enabled.",
            );
            methods.add_method("inverse", |_, s, a: ()| {
                Ok(LuaDMat4::new(s.inner().inverse()))
            });
            methods.document("Transforms a 4D vector.");
            methods.add_method("mul_vec4", |_, s, a: (LuaDVec4)| {
                Ok(LuaDVec4::new(s.inner().mul_vec4(a.inner())))
            });
            methods.document("Multiplies this matrix by a scalar value.");
            methods.add_method("mul_scalar", |_, s, a: (f64)| {
                Ok(LuaDMat4::new(s.inner().mul_scalar(a)))
            });
            methods.document(
                "Transforms the given 3D vector as a point, applying perspective correction.",
            );
            methods.document("");
            methods . document ("This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.") ;
            methods . document ("The perspective divide is performed meaning the resulting 3D vector is divided by `w`.") ;
            methods.document("");
            methods.document("This method assumes that `self` contains a projective transform.");
            methods.add_method("project_point3", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().project_point3(a.inner())))
            });
            methods.document("Transforms the given 3D vector as a point.");
            methods.document("");
            methods.document(
                "This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is",
            );
            methods.document("`1.0`.");
            methods.document("");
            methods . document ("This method assumes that `self` contains a valid affine transform. It does not perform") ;
            methods . document ("a persective divide, if `self` contains a perspective transform, or if you are unsure,") ;
            methods.document("the [`Self::project_point3()`] method should be used instead.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.") ;
            methods.add_method("transform_point3", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().transform_point3(a.inner())))
            });
            methods.document("Transforms the give 3D vector as a direction.");
            methods.document("");
            methods.document(
                "This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is",
            );
            methods.document("`0.0`.");
            methods.document("");
            methods.document("This method assumes that `self` contains a valid affine transform.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.") ;
            methods.add_method("transform_vector3", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().transform_vector3(a.inner())))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other`") ;
            methods.document("is less than or equal to `max_abs_diff`.");
            methods.document("");
            methods . document ("This can be used to compare if two 4x4 matrices contain similar elements. It works") ;
            methods . document ("best when comparing with a known value. The `max_abs_diff` that should be used used") ;
            methods.document("depends on the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaDMat4, f64)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.add_method("as_mat4", |_, s, a: ()| {
                Ok(LuaMat4::new(s.inner().as_mat4()))
            });
        }
    }
    impl tealr::TypeName for LuaDMat4 {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDMat4"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDMat4 {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDMat4 {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaQuat = crate::LuaWrapper<Quat>;
    impl tealr::mlu::TealData for LuaQuat {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A quaternion representing an orientation.");
            methods.document_type("");
            methods.document_type(
                "This quaternion is intended to be of unit length but may denormalize due to",
            );
            methods.document_type(
                "floating point \"error creep\" which can occur when successive quaternion",
            );
            methods.document_type("operations are applied.");
            methods.document_type("");
            methods.document_type("This type is 16 byte aligned.");
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaQuat::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (UnionLuaQuat, UnionLuaQuat)| {
                    match (lhs, rhs) {
                        (v, UnionLuaQuat::LuaQuat(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaQuat::LuaQuat(ud), v) => match v {
                            UnionLuaQuat::LuaQuat(v) => {
                                return Ok(UnionLuaQuat::LuaQuat(LuaQuat::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (UnionLuaQuat, UnionLuaQuat)| {
                    match (lhs, rhs) {
                        (v, UnionLuaQuat::LuaQuat(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaQuat::LuaQuat(ud), v) => match v {
                            UnionLuaQuat::LuaQuat(v) => {
                                return Ok(UnionLuaQuat::LuaQuat(LuaQuat::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (UnionLuaQuat, Unionf32)| {
                    match (lhs, rhs) {
                        (UnionLuaQuat::LuaQuat(ud), v) => match v {
                            Unionf32::f32(v) => {
                                return Ok(UnionLuaQuat::LuaQuat(LuaQuat::new((ud.inner()).div(v))))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (UnionLuaQuat, Unionf32LuaQuatLuaVec3)| {
                    match (lhs, rhs) {
                        (v, Unionf32LuaQuatLuaVec3::LuaQuat(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaQuat::LuaQuat(ud), v) => match v {
                            Unionf32LuaQuatLuaVec3::f32(v) => {
                                return Ok(UnionLuaQuatLuaVec3::LuaQuat(LuaQuat::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            Unionf32LuaQuatLuaVec3::LuaQuat(v) => {
                                return Ok(UnionLuaQuatLuaVec3::LuaQuat(LuaQuat::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            Unionf32LuaQuatLuaVec3::LuaVec3(v) => {
                                return Ok(UnionLuaQuatLuaVec3::LuaVec3(LuaVec3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Returns the rotation axis scaled by the rotation in radians.");
            methods.add_method("to_scaled_axis", |_, s, a: ()| {
                Ok(LuaVec3::new(s.inner().to_scaled_axis()))
            });
            methods.document("Returns the vector part of the quaternion.");
            methods.add_method("xyz", |_, s, a: ()| Ok(LuaVec3::new(s.inner().xyz())));
            methods
                .document("Returns the quaternion conjugate of `self`. For a unit quaternion the");
            methods.document("conjugate is also the inverse.");
            methods.add_method("conjugate", |_, s, a: ()| {
                Ok(LuaQuat::new(s.inner().conjugate()))
            });
            methods.document("Returns the inverse of a normalized quaternion.");
            methods.document("");
            methods.document(
                "Typically quaternion inverse returns the conjugate of a normalized quaternion.",
            );
            methods . document ("Because `self` is assumed to already be unit length this method *does not* normalize") ;
            methods.document("before returning the conjugate.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `self` is not normalized when `glam_assert` is enabled.");
            methods.add_method("inverse", |_, s, a: ()| {
                Ok(LuaQuat::new(s.inner().inverse()))
            });
            methods.document("Computes the dot product of `self` and `other`. The dot product is");
            methods
                .document("equal to the the cosine of the angle between two quaternion rotations.");
            methods.add_method("dot", |_, s, a: (LuaQuat)| Ok(s.inner().dot(a.inner())));
            methods.document("Computes the length of `self`.");
            methods.add_method("length", |_, s, a: ()| Ok(s.inner().length()));
            methods.document("Computes the squared length of `self`.");
            methods.document("");
            methods.document("This is generally faster than `length()` as it avoids a square");
            methods.document("root operation.");
            methods.add_method("length_squared", |_, s, a: ()| {
                Ok(s.inner().length_squared())
            });
            methods.document("Computes `1.0 / length()`.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.add_method("length_recip", |_, s, a: ()| Ok(s.inner().length_recip()));
            methods.document("Returns `self` normalized to length 1.0.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.document("");
            methods.document("Panics");
            methods.document("");
            methods.document("Will panic if `self` is zero length when `glam_assert` is enabled.");
            methods.add_method("normalize", |_, s, a: ()| {
                Ok(LuaQuat::new(s.inner().normalize()))
            });
            methods.document("Returns `true` if, and only if, all elements are finite.");
            methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Returns whether `self` of length `1.0` or not.");
            methods.document("");
            methods.document("Uses a precision threshold of `1e-6`.");
            methods.add_method("is_normalized", |_, s, a: ()| Ok(s.inner().is_normalized()));
            methods.add_method("is_near_identity", |_, s, a: ()| {
                Ok(s.inner().is_near_identity())
            });
            methods.document("Returns the angle (in radians) for the minimal rotation");
            methods.document("for transforming this quaternion into another.");
            methods.document("");
            methods.document("Both quaternions must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `self` or `other` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_method("angle_between", |_, s, a: (LuaQuat)| {
                Ok(s.inner().angle_between(a.inner()))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other`") ;
            methods.document("is less than or equal to `max_abs_diff`.");
            methods.document("");
            methods.document(
                "This can be used to compare if two quaternions contain similar elements. It works",
            );
            methods . document ("best when comparing with a known value. The `max_abs_diff` that should be used used") ;
            methods.document("depends on the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaQuat, f32)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.document("Performs a linear interpolation between `self` and `other` based on");
            methods.document("the value `s`.");
            methods.document("");
            methods.document("When `s` is `0.0`, the result will be equal to `self`.  When `s`");
            methods.document("is `1.0`, the result will be equal to `other`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_method("lerp", |_, s, a: (LuaQuat, f32)| {
                Ok(LuaQuat::new(s.inner().lerp(a.0.inner(), a.1)))
            });
            methods.document("Performs a spherical linear interpolation between `self` and `end`");
            methods.document("based on the value `s`.");
            methods.document("");
            methods.document("When `s` is `0.0`, the result will be equal to `self`.  When `s`");
            methods.document("is `1.0`, the result will be equal to `end`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_method("slerp", |_, s, a: (LuaQuat, f32)| {
                Ok(LuaQuat::new(s.inner().slerp(a.0.inner(), a.1)))
            });
            methods
                .document("Multiplies a quaternion and a 3D vector, returning the rotated vector.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `self` is not normalized when `glam_assert` is enabled.");
            methods.add_method("mul_vec3", |_, s, a: (LuaVec3)| {
                Ok(LuaVec3::new(s.inner().mul_vec3(a.inner())))
            });
            methods.document(
                "Multiplies two quaternions. If they each represent a rotation, the result will",
            );
            methods.document("represent the combined rotation.");
            methods.document("");
            methods . document ("Note that due to floating point rounding the result may not be perfectly normalized.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `self` or `other` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_method("mul_quat", |_, s, a: (LuaQuat)| {
                Ok(LuaQuat::new(s.inner().mul_quat(a.inner())))
            });
            methods.add_method("as_f64", |_, s, a: ()| {
                Ok(LuaDQuat::new(s.inner().as_f64()))
            });
        }
    }
    impl tealr::TypeName for LuaQuat {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaQuat"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaQuat {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaQuat {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaDQuat = crate::LuaWrapper<DQuat>;
    impl tealr::mlu::TealData for LuaDQuat {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("A quaternion representing an orientation.");
            methods.document_type("");
            methods.document_type(
                "This quaternion is intended to be of unit length but may denormalize due to",
            );
            methods.document_type(
                "floating point \"error creep\" which can occur when successive quaternion",
            );
            methods.document_type("operations are applied.");
            methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                return Ok(LuaDQuat::new(ud.inner().neg()));
            });
            methods.add_meta_function(
                mlua::MetaMethod::Add,
                |ctx, (lhs, rhs): (UnionLuaDQuat, UnionLuaDQuat)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDQuat::LuaDQuat(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaDQuat::LuaDQuat(ud), v) => match v {
                            UnionLuaDQuat::LuaDQuat(v) => {
                                return Ok(UnionLuaDQuat::LuaDQuat(LuaDQuat::new(
                                    (ud.inner()).add(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Sub,
                |ctx, (lhs, rhs): (UnionLuaDQuat, UnionLuaDQuat)| {
                    match (lhs, rhs) {
                        (v, UnionLuaDQuat::LuaDQuat(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaDQuat::LuaDQuat(ud), v) => match v {
                            UnionLuaDQuat::LuaDQuat(v) => {
                                return Ok(UnionLuaDQuat::LuaDQuat(LuaDQuat::new(
                                    (ud.inner()).sub(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Div,
                |ctx, (lhs, rhs): (UnionLuaDQuat, Unionf64)| {
                    match (lhs, rhs) {
                        (UnionLuaDQuat::LuaDQuat(ud), v) => match v {
                            Unionf64::f64(v) => {
                                return Ok(UnionLuaDQuat::LuaDQuat(LuaDQuat::new(
                                    (ud.inner()).div(v),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.add_meta_function(
                mlua::MetaMethod::Mul,
                |ctx, (lhs, rhs): (UnionLuaDQuat, Unionf64LuaDQuatLuaDVec3)| {
                    match (lhs, rhs) {
                        (v, Unionf64LuaDQuatLuaDVec3::LuaDQuat(ud)) => match v {
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        (UnionLuaDQuat::LuaDQuat(ud), v) => match v {
                            Unionf64LuaDQuatLuaDVec3::f64(v) => {
                                return Ok(UnionLuaDQuatLuaDVec3::LuaDQuat(LuaDQuat::new(
                                    (ud.inner()).mul(v),
                                )))
                            }
                            Unionf64LuaDQuatLuaDVec3::LuaDQuat(v) => {
                                return Ok(UnionLuaDQuatLuaDVec3::LuaDQuat(LuaDQuat::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            Unionf64LuaDQuatLuaDVec3::LuaDVec3(v) => {
                                return Ok(UnionLuaDQuatLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.inner()).mul(v.inner()),
                                )))
                            }
                            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["panic"],
                                &[],
                            )),
                        },
                        _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["Something went wrong"],
                            &[],
                        )),
                    };
                    return Err(tealr::mlu::mlua::Error::RuntimeError(
                        "Operation not supported".to_string(),
                    ));
                },
            );
            methods.document("Returns the rotation axis scaled by the rotation in radians.");
            methods.add_method("to_scaled_axis", |_, s, a: ()| {
                Ok(LuaDVec3::new(s.inner().to_scaled_axis()))
            });
            methods.document("Returns the vector part of the quaternion.");
            methods.add_method("xyz", |_, s, a: ()| Ok(LuaDVec3::new(s.inner().xyz())));
            methods
                .document("Returns the quaternion conjugate of `self`. For a unit quaternion the");
            methods.document("conjugate is also the inverse.");
            methods.add_method("conjugate", |_, s, a: ()| {
                Ok(LuaDQuat::new(s.inner().conjugate()))
            });
            methods.document("Returns the inverse of a normalized quaternion.");
            methods.document("");
            methods.document(
                "Typically quaternion inverse returns the conjugate of a normalized quaternion.",
            );
            methods . document ("Because `self` is assumed to already be unit length this method *does not* normalize") ;
            methods.document("before returning the conjugate.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `self` is not normalized when `glam_assert` is enabled.");
            methods.add_method("inverse", |_, s, a: ()| {
                Ok(LuaDQuat::new(s.inner().inverse()))
            });
            methods.document("Computes the dot product of `self` and `other`. The dot product is");
            methods
                .document("equal to the the cosine of the angle between two quaternion rotations.");
            methods.add_method("dot", |_, s, a: (LuaDQuat)| Ok(s.inner().dot(a.inner())));
            methods.document("Computes the length of `self`.");
            methods.add_method("length", |_, s, a: ()| Ok(s.inner().length()));
            methods.document("Computes the squared length of `self`.");
            methods.document("");
            methods.document("This is generally faster than `length()` as it avoids a square");
            methods.document("root operation.");
            methods.add_method("length_squared", |_, s, a: ()| {
                Ok(s.inner().length_squared())
            });
            methods.document("Computes `1.0 / length()`.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.add_method("length_recip", |_, s, a: ()| Ok(s.inner().length_recip()));
            methods.document("Returns `self` normalized to length 1.0.");
            methods.document("");
            methods.document("For valid results, `self` must _not_ be of length zero.");
            methods.document("");
            methods.document("Panics");
            methods.document("");
            methods.document("Will panic if `self` is zero length when `glam_assert` is enabled.");
            methods.add_method("normalize", |_, s, a: ()| {
                Ok(LuaDQuat::new(s.inner().normalize()))
            });
            methods.document("Returns `true` if, and only if, all elements are finite.");
            methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
            methods.add_method("is_finite", |_, s, a: ()| Ok(s.inner().is_finite()));
            methods.add_method("is_nan", |_, s, a: ()| Ok(s.inner().is_nan()));
            methods.document("Returns whether `self` of length `1.0` or not.");
            methods.document("");
            methods.document("Uses a precision threshold of `1e-6`.");
            methods.add_method("is_normalized", |_, s, a: ()| Ok(s.inner().is_normalized()));
            methods.add_method("is_near_identity", |_, s, a: ()| {
                Ok(s.inner().is_near_identity())
            });
            methods.document("Returns the angle (in radians) for the minimal rotation");
            methods.document("for transforming this quaternion into another.");
            methods.document("");
            methods.document("Both quaternions must be normalized.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `self` or `other` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_method("angle_between", |_, s, a: (LuaDQuat)| {
                Ok(s.inner().angle_between(a.inner()))
            });
            methods . document ("Returns true if the absolute difference of all elements between `self` and `other`") ;
            methods.document("is less than or equal to `max_abs_diff`.");
            methods.document("");
            methods.document(
                "This can be used to compare if two quaternions contain similar elements. It works",
            );
            methods . document ("best when comparing with a known value. The `max_abs_diff` that should be used used") ;
            methods.document("depends on the values being compared against.");
            methods.document("");
            methods.document("For more see");
            methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
            methods.add_method("abs_diff_eq", |_, s, a: (LuaDQuat, f64)| {
                Ok(s.inner().abs_diff_eq(a.0.inner(), a.1))
            });
            methods.document("Performs a linear interpolation between `self` and `other` based on");
            methods.document("the value `s`.");
            methods.document("");
            methods.document("When `s` is `0.0`, the result will be equal to `self`.  When `s`");
            methods.document("is `1.0`, the result will be equal to `other`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_method("lerp", |_, s, a: (LuaDQuat, f64)| {
                Ok(LuaDQuat::new(s.inner().lerp(a.0.inner(), a.1)))
            });
            methods.document("Performs a spherical linear interpolation between `self` and `end`");
            methods.document("based on the value `s`.");
            methods.document("");
            methods.document("When `s` is `0.0`, the result will be equal to `self`.  When `s`");
            methods.document("is `1.0`, the result will be equal to `end`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_method("slerp", |_, s, a: (LuaDQuat, f64)| {
                Ok(LuaDQuat::new(s.inner().slerp(a.0.inner(), a.1)))
            });
            methods
                .document("Multiplies a quaternion and a 3D vector, returning the rotated vector.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `self` is not normalized when `glam_assert` is enabled.");
            methods.add_method("mul_vec3", |_, s, a: (LuaDVec3)| {
                Ok(LuaDVec3::new(s.inner().mul_vec3(a.inner())))
            });
            methods.document(
                "Multiplies two quaternions. If they each represent a rotation, the result will",
            );
            methods.document("represent the combined rotation.");
            methods.document("");
            methods . document ("Note that due to floating point rounding the result may not be perfectly normalized.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `self` or `other` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_method("mul_quat", |_, s, a: (LuaDQuat)| {
                Ok(LuaDQuat::new(s.inner().mul_quat(a.inner())))
            });
            methods.add_method("as_f32", |_, s, a: ()| Ok(LuaQuat::new(s.inner().as_f32())));
        }
    }
    impl tealr::TypeName for LuaDQuat {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDQuat"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDQuat {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDQuat {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub type LuaEulerRot = crate::AnyLuaWrapper<EulerRot>;
    impl tealr::mlu::TealData for LuaEulerRot {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Euler rotation sequences.");
            methods.document_type("");
            methods.document_type("The angles are applied starting from the right.");
            methods.document_type("E.g. XYZ will first apply the z-axis rotation.");
            methods.document_type("");
            methods
                .document_type("YXZ can be used for yaw (y-axis), pitch (x-axis), roll (z-axis).");
            methods.document_type("");
            methods . document_type ("The two-axis rotations (e.g. ZYZ) are not fully tested and have to be treated with caution.") ;
        }
    }
    impl tealr::TypeName for LuaEulerRot {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaEulerRot"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaEulerRot {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaEulerRot {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct BevyAPIGlobals;
    impl tealr::mlu::ExportInstances for BevyAPIGlobals {
        fn add_instances<'lua, T: tealr::mlu::InstanceCollector<'lua>>(
            instance_collector: &mut T,
        ) -> mlua::Result<()> {
            instance_collector.document_instance("Global methods for LuaEntityGlobals");
            instance_collector.add_instance("LuaEntityGlobals".into(), |_| Ok(LuaEntityGlobals))?;
            instance_collector.document_instance("Global methods for LuaVec2Globals");
            instance_collector.add_instance("LuaVec2Globals".into(), |_| Ok(LuaVec2Globals))?;
            instance_collector.document_instance("Global methods for LuaVec3Globals");
            instance_collector.add_instance("LuaVec3Globals".into(), |_| Ok(LuaVec3Globals))?;
            instance_collector.document_instance("Global methods for LuaVec4Globals");
            instance_collector.add_instance("LuaVec4Globals".into(), |_| Ok(LuaVec4Globals))?;
            instance_collector.document_instance("Global methods for LuaDVec2Globals");
            instance_collector.add_instance("LuaDVec2Globals".into(), |_| Ok(LuaDVec2Globals))?;
            instance_collector.document_instance("Global methods for LuaDVec3Globals");
            instance_collector.add_instance("LuaDVec3Globals".into(), |_| Ok(LuaDVec3Globals))?;
            instance_collector.document_instance("Global methods for LuaDVec4Globals");
            instance_collector.add_instance("LuaDVec4Globals".into(), |_| Ok(LuaDVec4Globals))?;
            instance_collector.document_instance("Global methods for LuaIVec2Globals");
            instance_collector.add_instance("LuaIVec2Globals".into(), |_| Ok(LuaIVec2Globals))?;
            instance_collector.document_instance("Global methods for LuaIVec3Globals");
            instance_collector.add_instance("LuaIVec3Globals".into(), |_| Ok(LuaIVec3Globals))?;
            instance_collector.document_instance("Global methods for LuaIVec4Globals");
            instance_collector.add_instance("LuaIVec4Globals".into(), |_| Ok(LuaIVec4Globals))?;
            instance_collector.document_instance("Global methods for LuaUVec2Globals");
            instance_collector.add_instance("LuaUVec2Globals".into(), |_| Ok(LuaUVec2Globals))?;
            instance_collector.document_instance("Global methods for LuaUVec3Globals");
            instance_collector.add_instance("LuaUVec3Globals".into(), |_| Ok(LuaUVec3Globals))?;
            instance_collector.document_instance("Global methods for LuaUVec4Globals");
            instance_collector.add_instance("LuaUVec4Globals".into(), |_| Ok(LuaUVec4Globals))?;
            instance_collector.document_instance("Global methods for LuaMat3Globals");
            instance_collector.add_instance("LuaMat3Globals".into(), |_| Ok(LuaMat3Globals))?;
            instance_collector.document_instance("Global methods for LuaMat4Globals");
            instance_collector.add_instance("LuaMat4Globals".into(), |_| Ok(LuaMat4Globals))?;
            instance_collector.document_instance("Global methods for LuaDMat3Globals");
            instance_collector.add_instance("LuaDMat3Globals".into(), |_| Ok(LuaDMat3Globals))?;
            instance_collector.document_instance("Global methods for LuaDMat4Globals");
            instance_collector.add_instance("LuaDMat4Globals".into(), |_| Ok(LuaDMat4Globals))?;
            instance_collector.document_instance("Global methods for LuaQuatGlobals");
            instance_collector.add_instance("LuaQuatGlobals".into(), |_| Ok(LuaQuatGlobals))?;
            instance_collector.document_instance("Global methods for LuaDQuatGlobals");
            instance_collector.add_instance("LuaDQuatGlobals".into(), |_| Ok(LuaDQuatGlobals))?;
            Ok(())
        }
    }
    struct LuaEntityGlobals;
    impl tealr::mlu::TealData for LuaEntityGlobals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for Entity");
            methods.document(
                "Creates a new entity reference with the specified `id` and a generation of 0.",
            );
            methods.document("");
            methods.document("# Note");
            methods.document("");
            methods . document ("Spawning a specific `entity` value is __rarely the right choice__. Most apps should favor") ;
            methods.document(
                "[`Commands::spawn`](crate::system::Commands::spawn). This method should generally",
            );
            methods.document(
                "only be used for sharing entities across apps, and only when they have a scheme",
            );
            methods.document("worked out to share an ID space (which doesn\'t happen by default).");
            methods.document("");
            methods . document ("In general, one should not try to synchronize the ECS by attempting to ensure that") ;
            methods.document(
                "`Entity` lines up between instances, but instead insert a secondary identifier as",
            );
            methods.document("a component.");
            methods.document("");
            methods.document(
                "There are still some use cases where it might be appropriate to use this function",
            );
            methods.document("externally.");
            methods.document("");
            methods.document("## Examples");
            methods.document("");
            methods
                .document("Initializing a collection (e.g. `array` or `Vec`) with a known size:");
            methods.document("");
            methods.document("```no_run");
            methods.document("# use bevy_ecs::prelude::*;");
            methods.document("let mut entities: [Entity; 10] = [Entity::from_raw(0); 10];");
            methods.document("");
            methods.document("```");
            methods.document("");
            methods.document("Deriving `Reflect` for a component that has an `Entity` field:");
            methods.document("");
            methods.document("```no_run");
            methods.document("# use bevy_ecs::{prelude::*, component::*};");
            methods.document("# use bevy_reflect::Reflect;");
            methods.document("#[derive(Reflect, Component)]");
            methods.document("#[reflect(Component)]");
            methods.document("pub struct MyStruct {");
            methods.document("    pub entity: Entity,");
            methods.document("}");
            methods.document("");
            methods.document("impl FromWorld for MyStruct {");
            methods.document("    fn from_world(_world: &mut World) -> Self {");
            methods.document("        Self {");
            methods.document("            entity: Entity::from_raw(u32::MAX),");
            methods.document("        }");
            methods.document("    }");
            methods.document("}");
            methods.document("```");
            methods.add_function("from_raw", |_, a: (u32)| {
                Ok(LuaEntity::new(Entity::from_raw(a)))
            });
            methods.document(
                "Reconstruct an `Entity` previously destructured with [`Entity::to_bits`].",
            );
            methods.document("");
            methods . document ("Only useful when applied to results from `to_bits` in the same instance of an application.") ;
            methods.add_function("from_bits", |_, a: (u64)| {
                Ok(LuaEntity::new(Entity::from_bits(a)))
            });
        }
    }
    impl tealr::TypeName for LuaEntityGlobals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaEntityGlobals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaEntityGlobals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaEntityGlobals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaVec2Globals;
    impl tealr::mlu::TealData for LuaVec2Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for Vec2");
            methods.document("Creates a new vector.");
            methods.add_function("new", |_, a: (f32, f32)| {
                Ok(LuaVec2::new(Vec2::new(a.0, a.1)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (f32)| Ok(LuaVec2::new(Vec2::splat(a))));
        }
    }
    impl tealr::TypeName for LuaVec2Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaVec2Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaVec2Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaVec2Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaVec3Globals;
    impl tealr::mlu::TealData for LuaVec3Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for Vec3");
            methods.document("Creates a new 3D vector.");
            methods.add_function("new", |_, a: (f32, f32, f32)| {
                Ok(LuaVec3::new(Vec3::new(a.0, a.1, a.2)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (f32)| Ok(LuaVec3::new(Vec3::splat(a))));
        }
    }
    impl tealr::TypeName for LuaVec3Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaVec3Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaVec3Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaVec3Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaVec4Globals;
    impl tealr::mlu::TealData for LuaVec4Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for Vec4");
            methods.document("Creates a new 4D vector.");
            methods.add_function("new", |_, a: (f32, f32, f32, f32)| {
                Ok(LuaVec4::new(Vec4::new(a.0, a.1, a.2, a.3)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (f32)| Ok(LuaVec4::new(Vec4::splat(a))));
        }
    }
    impl tealr::TypeName for LuaVec4Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaVec4Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaVec4Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaVec4Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaDVec2Globals;
    impl tealr::mlu::TealData for LuaDVec2Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for DVec2");
            methods.document("Creates a new vector.");
            methods.add_function("new", |_, a: (f64, f64)| {
                Ok(LuaDVec2::new(DVec2::new(a.0, a.1)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (f64)| Ok(LuaDVec2::new(DVec2::splat(a))));
        }
    }
    impl tealr::TypeName for LuaDVec2Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDVec2Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDVec2Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDVec2Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaDVec3Globals;
    impl tealr::mlu::TealData for LuaDVec3Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for DVec3");
            methods.document("Creates a new 3D vector.");
            methods.add_function("new", |_, a: (f64, f64, f64)| {
                Ok(LuaDVec3::new(DVec3::new(a.0, a.1, a.2)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (f64)| Ok(LuaDVec3::new(DVec3::splat(a))));
        }
    }
    impl tealr::TypeName for LuaDVec3Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDVec3Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDVec3Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDVec3Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaDVec4Globals;
    impl tealr::mlu::TealData for LuaDVec4Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for DVec4");
            methods.document("Creates a new 4D vector.");
            methods.add_function("new", |_, a: (f64, f64, f64, f64)| {
                Ok(LuaDVec4::new(DVec4::new(a.0, a.1, a.2, a.3)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (f64)| Ok(LuaDVec4::new(DVec4::splat(a))));
        }
    }
    impl tealr::TypeName for LuaDVec4Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDVec4Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDVec4Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDVec4Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaIVec2Globals;
    impl tealr::mlu::TealData for LuaIVec2Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for IVec2");
            methods.document("Creates a new vector.");
            methods.add_function("new", |_, a: (i32, i32)| {
                Ok(LuaIVec2::new(IVec2::new(a.0, a.1)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (i32)| Ok(LuaIVec2::new(IVec2::splat(a))));
        }
    }
    impl tealr::TypeName for LuaIVec2Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaIVec2Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaIVec2Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaIVec2Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaIVec3Globals;
    impl tealr::mlu::TealData for LuaIVec3Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for IVec3");
            methods.document("Creates a new 3D vector.");
            methods.add_function("new", |_, a: (i32, i32, i32)| {
                Ok(LuaIVec3::new(IVec3::new(a.0, a.1, a.2)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (i32)| Ok(LuaIVec3::new(IVec3::splat(a))));
        }
    }
    impl tealr::TypeName for LuaIVec3Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaIVec3Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaIVec3Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaIVec3Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaIVec4Globals;
    impl tealr::mlu::TealData for LuaIVec4Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for IVec4");
            methods.document("Creates a new 4D vector.");
            methods.add_function("new", |_, a: (i32, i32, i32, i32)| {
                Ok(LuaIVec4::new(IVec4::new(a.0, a.1, a.2, a.3)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (i32)| Ok(LuaIVec4::new(IVec4::splat(a))));
        }
    }
    impl tealr::TypeName for LuaIVec4Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaIVec4Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaIVec4Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaIVec4Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaUVec2Globals;
    impl tealr::mlu::TealData for LuaUVec2Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for UVec2");
            methods.document("Creates a new vector.");
            methods.add_function("new", |_, a: (u32, u32)| {
                Ok(LuaUVec2::new(UVec2::new(a.0, a.1)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (u32)| Ok(LuaUVec2::new(UVec2::splat(a))));
        }
    }
    impl tealr::TypeName for LuaUVec2Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaUVec2Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaUVec2Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaUVec2Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaUVec3Globals;
    impl tealr::mlu::TealData for LuaUVec3Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for UVec3");
            methods.document("Creates a new 3D vector.");
            methods.add_function("new", |_, a: (u32, u32, u32)| {
                Ok(LuaUVec3::new(UVec3::new(a.0, a.1, a.2)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (u32)| Ok(LuaUVec3::new(UVec3::splat(a))));
        }
    }
    impl tealr::TypeName for LuaUVec3Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaUVec3Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaUVec3Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaUVec3Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaUVec4Globals;
    impl tealr::mlu::TealData for LuaUVec4Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for UVec4");
            methods.document("Creates a new 4D vector.");
            methods.add_function("new", |_, a: (u32, u32, u32, u32)| {
                Ok(LuaUVec4::new(UVec4::new(a.0, a.1, a.2, a.3)))
            });
            methods.document("Creates a vector with all elements set to `v`.");
            methods.add_function("splat", |_, a: (u32)| Ok(LuaUVec4::new(UVec4::splat(a))));
        }
    }
    impl tealr::TypeName for LuaUVec4Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaUVec4Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaUVec4Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaUVec4Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaMat3Globals;
    impl tealr::mlu::TealData for LuaMat3Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for Mat3");
            methods.document("Creates a 3x3 matrix from three column vectors.");
            methods.add_function("from_cols", |_, a: (LuaVec3, LuaVec3, LuaVec3)| {
                Ok(LuaMat3::new(Mat3::from_cols(
                    a.0.inner(),
                    a.1.inner(),
                    a.2.inner(),
                )))
            });
            methods . document ("Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.") ;
            methods.document("The resulting matrix is a 3D scale transfom.");
            methods.add_function("from_diagonal", |_, a: (LuaVec3)| {
                Ok(LuaMat3::new(Mat3::from_diagonal(a.inner())))
            });
            methods.document(
                "Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.",
            );
            methods.add_function("from_mat4", |_, a: (LuaMat4)| {
                Ok(LuaMat3::new(Mat3::from_mat4(a.inner())))
            });
            methods.document("Creates a 3D rotation matrix from the given quaternion.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_quat", |_, a: (LuaQuat)| {
                Ok(LuaMat3::new(Mat3::from_quat(a.inner())))
            });
            methods.document(
                "Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in",
            );
            methods.document("radians).");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `axis` is not normalized when `glam_assert` is enabled.");
            methods.add_function("from_axis_angle", |_, a: (LuaVec3, f32)| {
                Ok(LuaMat3::new(Mat3::from_axis_angle(a.0.inner(), a.1)))
            });
            methods . document ("Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in") ;
            methods.document("radians).");
            methods.add_function("from_euler", |_, a: (LuaEulerRot, f32, f32, f32)| {
                Ok(LuaMat3::new(Mat3::from_euler(a.0.inner(), a.1, a.2, a.3)))
            });
            methods.document(
                "Creates a 3D rotation matrix from `angle` (in radians) around the x axis.",
            );
            methods.add_function("from_rotation_x", |_, a: (f32)| {
                Ok(LuaMat3::new(Mat3::from_rotation_x(a)))
            });
            methods.document(
                "Creates a 3D rotation matrix from `angle` (in radians) around the y axis.",
            );
            methods.add_function("from_rotation_y", |_, a: (f32)| {
                Ok(LuaMat3::new(Mat3::from_rotation_y(a)))
            });
            methods.document(
                "Creates a 3D rotation matrix from `angle` (in radians) around the z axis.",
            );
            methods.add_function("from_rotation_z", |_, a: (f32)| {
                Ok(LuaMat3::new(Mat3::from_rotation_z(a)))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 2D `translation`.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 2D points and vectors. See",
            );
            methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
            methods.add_function("from_translation", |_, a: (LuaVec2)| {
                Ok(LuaMat3::new(Mat3::from_translation(a.inner())))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 2D rotation `angle` (in",
            );
            methods.document("radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 2D points and vectors. See",
            );
            methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
            methods.add_function("from_angle", |_, a: (f32)| {
                Ok(LuaMat3::new(Mat3::from_angle(a)))
            });
            methods . document ("Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in") ;
            methods.document("radians) and `translation`.");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 2D points and vectors. See",
            );
            methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
            methods.add_function(
                "from_scale_angle_translation",
                |_, a: (LuaVec2, f32, LuaVec2)| {
                    Ok(LuaMat3::new(Mat3::from_scale_angle_translation(
                        a.0.inner(),
                        a.1,
                        a.2.inner(),
                    )))
                },
            );
            methods.document(
                "Creates an affine transformation matrix from the given non-uniform 2D `scale`.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 2D points and vectors. See",
            );
            methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
            );
            methods.add_function("from_scale", |_, a: (LuaVec2)| {
                Ok(LuaMat3::new(Mat3::from_scale(a.inner())))
            });
        }
    }
    impl tealr::TypeName for LuaMat3Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaMat3Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaMat3Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaMat3Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaMat4Globals;
    impl tealr::mlu::TealData for LuaMat4Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for Mat4");
            methods.document("Creates a 4x4 matrix from four column vectors.");
            methods.add_function("from_cols", |_, a: (LuaVec4, LuaVec4, LuaVec4, LuaVec4)| {
                Ok(LuaMat4::new(Mat4::from_cols(
                    a.0.inner(),
                    a.1.inner(),
                    a.2.inner(),
                    a.3.inner(),
                )))
            });
            methods . document ("Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.") ;
            methods.add_function("from_diagonal", |_, a: (LuaVec4)| {
                Ok(LuaMat4::new(Mat4::from_diagonal(a.inner())))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 3D `scale`, `rotation` and",
            );
            methods.document("`translation`.");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
            );
            methods.add_function(
                "from_scale_rotation_translation",
                |_, a: (LuaVec3, LuaQuat, LuaVec3)| {
                    Ok(LuaMat4::new(Mat4::from_scale_rotation_translation(
                        a.0.inner(),
                        a.1.inner(),
                        a.2.inner(),
                    )))
                },
            );
            methods.document(
                "Creates an affine transformation matrix from the given 3D `translation`.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_rotation_translation", |_, a: (LuaQuat, LuaVec3)| {
                Ok(LuaMat4::new(Mat4::from_rotation_translation(
                    a.0.inner(),
                    a.1.inner(),
                )))
            });
            methods.document(
                "Creates an affine transformation matrix from the given `rotation` quaternion.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_quat", |_, a: (LuaQuat)| {
                Ok(LuaMat4::new(Mat4::from_quat(a.inner())))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 3x3 linear transformation",
            );
            methods.document("matrix.");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_mat3", |_, a: (LuaMat3)| {
                Ok(LuaMat4::new(Mat4::from_mat3(a.inner())))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 3D `translation`.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_translation", |_, a: (LuaVec3)| {
                Ok(LuaMat4::new(Mat4::from_translation(a.inner())))
            });
            methods . document ("Creates an affine transformation matrix containing a 3D rotation around a normalized") ;
            methods.document("rotation `axis` of `angle` (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `axis` is not normalized when `glam_assert` is enabled.");
            methods.add_function("from_axis_angle", |_, a: (LuaVec3, f32)| {
                Ok(LuaMat4::new(Mat4::from_axis_angle(a.0.inner(), a.1)))
            });
            methods.document(
                "Creates a affine transformation matrix containing a rotation from the given euler",
            );
            methods.document("rotation sequence and angles (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_euler", |_, a: (LuaEulerRot, f32, f32, f32)| {
                Ok(LuaMat4::new(Mat4::from_euler(a.0.inner(), a.1, a.2, a.3)))
            });
            methods . document ("Creates an affine transformation matrix containing a 3D rotation around the x axis of") ;
            methods.document("`angle` (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_rotation_x", |_, a: (f32)| {
                Ok(LuaMat4::new(Mat4::from_rotation_x(a)))
            });
            methods . document ("Creates an affine transformation matrix containing a 3D rotation around the y axis of") ;
            methods.document("`angle` (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_rotation_y", |_, a: (f32)| {
                Ok(LuaMat4::new(Mat4::from_rotation_y(a)))
            });
            methods . document ("Creates an affine transformation matrix containing a 3D rotation around the z axis of") ;
            methods.document("`angle` (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_rotation_z", |_, a: (f32)| {
                Ok(LuaMat4::new(Mat4::from_rotation_z(a)))
            });
            methods . document ("Creates an affine transformation matrix containing the given 3D non-uniform `scale`.") ;
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
            );
            methods.add_function("from_scale", |_, a: (LuaVec3)| {
                Ok(LuaMat4::new(Mat4::from_scale(a.inner())))
            });
            methods . document ("Creates a left-handed view matrix using a camera position, an up direction, and a focal") ;
            methods.document("point.");
            methods.document(
                "For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `up` is not normalized when `glam_assert` is enabled.");
            methods.add_function("look_at_lh", |_, a: (LuaVec3, LuaVec3, LuaVec3)| {
                Ok(LuaMat4::new(Mat4::look_at_lh(
                    a.0.inner(),
                    a.1.inner(),
                    a.2.inner(),
                )))
            });
            methods . document ("Creates a right-handed view matrix using a camera position, an up direction, and a focal") ;
            methods.document("point.");
            methods
                .document("For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `up` is not normalized when `glam_assert` is enabled.");
            methods.add_function("look_at_rh", |_, a: (LuaVec3, LuaVec3, LuaVec3)| {
                Ok(LuaMat4::new(Mat4::look_at_rh(
                    a.0.inner(),
                    a.1.inner(),
                    a.2.inner(),
                )))
            });
            methods.document(
                "Creates a right-handed perspective projection matrix with [-1,1] depth range.",
            );
            methods.document("This is the same as the OpenGL `gluPerspective` function.");
            methods . document ("See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>") ;
            methods.add_function("perspective_rh_gl", |_, a: (f32, f32, f32, f32)| {
                Ok(LuaMat4::new(Mat4::perspective_rh_gl(a.0, a.1, a.2, a.3)))
            });
            methods.document(
                "Creates a left-handed perspective projection matrix with `[0,1]` depth range.",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is") ;
            methods.document("enabled.");
            methods.add_function("perspective_lh", |_, a: (f32, f32, f32, f32)| {
                Ok(LuaMat4::new(Mat4::perspective_lh(a.0, a.1, a.2, a.3)))
            });
            methods.document(
                "Creates a right-handed perspective projection matrix with `[0,1]` depth range.",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is") ;
            methods.document("enabled.");
            methods.add_function("perspective_rh", |_, a: (f32, f32, f32, f32)| {
                Ok(LuaMat4::new(Mat4::perspective_rh(a.0, a.1, a.2, a.3)))
            });
            methods . document ("Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.") ;
            methods.add_function("perspective_infinite_lh", |_, a: (f32, f32, f32)| {
                Ok(LuaMat4::new(Mat4::perspective_infinite_lh(a.0, a.1, a.2)))
            });
            methods . document ("Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.") ;
            methods.add_function(
                "perspective_infinite_reverse_lh",
                |_, a: (f32, f32, f32)| {
                    Ok(LuaMat4::new(Mat4::perspective_infinite_reverse_lh(
                        a.0, a.1, a.2,
                    )))
                },
            );
            methods.document("Creates an infinite right-handed perspective projection matrix with");
            methods.document("`[0,1]` depth range.");
            methods.add_function("perspective_infinite_rh", |_, a: (f32, f32, f32)| {
                Ok(LuaMat4::new(Mat4::perspective_infinite_rh(a.0, a.1, a.2)))
            });
            methods
                .document("Creates an infinite reverse right-handed perspective projection matrix");
            methods.document("with `[0,1]` depth range.");
            methods.add_function(
                "perspective_infinite_reverse_rh",
                |_, a: (f32, f32, f32)| {
                    Ok(LuaMat4::new(Mat4::perspective_infinite_reverse_rh(
                        a.0, a.1, a.2,
                    )))
                },
            );
            methods.document(
                "Creates a right-handed orthographic projection matrix with `[-1,1]` depth",
            );
            methods
                .document("range.  This is the same as the OpenGL `glOrtho` function in OpenGL.");
            methods.document("See");
            methods.document(
                "<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>",
            );
            methods.add_function(
                "orthographic_rh_gl",
                |_, a: (f32, f32, f32, f32, f32, f32)| {
                    Ok(LuaMat4::new(Mat4::orthographic_rh_gl(
                        a.0, a.1, a.2, a.3, a.4, a.5,
                    )))
                },
            );
            methods.document(
                "Creates a left-handed orthographic projection matrix with `[0,1]` depth range.",
            );
            methods.add_function("orthographic_lh", |_, a: (f32, f32, f32, f32, f32, f32)| {
                Ok(LuaMat4::new(Mat4::orthographic_lh(
                    a.0, a.1, a.2, a.3, a.4, a.5,
                )))
            });
            methods.document(
                "Creates a right-handed orthographic projection matrix with `[0,1]` depth range.",
            );
            methods.add_function("orthographic_rh", |_, a: (f32, f32, f32, f32, f32, f32)| {
                Ok(LuaMat4::new(Mat4::orthographic_rh(
                    a.0, a.1, a.2, a.3, a.4, a.5,
                )))
            });
        }
    }
    impl tealr::TypeName for LuaMat4Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaMat4Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaMat4Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaMat4Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaDMat3Globals;
    impl tealr::mlu::TealData for LuaDMat3Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for DMat3");
            methods.document("Creates a 3x3 matrix from three column vectors.");
            methods.add_function("from_cols", |_, a: (LuaDVec3, LuaDVec3, LuaDVec3)| {
                Ok(LuaDMat3::new(DMat3::from_cols(
                    a.0.inner(),
                    a.1.inner(),
                    a.2.inner(),
                )))
            });
            methods . document ("Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.") ;
            methods.document("The resulting matrix is a 3D scale transfom.");
            methods.add_function("from_diagonal", |_, a: (LuaDVec3)| {
                Ok(LuaDMat3::new(DMat3::from_diagonal(a.inner())))
            });
            methods.document(
                "Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.",
            );
            methods.add_function("from_mat4", |_, a: (LuaDMat4)| {
                Ok(LuaDMat3::new(DMat3::from_mat4(a.inner())))
            });
            methods.document("Creates a 3D rotation matrix from the given quaternion.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_quat", |_, a: (LuaDQuat)| {
                Ok(LuaDMat3::new(DMat3::from_quat(a.inner())))
            });
            methods.document(
                "Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in",
            );
            methods.document("radians).");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `axis` is not normalized when `glam_assert` is enabled.");
            methods.add_function("from_axis_angle", |_, a: (LuaDVec3, f64)| {
                Ok(LuaDMat3::new(DMat3::from_axis_angle(a.0.inner(), a.1)))
            });
            methods . document ("Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in") ;
            methods.document("radians).");
            methods.add_function("from_euler", |_, a: (LuaEulerRot, f64, f64, f64)| {
                Ok(LuaDMat3::new(DMat3::from_euler(a.0.inner(), a.1, a.2, a.3)))
            });
            methods.document(
                "Creates a 3D rotation matrix from `angle` (in radians) around the x axis.",
            );
            methods.add_function("from_rotation_x", |_, a: (f64)| {
                Ok(LuaDMat3::new(DMat3::from_rotation_x(a)))
            });
            methods.document(
                "Creates a 3D rotation matrix from `angle` (in radians) around the y axis.",
            );
            methods.add_function("from_rotation_y", |_, a: (f64)| {
                Ok(LuaDMat3::new(DMat3::from_rotation_y(a)))
            });
            methods.document(
                "Creates a 3D rotation matrix from `angle` (in radians) around the z axis.",
            );
            methods.add_function("from_rotation_z", |_, a: (f64)| {
                Ok(LuaDMat3::new(DMat3::from_rotation_z(a)))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 2D `translation`.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 2D points and vectors. See",
            );
            methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
            methods.add_function("from_translation", |_, a: (LuaDVec2)| {
                Ok(LuaDMat3::new(DMat3::from_translation(a.inner())))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 2D rotation `angle` (in",
            );
            methods.document("radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 2D points and vectors. See",
            );
            methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
            methods.add_function("from_angle", |_, a: (f64)| {
                Ok(LuaDMat3::new(DMat3::from_angle(a)))
            });
            methods . document ("Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in") ;
            methods.document("radians) and `translation`.");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 2D points and vectors. See",
            );
            methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
            methods.add_function(
                "from_scale_angle_translation",
                |_, a: (LuaDVec2, f64, LuaDVec2)| {
                    Ok(LuaDMat3::new(DMat3::from_scale_angle_translation(
                        a.0.inner(),
                        a.1,
                        a.2.inner(),
                    )))
                },
            );
            methods.document(
                "Creates an affine transformation matrix from the given non-uniform 2D `scale`.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 2D points and vectors. See",
            );
            methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
            );
            methods.add_function("from_scale", |_, a: (LuaDVec2)| {
                Ok(LuaDMat3::new(DMat3::from_scale(a.inner())))
            });
        }
    }
    impl tealr::TypeName for LuaDMat3Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDMat3Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDMat3Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDMat3Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaDMat4Globals;
    impl tealr::mlu::TealData for LuaDMat4Globals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for DMat4");
            methods.document("Creates a 4x4 matrix from four column vectors.");
            methods.add_function(
                "from_cols",
                |_, a: (LuaDVec4, LuaDVec4, LuaDVec4, LuaDVec4)| {
                    Ok(LuaDMat4::new(DMat4::from_cols(
                        a.0.inner(),
                        a.1.inner(),
                        a.2.inner(),
                        a.3.inner(),
                    )))
                },
            );
            methods . document ("Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.") ;
            methods.add_function("from_diagonal", |_, a: (LuaDVec4)| {
                Ok(LuaDMat4::new(DMat4::from_diagonal(a.inner())))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 3D `scale`, `rotation` and",
            );
            methods.document("`translation`.");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
            );
            methods.add_function(
                "from_scale_rotation_translation",
                |_, a: (LuaDVec3, LuaDQuat, LuaDVec3)| {
                    Ok(LuaDMat4::new(DMat4::from_scale_rotation_translation(
                        a.0.inner(),
                        a.1.inner(),
                        a.2.inner(),
                    )))
                },
            );
            methods.document(
                "Creates an affine transformation matrix from the given 3D `translation`.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_rotation_translation", |_, a: (LuaDQuat, LuaDVec3)| {
                Ok(LuaDMat4::new(DMat4::from_rotation_translation(
                    a.0.inner(),
                    a.1.inner(),
                )))
            });
            methods.document(
                "Creates an affine transformation matrix from the given `rotation` quaternion.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_quat", |_, a: (LuaDQuat)| {
                Ok(LuaDMat4::new(DMat4::from_quat(a.inner())))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 3x3 linear transformation",
            );
            methods.document("matrix.");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_mat3", |_, a: (LuaDMat3)| {
                Ok(LuaDMat4::new(DMat4::from_mat3(a.inner())))
            });
            methods.document(
                "Creates an affine transformation matrix from the given 3D `translation`.",
            );
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_translation", |_, a: (LuaDVec3)| {
                Ok(LuaDMat4::new(DMat4::from_translation(a.inner())))
            });
            methods . document ("Creates an affine transformation matrix containing a 3D rotation around a normalized") ;
            methods.document("rotation `axis` of `angle` (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `axis` is not normalized when `glam_assert` is enabled.");
            methods.add_function("from_axis_angle", |_, a: (LuaDVec3, f64)| {
                Ok(LuaDMat4::new(DMat4::from_axis_angle(a.0.inner(), a.1)))
            });
            methods.document(
                "Creates a affine transformation matrix containing a rotation from the given euler",
            );
            methods.document("rotation sequence and angles (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_euler", |_, a: (LuaEulerRot, f64, f64, f64)| {
                Ok(LuaDMat4::new(DMat4::from_euler(a.0.inner(), a.1, a.2, a.3)))
            });
            methods . document ("Creates an affine transformation matrix containing a 3D rotation around the x axis of") ;
            methods.document("`angle` (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_rotation_x", |_, a: (f64)| {
                Ok(LuaDMat4::new(DMat4::from_rotation_x(a)))
            });
            methods . document ("Creates an affine transformation matrix containing a 3D rotation around the y axis of") ;
            methods.document("`angle` (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_rotation_y", |_, a: (f64)| {
                Ok(LuaDMat4::new(DMat4::from_rotation_y(a)))
            });
            methods . document ("Creates an affine transformation matrix containing a 3D rotation around the z axis of") ;
            methods.document("`angle` (in radians).");
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.add_function("from_rotation_z", |_, a: (f64)| {
                Ok(LuaDMat4::new(DMat4::from_rotation_z(a)))
            });
            methods . document ("Creates an affine transformation matrix containing the given 3D non-uniform `scale`.") ;
            methods.document("");
            methods.document(
                "The resulting matrix can be used to transform 3D points and vectors. See",
            );
            methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
            );
            methods.add_function("from_scale", |_, a: (LuaDVec3)| {
                Ok(LuaDMat4::new(DMat4::from_scale(a.inner())))
            });
            methods . document ("Creates a left-handed view matrix using a camera position, an up direction, and a focal") ;
            methods.document("point.");
            methods.document(
                "For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `up` is not normalized when `glam_assert` is enabled.");
            methods.add_function("look_at_lh", |_, a: (LuaDVec3, LuaDVec3, LuaDVec3)| {
                Ok(LuaDMat4::new(DMat4::look_at_lh(
                    a.0.inner(),
                    a.1.inner(),
                    a.2.inner(),
                )))
            });
            methods . document ("Creates a right-handed view matrix using a camera position, an up direction, and a focal") ;
            methods.document("point.");
            methods
                .document("For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document("Will panic if `up` is not normalized when `glam_assert` is enabled.");
            methods.add_function("look_at_rh", |_, a: (LuaDVec3, LuaDVec3, LuaDVec3)| {
                Ok(LuaDMat4::new(DMat4::look_at_rh(
                    a.0.inner(),
                    a.1.inner(),
                    a.2.inner(),
                )))
            });
            methods.document(
                "Creates a right-handed perspective projection matrix with [-1,1] depth range.",
            );
            methods.document("This is the same as the OpenGL `gluPerspective` function.");
            methods . document ("See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>") ;
            methods.add_function("perspective_rh_gl", |_, a: (f64, f64, f64, f64)| {
                Ok(LuaDMat4::new(DMat4::perspective_rh_gl(a.0, a.1, a.2, a.3)))
            });
            methods.document(
                "Creates a left-handed perspective projection matrix with `[0,1]` depth range.",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is") ;
            methods.document("enabled.");
            methods.add_function("perspective_lh", |_, a: (f64, f64, f64, f64)| {
                Ok(LuaDMat4::new(DMat4::perspective_lh(a.0, a.1, a.2, a.3)))
            });
            methods.document(
                "Creates a right-handed perspective projection matrix with `[0,1]` depth range.",
            );
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is") ;
            methods.document("enabled.");
            methods.add_function("perspective_rh", |_, a: (f64, f64, f64, f64)| {
                Ok(LuaDMat4::new(DMat4::perspective_rh(a.0, a.1, a.2, a.3)))
            });
            methods . document ("Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.") ;
            methods.add_function("perspective_infinite_lh", |_, a: (f64, f64, f64)| {
                Ok(LuaDMat4::new(DMat4::perspective_infinite_lh(a.0, a.1, a.2)))
            });
            methods . document ("Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.") ;
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods . document ("Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.") ;
            methods.add_function(
                "perspective_infinite_reverse_lh",
                |_, a: (f64, f64, f64)| {
                    Ok(LuaDMat4::new(DMat4::perspective_infinite_reverse_lh(
                        a.0, a.1, a.2,
                    )))
                },
            );
            methods.document("Creates an infinite right-handed perspective projection matrix with");
            methods.document("`[0,1]` depth range.");
            methods.add_function("perspective_infinite_rh", |_, a: (f64, f64, f64)| {
                Ok(LuaDMat4::new(DMat4::perspective_infinite_rh(a.0, a.1, a.2)))
            });
            methods
                .document("Creates an infinite reverse right-handed perspective projection matrix");
            methods.document("with `[0,1]` depth range.");
            methods.add_function(
                "perspective_infinite_reverse_rh",
                |_, a: (f64, f64, f64)| {
                    Ok(LuaDMat4::new(DMat4::perspective_infinite_reverse_rh(
                        a.0, a.1, a.2,
                    )))
                },
            );
            methods.document(
                "Creates a right-handed orthographic projection matrix with `[-1,1]` depth",
            );
            methods
                .document("range.  This is the same as the OpenGL `glOrtho` function in OpenGL.");
            methods.document("See");
            methods.document(
                "<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>",
            );
            methods.add_function(
                "orthographic_rh_gl",
                |_, a: (f64, f64, f64, f64, f64, f64)| {
                    Ok(LuaDMat4::new(DMat4::orthographic_rh_gl(
                        a.0, a.1, a.2, a.3, a.4, a.5,
                    )))
                },
            );
            methods.document(
                "Creates a left-handed orthographic projection matrix with `[0,1]` depth range.",
            );
            methods.add_function("orthographic_lh", |_, a: (f64, f64, f64, f64, f64, f64)| {
                Ok(LuaDMat4::new(DMat4::orthographic_lh(
                    a.0, a.1, a.2, a.3, a.4, a.5,
                )))
            });
            methods.document(
                "Creates a right-handed orthographic projection matrix with `[0,1]` depth range.",
            );
            methods.add_function("orthographic_rh", |_, a: (f64, f64, f64, f64, f64, f64)| {
                Ok(LuaDMat4::new(DMat4::orthographic_rh(
                    a.0, a.1, a.2, a.3, a.4, a.5,
                )))
            });
        }
    }
    impl tealr::TypeName for LuaDMat4Globals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDMat4Globals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDMat4Globals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDMat4Globals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaQuatGlobals;
    impl tealr::mlu::TealData for LuaQuatGlobals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for Quat");
            methods.document("Creates a new rotation quaternion.");
            methods.document("");
            methods.document(
                "This should generally not be called manually unless you know what you are doing.",
            );
            methods . document ("Use one of the other constructors instead such as `identity` or `from_axis_angle`.") ;
            methods.document("");
            methods
                .document("`from_xyzw` is mostly used by unit tests and `serde` deserialization.");
            methods.document("");
            methods.document("# Preconditions");
            methods.document("");
            methods.document(
                "This function does not check if the input is normalized, it is up to the user to",
            );
            methods.document("provide normalized input or to normalized the resulting quaternion.");
            methods.add_function("from_xyzw", |_, a: (f32, f32, f32, f32)| {
                Ok(LuaQuat::new(Quat::from_xyzw(a.0, a.1, a.2, a.3)))
            });
            methods.document("Creates a new rotation quaternion from a 4D vector.");
            methods.document("");
            methods.document("# Preconditions");
            methods.document("");
            methods.document(
                "This function does not check if the input is normalized, it is up to the user to",
            );
            methods.document("provide normalized input or to normalized the resulting quaternion.");
            methods.add_function("from_vec4", |_, a: (LuaVec4)| {
                Ok(LuaQuat::new(Quat::from_vec4(a.inner())))
            });
            methods.document(
                "Create a quaternion for a normalized rotation `axis` and `angle` (in radians).",
            );
            methods.document("The axis must be normalized (unit-length).");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `axis` is not normalized when `glam_assert` is enabled.");
            methods.add_function("from_axis_angle", |_, a: (LuaVec3, f32)| {
                Ok(LuaQuat::new(Quat::from_axis_angle(a.0.inner(), a.1)))
            });
            methods.document(
                "Create a quaternion that rotates `v.length()` radians around `v.normalize()`.",
            );
            methods.document("");
            methods.document("`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.");
            methods.add_function("from_scaled_axis", |_, a: (LuaVec3)| {
                Ok(LuaQuat::new(Quat::from_scaled_axis(a.inner())))
            });
            methods
                .document("Creates a quaternion from the `angle` (in radians) around the x axis.");
            methods.add_function("from_rotation_x", |_, a: (f32)| {
                Ok(LuaQuat::new(Quat::from_rotation_x(a)))
            });
            methods
                .document("Creates a quaternion from the `angle` (in radians) around the y axis.");
            methods.add_function("from_rotation_y", |_, a: (f32)| {
                Ok(LuaQuat::new(Quat::from_rotation_y(a)))
            });
            methods
                .document("Creates a quaternion from the `angle` (in radians) around the z axis.");
            methods.add_function("from_rotation_z", |_, a: (f32)| {
                Ok(LuaQuat::new(Quat::from_rotation_z(a)))
            });
            methods . document ("Creates a quaternion from the given euler rotation sequence and the angles (in radians).") ;
            methods.add_function("from_euler", |_, a: (LuaEulerRot, f32, f32, f32)| {
                Ok(LuaQuat::new(Quat::from_euler(a.0.inner(), a.1, a.2, a.3)))
            });
            methods . document ("Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the") ;
            methods.document("plane spanned by the two vectors.  Will rotate at most 180 degrees.");
            methods.document("");
            methods.document("The input vectors must be normalized (unit-length).");
            methods.document("");
            methods.document("`from_rotation_arc(from, to) * from ≈ to`.");
            methods.document("");
            methods.document(
                "For near-singular cases (from≈to and from≈-to) the current implementation",
            );
            methods.document("is only accurate to about 0.001 (for `f32`).");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_rotation_arc", |_, a: (LuaVec3, LuaVec3)| {
                Ok(LuaQuat::new(Quat::from_rotation_arc(
                    a.0.inner(),
                    a.1.inner(),
                )))
            });
            methods . document ("Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means") ;
            methods . document ("that the resulting quaternion will rotate `from` so that it is colinear with `to`.") ;
            methods.document("");
            methods.document(
                "The rotation is in the plane spanned by the two vectors.  Will rotate at most 90",
            );
            methods.document("degrees.");
            methods.document("");
            methods.document("The input vectors must be normalized (unit-length).");
            methods.document("");
            methods.document("`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_rotation_arc_colinear", |_, a: (LuaVec3, LuaVec3)| {
                Ok(LuaQuat::new(Quat::from_rotation_arc_colinear(
                    a.0.inner(),
                    a.1.inner(),
                )))
            });
            methods . document ("Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is") ;
            methods.document("around the z axis. Will rotate at most 180 degrees.");
            methods.document("");
            methods.document("The input vectors must be normalized (unit-length).");
            methods.document("");
            methods.document("`from_rotation_arc_2d(from, to) * from ≈ to`.");
            methods.document("");
            methods.document(
                "For near-singular cases (from≈to and from≈-to) the current implementation",
            );
            methods.document("is only accurate to about 0.001 (for `f32`).");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_rotation_arc_2d", |_, a: (LuaVec2, LuaVec2)| {
                Ok(LuaQuat::new(Quat::from_rotation_arc_2d(
                    a.0.inner(),
                    a.1.inner(),
                )))
            });
        }
    }
    impl tealr::TypeName for LuaQuatGlobals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaQuatGlobals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaQuatGlobals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaQuatGlobals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    struct LuaDQuatGlobals;
    impl tealr::mlu::TealData for LuaDQuatGlobals {
        fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
            methods.document_type("Global methods for DQuat");
            methods.document("Creates a new rotation quaternion.");
            methods.document("");
            methods.document(
                "This should generally not be called manually unless you know what you are doing.",
            );
            methods . document ("Use one of the other constructors instead such as `identity` or `from_axis_angle`.") ;
            methods.document("");
            methods
                .document("`from_xyzw` is mostly used by unit tests and `serde` deserialization.");
            methods.document("");
            methods.document("# Preconditions");
            methods.document("");
            methods.document(
                "This function does not check if the input is normalized, it is up to the user to",
            );
            methods.document("provide normalized input or to normalized the resulting quaternion.");
            methods.add_function("from_xyzw", |_, a: (f64, f64, f64, f64)| {
                Ok(LuaDQuat::new(DQuat::from_xyzw(a.0, a.1, a.2, a.3)))
            });
            methods.document("Creates a new rotation quaternion from a 4D vector.");
            methods.document("");
            methods.document("# Preconditions");
            methods.document("");
            methods.document(
                "This function does not check if the input is normalized, it is up to the user to",
            );
            methods.document("provide normalized input or to normalized the resulting quaternion.");
            methods.add_function("from_vec4", |_, a: (LuaDVec4)| {
                Ok(LuaDQuat::new(DQuat::from_vec4(a.inner())))
            });
            methods.document(
                "Create a quaternion for a normalized rotation `axis` and `angle` (in radians).",
            );
            methods.document("The axis must be normalized (unit-length).");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods
                .document("Will panic if `axis` is not normalized when `glam_assert` is enabled.");
            methods.add_function("from_axis_angle", |_, a: (LuaDVec3, f64)| {
                Ok(LuaDQuat::new(DQuat::from_axis_angle(a.0.inner(), a.1)))
            });
            methods.document(
                "Create a quaternion that rotates `v.length()` radians around `v.normalize()`.",
            );
            methods.document("");
            methods.document("`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.");
            methods.add_function("from_scaled_axis", |_, a: (LuaDVec3)| {
                Ok(LuaDQuat::new(DQuat::from_scaled_axis(a.inner())))
            });
            methods
                .document("Creates a quaternion from the `angle` (in radians) around the x axis.");
            methods.add_function("from_rotation_x", |_, a: (f64)| {
                Ok(LuaDQuat::new(DQuat::from_rotation_x(a)))
            });
            methods
                .document("Creates a quaternion from the `angle` (in radians) around the y axis.");
            methods.add_function("from_rotation_y", |_, a: (f64)| {
                Ok(LuaDQuat::new(DQuat::from_rotation_y(a)))
            });
            methods
                .document("Creates a quaternion from the `angle` (in radians) around the z axis.");
            methods.add_function("from_rotation_z", |_, a: (f64)| {
                Ok(LuaDQuat::new(DQuat::from_rotation_z(a)))
            });
            methods . document ("Creates a quaternion from the given euler rotation sequence and the angles (in radians).") ;
            methods.add_function("from_euler", |_, a: (LuaEulerRot, f64, f64, f64)| {
                Ok(LuaDQuat::new(DQuat::from_euler(a.0.inner(), a.1, a.2, a.3)))
            });
            methods . document ("Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the") ;
            methods.document("plane spanned by the two vectors.  Will rotate at most 180 degrees.");
            methods.document("");
            methods.document("The input vectors must be normalized (unit-length).");
            methods.document("");
            methods.document("`from_rotation_arc(from, to) * from ≈ to`.");
            methods.document("");
            methods.document(
                "For near-singular cases (from≈to and from≈-to) the current implementation",
            );
            methods.document("is only accurate to about 0.001 (for `f32`).");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_rotation_arc", |_, a: (LuaDVec3, LuaDVec3)| {
                Ok(LuaDQuat::new(DQuat::from_rotation_arc(
                    a.0.inner(),
                    a.1.inner(),
                )))
            });
            methods . document ("Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means") ;
            methods . document ("that the resulting quaternion will rotate `from` so that it is colinear with `to`.") ;
            methods.document("");
            methods.document(
                "The rotation is in the plane spanned by the two vectors.  Will rotate at most 90",
            );
            methods.document("degrees.");
            methods.document("");
            methods.document("The input vectors must be normalized (unit-length).");
            methods.document("");
            methods.document("`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_function(
                "from_rotation_arc_colinear",
                |_, a: (LuaDVec3, LuaDVec3)| {
                    Ok(LuaDQuat::new(DQuat::from_rotation_arc_colinear(
                        a.0.inner(),
                        a.1.inner(),
                    )))
                },
            );
            methods . document ("Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is") ;
            methods.document("around the z axis. Will rotate at most 180 degrees.");
            methods.document("");
            methods.document("The input vectors must be normalized (unit-length).");
            methods.document("");
            methods.document("`from_rotation_arc_2d(from, to) * from ≈ to`.");
            methods.document("");
            methods.document(
                "For near-singular cases (from≈to and from≈-to) the current implementation",
            );
            methods.document("is only accurate to about 0.001 (for `f32`).");
            methods.document("");
            methods.document("# Panics");
            methods.document("");
            methods.document(
                "Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.",
            );
            methods.add_function("from_rotation_arc_2d", |_, a: (LuaDVec2, LuaDVec2)| {
                Ok(LuaDQuat::new(DQuat::from_rotation_arc_2d(
                    a.0.inner(),
                    a.1.inner(),
                )))
            });
        }
    }
    impl tealr::TypeName for LuaDQuatGlobals {
        fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
            std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                name: std::borrow::Cow::Borrowed("LuaDQuatGlobals"),
                generics: None,
                type_kind: tealr::KindOfType::External,
            })])
        }
    }
    impl mlua::UserData for LuaDQuatGlobals {
        fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
            let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
            <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
        }
        fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(methods: &mut M) {
            let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
        }
    }
    impl tealr::TypeBody for LuaDQuatGlobals {
        fn get_type_body() -> tealr::TypeGenerator {
            let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
            gen.is_user_data = true;
            <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
            <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
            <_ as ::std::convert::From<_>>::from(gen)
        }
    }
    pub struct LuaBevyAPIProvider;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for LuaBevyAPIProvider {
        #[inline]
        fn default() -> LuaBevyAPIProvider {
            LuaBevyAPIProvider {}
        }
    }
    impl crate::APIProvider for LuaBevyAPIProvider {
        type Target = ::std::sync::Mutex<Lua>;
        type DocTarget = crate::LuaDocFragment;
        fn attach_api(
            &mut self,
            c: &mut <Self as crate::APIProvider>::Target,
        ) -> Result<(), crate::ScriptError> {
            let lua_ctx = c.lock().expect("Could not get lock on script context");
            tealr::mlu::set_global_env::<BevyAPIGlobals>(&lua_ctx)?;
            Ok(())
        }
        fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
            Some(crate::LuaDocFragment::new(|tw| {
                tw.document_global_instance::<BevyAPIGlobals>()
                    .unwrap()
                    .process_type::<LuaEntity>()
                    .process_type::<LuaVec2>()
                    .process_type::<LuaVec3>()
                    .process_type::<LuaVec4>()
                    .process_type::<LuaDVec2>()
                    .process_type::<LuaDVec3>()
                    .process_type::<LuaDVec4>()
                    .process_type::<LuaIVec2>()
                    .process_type::<LuaIVec3>()
                    .process_type::<LuaIVec4>()
                    .process_type::<LuaUVec2>()
                    .process_type::<LuaUVec3>()
                    .process_type::<LuaUVec4>()
                    .process_type::<LuaMat3>()
                    .process_type::<LuaMat4>()
                    .process_type::<LuaDMat3>()
                    .process_type::<LuaDMat4>()
                    .process_type::<LuaQuat>()
                    .process_type::<LuaDQuat>()
                    .process_type::<LuaEulerRot>()
                    .process_type::<LuaEntityGlobals>()
                    .process_type::<LuaVec2Globals>()
                    .process_type::<LuaVec3Globals>()
                    .process_type::<LuaVec4Globals>()
                    .process_type::<LuaDVec2Globals>()
                    .process_type::<LuaDVec3Globals>()
                    .process_type::<LuaDVec4Globals>()
                    .process_type::<LuaIVec2Globals>()
                    .process_type::<LuaIVec3Globals>()
                    .process_type::<LuaIVec4Globals>()
                    .process_type::<LuaUVec2Globals>()
                    .process_type::<LuaUVec3Globals>()
                    .process_type::<LuaUVec4Globals>()
                    .process_type::<LuaMat3Globals>()
                    .process_type::<LuaMat4Globals>()
                    .process_type::<LuaDMat3Globals>()
                    .process_type::<LuaDMat4Globals>()
                    .process_type::<LuaQuatGlobals>()
                    .process_type::<LuaDQuatGlobals>()
                    .process_type::<LuaComponent>()
                    .process_type::<LuaResource>()
                    .process_type::<LuaWorld>()
            }))
        }
    }
    pub static BEVY_TO_LUA: Map<
        &'static str,
        for<'l> fn(&crate::LuaRef, &'l Lua) -> tealr::mlu::mlua::Value<'l>,
    > = {
        #[allow(dead_code)]
        enum ProcMacroHack {
            Value = ("\"usize\" => | r, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < usize > ().unwrap().to_i64().unwrap())), \"isize\"\n=> | r, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < isize > ().unwrap().to_i64().unwrap())), \"i128\" =>\n| r, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i128 > ().unwrap().to_i64().unwrap())), \"i64\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i64 > ().unwrap().to_i64().unwrap())), \"i32\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i32 > ().unwrap().to_i64().unwrap())), \"i16\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i16 > ().unwrap().to_i64().unwrap())), \"i8\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i8 > ().unwrap().to_i64().unwrap())), \"u128\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u128 > ().unwrap().to_i64().unwrap())), \"u64\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u64 > ().unwrap().to_i64().unwrap())), \"u32\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u32 > ().unwrap().to_i64().unwrap())), \"u16\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u16 > ().unwrap().to_i64().unwrap())), \"u8\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u8 > ().unwrap().to_i64().unwrap())), \"f32\" => |\nr, _ |\nr.get(| s, _ | Value ::\nNumber(s.downcast_ref :: < f32 > ().unwrap().to_f64().unwrap())), \"f64\" => |\nr, _ |\nr.get(| s, _ | Value ::\nNumber(s.downcast_ref :: < f64 > ().unwrap().to_f64().unwrap())),\n\"alloc::string::String\" => | r, c |\nr.get(| s, _ | Value ::\nString(c.create_string(s.downcast_ref :: < String > ().unwrap()).unwrap())),\n\"bevy_ecs::entity::Entity\" => | r, c |\n{\n    let usr = c.create_userdata(LuaEntity :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::Vec2\" => | r, c |\n{\n    let usr = c.create_userdata(LuaVec2 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::Vec3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaVec3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::Vec4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaVec4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::DVec2\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDVec2 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::DVec3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDVec3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::DVec4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDVec4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::i32::IVec2\" => | r, c |\n{\n    let usr = c.create_userdata(LuaIVec2 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::i32::IVec3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaIVec3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::i32::IVec4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaIVec4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::u32::UVec2\" => | r, c |\n{\n    let usr = c.create_userdata(LuaUVec2 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::u32::UVec3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaUVec3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::u32::UVec4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaUVec4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::Mat3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaMat3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::Mat4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaMat4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::DMat3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDMat3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::DMat4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDMat4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::Quat\" => | r, c |\n{\n    let usr = c.create_userdata(LuaQuat :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::DQuat\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDQuat :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}," , 0) . 1 , }
        phf::Map {
            key: 12913932095322966823u64,
            disps: &[
                (0u32, 15u32),
                (1u32, 8u32),
                (3u32, 6u32),
                (22u32, 33u32),
                (4u32, 0u32),
                (30u32, 18u32),
                (4u32, 29u32),
            ],
            entries: &[
                ("glam::f64::DQuat", |r, c| {
                    let usr = c.create_userdata(LuaDQuat::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::f32::Vec3", |r, c| {
                    let usr = c.create_userdata(LuaVec3::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::f64::DVec4", |r, c| {
                    let usr = c.create_userdata(LuaDVec4::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("isize", |r, _| {
                    r.get(|s, _| {
                        Value::Integer(s.downcast_ref::<isize>().unwrap().to_i64().unwrap())
                    })
                }),
                ("glam::i32::IVec2", |r, c| {
                    let usr = c.create_userdata(LuaIVec2::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("i16", |r, _| {
                    r.get(|s, _| Value::Integer(s.downcast_ref::<i16>().unwrap().to_i64().unwrap()))
                }),
                ("u16", |r, _| {
                    r.get(|s, _| Value::Integer(s.downcast_ref::<u16>().unwrap().to_i64().unwrap()))
                }),
                ("i64", |r, _| {
                    r.get(|s, _| Value::Integer(s.downcast_ref::<i64>().unwrap().to_i64().unwrap()))
                }),
                ("f64", |r, _| {
                    r.get(|s, _| Value::Number(s.downcast_ref::<f64>().unwrap().to_f64().unwrap()))
                }),
                ("u32", |r, _| {
                    r.get(|s, _| Value::Integer(s.downcast_ref::<u32>().unwrap().to_i64().unwrap()))
                }),
                ("bevy_ecs::entity::Entity", |r, c| {
                    let usr = c.create_userdata(LuaEntity::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("i32", |r, _| {
                    r.get(|s, _| Value::Integer(s.downcast_ref::<i32>().unwrap().to_i64().unwrap()))
                }),
                ("glam::u32::UVec4", |r, c| {
                    let usr = c.create_userdata(LuaUVec4::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::f64::DMat4", |r, c| {
                    let usr = c.create_userdata(LuaDMat4::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("u128", |r, _| {
                    r.get(|s, _| {
                        Value::Integer(s.downcast_ref::<u128>().unwrap().to_i64().unwrap())
                    })
                }),
                ("u8", |r, _| {
                    r.get(|s, _| Value::Integer(s.downcast_ref::<u8>().unwrap().to_i64().unwrap()))
                }),
                ("glam::f32::Vec2", |r, c| {
                    let usr = c.create_userdata(LuaVec2::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::f64::DVec2", |r, c| {
                    let usr = c.create_userdata(LuaDVec2::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("u64", |r, _| {
                    r.get(|s, _| Value::Integer(s.downcast_ref::<u64>().unwrap().to_i64().unwrap()))
                }),
                ("glam::u32::UVec2", |r, c| {
                    let usr = c.create_userdata(LuaUVec2::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::f64::DMat3", |r, c| {
                    let usr = c.create_userdata(LuaDMat3::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("i128", |r, _| {
                    r.get(|s, _| {
                        Value::Integer(s.downcast_ref::<i128>().unwrap().to_i64().unwrap())
                    })
                }),
                ("f32", |r, _| {
                    r.get(|s, _| Value::Number(s.downcast_ref::<f32>().unwrap().to_f64().unwrap()))
                }),
                ("glam::i32::IVec3", |r, c| {
                    let usr = c.create_userdata(LuaIVec3::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("usize", |r, _| {
                    r.get(|s, _| {
                        Value::Integer(s.downcast_ref::<usize>().unwrap().to_i64().unwrap())
                    })
                }),
                ("glam::f32::Mat3", |r, c| {
                    let usr = c.create_userdata(LuaMat3::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("alloc::string::String", |r, c| {
                    r.get(|s, _| {
                        Value::String(
                            c.create_string(s.downcast_ref::<String>().unwrap())
                                .unwrap(),
                        )
                    })
                }),
                ("glam::f32::Quat", |r, c| {
                    let usr = c.create_userdata(LuaQuat::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::i32::IVec4", |r, c| {
                    let usr = c.create_userdata(LuaIVec4::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::f32::Vec4", |r, c| {
                    let usr = c.create_userdata(LuaVec4::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::u32::UVec3", |r, c| {
                    let usr = c.create_userdata(LuaUVec3::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("glam::f64::DVec3", |r, c| {
                    let usr = c.create_userdata(LuaDVec3::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
                ("i8", |r, _| {
                    r.get(|s, _| Value::Integer(s.downcast_ref::<i8>().unwrap().to_i64().unwrap()))
                }),
                ("glam::f32::Mat4", |r, c| {
                    let usr = c.create_userdata(LuaMat4::base_to_self(r)).unwrap();
                    Value::UserData(usr)
                }),
            ],
        }
    };
    pub static APPLY_LUA_TO_BEVY: Map<
        &'static str,
        for<'l> fn(
            &mut crate::LuaRef,
            &'l Lua,
            tealr::mlu::mlua::Value<'l>,
        ) -> Result<(), tealr::mlu::mlua::Error>,
    > = {
        #[allow(dead_code)]
        enum ProcMacroHack {
            Value = ("\"usize\" => | r, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_usize().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with usize\".to_owned())) ?))), \"isize\" =>\n| r, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_isize().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with isize\".to_owned())) ?))), \"i128\" => |\nr, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i128().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i128\".to_owned())) ?))), \"i64\" => |\nr, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i64().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i64\".to_owned())) ?))), \"i32\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i32().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i32\".to_owned())) ?))), \"i16\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i16().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i16\".to_owned())) ?))), \"i8\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i8().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i8\".to_owned())) ?))), \"u128\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u128().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u128\".to_owned())) ?))), \"u64\" => |\nr, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u64().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u64\".to_owned())) ?))), \"u32\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u32().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u32\".to_owned())) ?))), \"u16\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u16().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u16\".to_owned())) ?))), \"u8\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u8().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u8\".to_owned())) ?))), \"f32\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_number(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not a number\".to_owned()))\n?.to_f32().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with f32\".to_owned())) ?))), \"f64\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_number(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not a number\".to_owned()))\n?.to_f64().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with f64\".to_owned())) ?))),\n\"alloc::string::String\" => | r, c, v : Value | c.coerce_string(v)\n?.ok_or_else(| | Error ::\nRuntimeError(\"Not a string\".to_owned())).and_then(| string |\nr.get_mut(| s, _ | Ok(s.apply(& string.to_str() ?.to_owned())))),\n\"bevy_ecs::entity::Entity\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaEntity > () ? ; LuaEntity ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::Vec2\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaVec2 > () ? ; LuaVec2 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::Vec3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaVec3 > () ? ; LuaVec3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::Vec4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaVec4 > () ? ; LuaVec4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::DVec2\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDVec2 > () ? ; LuaDVec2 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::DVec3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDVec3 > () ? ; LuaDVec3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::DVec4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDVec4 > () ? ; LuaDVec4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::i32::IVec2\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaIVec2 > () ? ; LuaIVec2 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::i32::IVec3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaIVec3 > () ? ; LuaIVec3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::i32::IVec4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaIVec4 > () ? ; LuaIVec4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::u32::UVec2\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaUVec2 > () ? ; LuaUVec2 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::u32::UVec3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaUVec3 > () ? ; LuaUVec3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::u32::UVec4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaUVec4 > () ? ; LuaUVec4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::Mat3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaMat3 > () ? ; LuaMat3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::Mat4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaMat4 > () ? ; LuaMat4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::DMat3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDMat3 > () ? ; LuaDMat3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::DMat4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDMat4 > () ? ; LuaDMat4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::Quat\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaQuat > () ? ; LuaQuat ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::DQuat\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDQuat > () ? ; LuaDQuat ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}," , 0) . 1 , }
        phf::Map {
            key: 12913932095322966823u64,
            disps: &[
                (0u32, 15u32),
                (1u32, 8u32),
                (3u32, 6u32),
                (22u32, 33u32),
                (4u32, 0u32),
                (30u32, 18u32),
                (4u32, 29u32),
            ],
            entries: &[
                ("glam::f64::DQuat", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaDQuat>()?;
                        LuaDQuat::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::f32::Vec3", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaVec3>()?;
                        LuaVec3::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::f64::DVec4", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaDVec4>()?;
                        LuaDVec4::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("isize", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_isize()
                                .ok_or_else(|| {
                                    Error::RuntimeError(
                                        "Value not compatibile with isize".to_owned(),
                                    )
                                })?,
                        ))
                    })
                }),
                ("glam::i32::IVec2", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaIVec2>()?;
                        LuaIVec2::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("i16", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_i16()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with i16".to_owned())
                                })?,
                        ))
                    })
                }),
                ("u16", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_u16()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with u16".to_owned())
                                })?,
                        ))
                    })
                }),
                ("i64", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_i64()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with i64".to_owned())
                                })?,
                        ))
                    })
                }),
                ("f64", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_number(v)?
                                .ok_or_else(|| Error::RuntimeError("Not a number".to_owned()))?
                                .to_f64()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with f64".to_owned())
                                })?,
                        ))
                    })
                }),
                ("u32", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_u32()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with u32".to_owned())
                                })?,
                        ))
                    })
                }),
                ("bevy_ecs::entity::Entity", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaEntity>()?;
                        LuaEntity::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("i32", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_i32()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with i32".to_owned())
                                })?,
                        ))
                    })
                }),
                ("glam::u32::UVec4", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaUVec4>()?;
                        LuaUVec4::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::f64::DMat4", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaDMat4>()?;
                        LuaDMat4::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("u128", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_u128()
                                .ok_or_else(|| {
                                    Error::RuntimeError(
                                        "Value not compatibile with u128".to_owned(),
                                    )
                                })?,
                        ))
                    })
                }),
                ("u8", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_u8()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with u8".to_owned())
                                })?,
                        ))
                    })
                }),
                ("glam::f32::Vec2", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaVec2>()?;
                        LuaVec2::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::f64::DVec2", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaDVec2>()?;
                        LuaDVec2::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("u64", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_u64()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with u64".to_owned())
                                })?,
                        ))
                    })
                }),
                ("glam::u32::UVec2", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaUVec2>()?;
                        LuaUVec2::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::f64::DMat3", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaDMat3>()?;
                        LuaDMat3::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("i128", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_i128()
                                .ok_or_else(|| {
                                    Error::RuntimeError(
                                        "Value not compatibile with i128".to_owned(),
                                    )
                                })?,
                        ))
                    })
                }),
                ("f32", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_number(v)?
                                .ok_or_else(|| Error::RuntimeError("Not a number".to_owned()))?
                                .to_f32()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with f32".to_owned())
                                })?,
                        ))
                    })
                }),
                ("glam::i32::IVec3", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaIVec3>()?;
                        LuaIVec3::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("usize", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_usize()
                                .ok_or_else(|| {
                                    Error::RuntimeError(
                                        "Value not compatibile with usize".to_owned(),
                                    )
                                })?,
                        ))
                    })
                }),
                ("glam::f32::Mat3", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaMat3>()?;
                        LuaMat3::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("alloc::string::String", |r, c, v: Value| {
                    c.coerce_string(v)?
                        .ok_or_else(|| Error::RuntimeError("Not a string".to_owned()))
                        .and_then(|string| {
                            r.get_mut(|s, _| Ok(s.apply(&string.to_str()?.to_owned())))
                        })
                }),
                ("glam::f32::Quat", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaQuat>()?;
                        LuaQuat::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::i32::IVec4", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaIVec4>()?;
                        LuaIVec4::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::f32::Vec4", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaVec4>()?;
                        LuaVec4::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::u32::UVec3", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaUVec3>()?;
                        LuaUVec3::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("glam::f64::DVec3", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaDVec3>()?;
                        LuaDVec3::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
                ("i8", |r, c, v: Value| {
                    r.get_mut(|s, _| {
                        Ok(s.apply(
                            &c.coerce_integer(v)?
                                .ok_or_else(|| Error::RuntimeError("Not an integer".to_owned()))?
                                .to_i8()
                                .ok_or_else(|| {
                                    Error::RuntimeError("Value not compatibile with i8".to_owned())
                                })?,
                        ))
                    })
                }),
                ("glam::f32::Mat4", |r, c, n| {
                    if let Value::UserData(v) = n {
                        let mut v = v.borrow_mut::<LuaMat4>()?;
                        LuaMat4::apply_self_to_base(v.deref_mut(), r);
                        Ok(())
                    } else {
                        Err(Error::RuntimeError("Invalid type".to_owned()))
                    }
                }),
            ],
        }
    };
    #[allow(non_camel_case_types)]
    pub enum UnionLuaVec2 {
        LuaVec2(LuaVec2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaVec2 {
        #[inline]
        fn clone(&self) -> UnionLuaVec2 {
            match (&*self,) {
                (&UnionLuaVec2::LuaVec2(ref __self_0),) => {
                    UnionLuaVec2::LuaVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec2 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaVec2::LuaVec2(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec2 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec2::LuaVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaVec2",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaVec2 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaVec2f32 {
        LuaVec2(LuaVec2),
        f32(f32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaVec2f32 {
        #[inline]
        fn clone(&self) -> UnionLuaVec2f32 {
            match (&*self,) {
                (&UnionLuaVec2f32::LuaVec2(ref __self_0),) => {
                    UnionLuaVec2f32::LuaVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaVec2f32::f32(ref __self_0),) => {
                    UnionLuaVec2f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec2f32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaVec2f32::LuaVec2(x) => x.to_lua(lua),
                UnionLuaVec2f32::f32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec2f32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec2f32::LuaVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec2f32::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaVec2 | f32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaVec2f32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf32LuaVec2 {
        f32(f32),
        LuaVec2(LuaVec2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf32LuaVec2 {
        #[inline]
        fn clone(&self) -> Unionf32LuaVec2 {
            match (&*self,) {
                (&Unionf32LuaVec2::f32(ref __self_0),) => {
                    Unionf32LuaVec2::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf32LuaVec2::LuaVec2(ref __self_0),) => {
                    Unionf32LuaVec2::LuaVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaVec2 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf32LuaVec2::f32(x) => x.to_lua(lua),
                Unionf32LuaVec2::LuaVec2(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaVec2 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaVec2::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaVec2::LuaVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f32 | LuaVec2",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf32LuaVec2 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaVec3 {
        LuaVec3(LuaVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaVec3 {
        #[inline]
        fn clone(&self) -> UnionLuaVec3 {
            match (&*self,) {
                (&UnionLuaVec3::LuaVec3(ref __self_0),) => {
                    UnionLuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaVec3::LuaVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec3::LuaVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaVec3f32 {
        LuaVec3(LuaVec3),
        f32(f32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaVec3f32 {
        #[inline]
        fn clone(&self) -> UnionLuaVec3f32 {
            match (&*self,) {
                (&UnionLuaVec3f32::LuaVec3(ref __self_0),) => {
                    UnionLuaVec3f32::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaVec3f32::f32(ref __self_0),) => {
                    UnionLuaVec3f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec3f32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaVec3f32::LuaVec3(x) => x.to_lua(lua),
                UnionLuaVec3f32::f32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec3f32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec3f32::LuaVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec3f32::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaVec3 | f32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaVec3f32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf32LuaVec3 {
        f32(f32),
        LuaVec3(LuaVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf32LuaVec3 {
        #[inline]
        fn clone(&self) -> Unionf32LuaVec3 {
            match (&*self,) {
                (&Unionf32LuaVec3::f32(ref __self_0),) => {
                    Unionf32LuaVec3::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf32LuaVec3::LuaVec3(ref __self_0),) => {
                    Unionf32LuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf32LuaVec3::f32(x) => x.to_lua(lua),
                Unionf32LuaVec3::LuaVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaVec3::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaVec3::LuaVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f32 | LuaVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf32LuaVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaVec4 {
        LuaVec4(LuaVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaVec4 {
        #[inline]
        fn clone(&self) -> UnionLuaVec4 {
            match (&*self,) {
                (&UnionLuaVec4::LuaVec4(ref __self_0),) => {
                    UnionLuaVec4::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaVec4::LuaVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec4::LuaVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaVec4f32 {
        LuaVec4(LuaVec4),
        f32(f32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaVec4f32 {
        #[inline]
        fn clone(&self) -> UnionLuaVec4f32 {
            match (&*self,) {
                (&UnionLuaVec4f32::LuaVec4(ref __self_0),) => {
                    UnionLuaVec4f32::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaVec4f32::f32(ref __self_0),) => {
                    UnionLuaVec4f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec4f32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaVec4f32::LuaVec4(x) => x.to_lua(lua),
                UnionLuaVec4f32::f32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec4f32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec4f32::LuaVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaVec4f32::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaVec4 | f32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaVec4f32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf32LuaVec4 {
        f32(f32),
        LuaVec4(LuaVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf32LuaVec4 {
        #[inline]
        fn clone(&self) -> Unionf32LuaVec4 {
            match (&*self,) {
                (&Unionf32LuaVec4::f32(ref __self_0),) => {
                    Unionf32LuaVec4::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf32LuaVec4::LuaVec4(ref __self_0),) => {
                    Unionf32LuaVec4::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf32LuaVec4::f32(x) => x.to_lua(lua),
                Unionf32LuaVec4::LuaVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaVec4::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaVec4::LuaVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f32 | LuaVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf32LuaVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDVec2 {
        LuaDVec2(LuaDVec2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDVec2 {
        #[inline]
        fn clone(&self) -> UnionLuaDVec2 {
            match (&*self,) {
                (&UnionLuaDVec2::LuaDVec2(ref __self_0),) => {
                    UnionLuaDVec2::LuaDVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec2 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDVec2::LuaDVec2(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec2 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec2::LuaDVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDVec2",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDVec2 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDVec2f64 {
        LuaDVec2(LuaDVec2),
        f64(f64),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDVec2f64 {
        #[inline]
        fn clone(&self) -> UnionLuaDVec2f64 {
            match (&*self,) {
                (&UnionLuaDVec2f64::LuaDVec2(ref __self_0),) => {
                    UnionLuaDVec2f64::LuaDVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDVec2f64::f64(ref __self_0),) => {
                    UnionLuaDVec2f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec2f64 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDVec2f64::LuaDVec2(x) => x.to_lua(lua),
                UnionLuaDVec2f64::f64(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec2f64 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec2f64::LuaDVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec2f64::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDVec2 | f64",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDVec2f64 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf64LuaDVec2 {
        f64(f64),
        LuaDVec2(LuaDVec2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf64LuaDVec2 {
        #[inline]
        fn clone(&self) -> Unionf64LuaDVec2 {
            match (&*self,) {
                (&Unionf64LuaDVec2::f64(ref __self_0),) => {
                    Unionf64LuaDVec2::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf64LuaDVec2::LuaDVec2(ref __self_0),) => {
                    Unionf64LuaDVec2::LuaDVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDVec2 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf64LuaDVec2::f64(x) => x.to_lua(lua),
                Unionf64LuaDVec2::LuaDVec2(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDVec2 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDVec2::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDVec2::LuaDVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f64 | LuaDVec2",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf64LuaDVec2 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDVec3 {
        LuaDVec3(LuaDVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDVec3 {
        #[inline]
        fn clone(&self) -> UnionLuaDVec3 {
            match (&*self,) {
                (&UnionLuaDVec3::LuaDVec3(ref __self_0),) => {
                    UnionLuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDVec3::LuaDVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec3::LuaDVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDVec3f64 {
        LuaDVec3(LuaDVec3),
        f64(f64),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDVec3f64 {
        #[inline]
        fn clone(&self) -> UnionLuaDVec3f64 {
            match (&*self,) {
                (&UnionLuaDVec3f64::LuaDVec3(ref __self_0),) => {
                    UnionLuaDVec3f64::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDVec3f64::f64(ref __self_0),) => {
                    UnionLuaDVec3f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec3f64 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDVec3f64::LuaDVec3(x) => x.to_lua(lua),
                UnionLuaDVec3f64::f64(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec3f64 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec3f64::LuaDVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec3f64::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDVec3 | f64",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDVec3f64 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf64LuaDVec3 {
        f64(f64),
        LuaDVec3(LuaDVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf64LuaDVec3 {
        #[inline]
        fn clone(&self) -> Unionf64LuaDVec3 {
            match (&*self,) {
                (&Unionf64LuaDVec3::f64(ref __self_0),) => {
                    Unionf64LuaDVec3::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf64LuaDVec3::LuaDVec3(ref __self_0),) => {
                    Unionf64LuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf64LuaDVec3::f64(x) => x.to_lua(lua),
                Unionf64LuaDVec3::LuaDVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDVec3::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDVec3::LuaDVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f64 | LuaDVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf64LuaDVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDVec4 {
        LuaDVec4(LuaDVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDVec4 {
        #[inline]
        fn clone(&self) -> UnionLuaDVec4 {
            match (&*self,) {
                (&UnionLuaDVec4::LuaDVec4(ref __self_0),) => {
                    UnionLuaDVec4::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDVec4::LuaDVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec4::LuaDVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDVec4f64 {
        LuaDVec4(LuaDVec4),
        f64(f64),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDVec4f64 {
        #[inline]
        fn clone(&self) -> UnionLuaDVec4f64 {
            match (&*self,) {
                (&UnionLuaDVec4f64::LuaDVec4(ref __self_0),) => {
                    UnionLuaDVec4f64::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDVec4f64::f64(ref __self_0),) => {
                    UnionLuaDVec4f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec4f64 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDVec4f64::LuaDVec4(x) => x.to_lua(lua),
                UnionLuaDVec4f64::f64(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec4f64 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec4f64::LuaDVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDVec4f64::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDVec4 | f64",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDVec4f64 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf64LuaDVec4 {
        f64(f64),
        LuaDVec4(LuaDVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf64LuaDVec4 {
        #[inline]
        fn clone(&self) -> Unionf64LuaDVec4 {
            match (&*self,) {
                (&Unionf64LuaDVec4::f64(ref __self_0),) => {
                    Unionf64LuaDVec4::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf64LuaDVec4::LuaDVec4(ref __self_0),) => {
                    Unionf64LuaDVec4::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf64LuaDVec4::f64(x) => x.to_lua(lua),
                Unionf64LuaDVec4::LuaDVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDVec4::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDVec4::LuaDVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f64 | LuaDVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf64LuaDVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaIVec2 {
        LuaIVec2(LuaIVec2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaIVec2 {
        #[inline]
        fn clone(&self) -> UnionLuaIVec2 {
            match (&*self,) {
                (&UnionLuaIVec2::LuaIVec2(ref __self_0),) => {
                    UnionLuaIVec2::LuaIVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec2 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaIVec2::LuaIVec2(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec2 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaIVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec2::LuaIVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaIVec2",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaIVec2 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaIVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaIVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaIVec2i32 {
        LuaIVec2(LuaIVec2),
        i32(i32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaIVec2i32 {
        #[inline]
        fn clone(&self) -> UnionLuaIVec2i32 {
            match (&*self,) {
                (&UnionLuaIVec2i32::LuaIVec2(ref __self_0),) => {
                    UnionLuaIVec2i32::LuaIVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaIVec2i32::i32(ref __self_0),) => {
                    UnionLuaIVec2i32::i32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec2i32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaIVec2i32::LuaIVec2(x) => x.to_lua(lua),
                UnionLuaIVec2i32::i32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec2i32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaIVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec2i32::LuaIVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match i32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec2i32::i32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaIVec2 | i32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaIVec2i32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaIVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut i32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaIVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((i32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unioni32LuaIVec2 {
        i32(i32),
        LuaIVec2(LuaIVec2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unioni32LuaIVec2 {
        #[inline]
        fn clone(&self) -> Unioni32LuaIVec2 {
            match (&*self,) {
                (&Unioni32LuaIVec2::i32(ref __self_0),) => {
                    Unioni32LuaIVec2::i32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unioni32LuaIVec2::LuaIVec2(ref __self_0),) => {
                    Unioni32LuaIVec2::LuaIVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unioni32LuaIVec2 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unioni32LuaIVec2::i32(x) => x.to_lua(lua),
                Unioni32LuaIVec2::LuaIVec2(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unioni32LuaIVec2 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match i32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unioni32LuaIVec2::i32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaIVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unioni32LuaIVec2::LuaIVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "i32 | LuaIVec2",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unioni32LuaIVec2 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut i32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaIVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((i32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaIVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaIVec3 {
        LuaIVec3(LuaIVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaIVec3 {
        #[inline]
        fn clone(&self) -> UnionLuaIVec3 {
            match (&*self,) {
                (&UnionLuaIVec3::LuaIVec3(ref __self_0),) => {
                    UnionLuaIVec3::LuaIVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaIVec3::LuaIVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaIVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec3::LuaIVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaIVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaIVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaIVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaIVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaIVec3i32 {
        LuaIVec3(LuaIVec3),
        i32(i32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaIVec3i32 {
        #[inline]
        fn clone(&self) -> UnionLuaIVec3i32 {
            match (&*self,) {
                (&UnionLuaIVec3i32::LuaIVec3(ref __self_0),) => {
                    UnionLuaIVec3i32::LuaIVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaIVec3i32::i32(ref __self_0),) => {
                    UnionLuaIVec3i32::i32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec3i32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaIVec3i32::LuaIVec3(x) => x.to_lua(lua),
                UnionLuaIVec3i32::i32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec3i32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaIVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec3i32::LuaIVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match i32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec3i32::i32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaIVec3 | i32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaIVec3i32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaIVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut i32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaIVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((i32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unioni32LuaIVec3 {
        i32(i32),
        LuaIVec3(LuaIVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unioni32LuaIVec3 {
        #[inline]
        fn clone(&self) -> Unioni32LuaIVec3 {
            match (&*self,) {
                (&Unioni32LuaIVec3::i32(ref __self_0),) => {
                    Unioni32LuaIVec3::i32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unioni32LuaIVec3::LuaIVec3(ref __self_0),) => {
                    Unioni32LuaIVec3::LuaIVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unioni32LuaIVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unioni32LuaIVec3::i32(x) => x.to_lua(lua),
                Unioni32LuaIVec3::LuaIVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unioni32LuaIVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match i32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unioni32LuaIVec3::i32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaIVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unioni32LuaIVec3::LuaIVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "i32 | LuaIVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unioni32LuaIVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut i32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaIVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((i32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaIVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaIVec4 {
        LuaIVec4(LuaIVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaIVec4 {
        #[inline]
        fn clone(&self) -> UnionLuaIVec4 {
            match (&*self,) {
                (&UnionLuaIVec4::LuaIVec4(ref __self_0),) => {
                    UnionLuaIVec4::LuaIVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaIVec4::LuaIVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaIVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec4::LuaIVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaIVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaIVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaIVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaIVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaIVec4i32 {
        LuaIVec4(LuaIVec4),
        i32(i32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaIVec4i32 {
        #[inline]
        fn clone(&self) -> UnionLuaIVec4i32 {
            match (&*self,) {
                (&UnionLuaIVec4i32::LuaIVec4(ref __self_0),) => {
                    UnionLuaIVec4i32::LuaIVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaIVec4i32::i32(ref __self_0),) => {
                    UnionLuaIVec4i32::i32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec4i32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaIVec4i32::LuaIVec4(x) => x.to_lua(lua),
                UnionLuaIVec4i32::i32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec4i32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaIVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec4i32::LuaIVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match i32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaIVec4i32::i32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaIVec4 | i32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaIVec4i32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaIVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut i32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaIVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((i32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unioni32LuaIVec4 {
        i32(i32),
        LuaIVec4(LuaIVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unioni32LuaIVec4 {
        #[inline]
        fn clone(&self) -> Unioni32LuaIVec4 {
            match (&*self,) {
                (&Unioni32LuaIVec4::i32(ref __self_0),) => {
                    Unioni32LuaIVec4::i32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unioni32LuaIVec4::LuaIVec4(ref __self_0),) => {
                    Unioni32LuaIVec4::LuaIVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unioni32LuaIVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unioni32LuaIVec4::i32(x) => x.to_lua(lua),
                Unioni32LuaIVec4::LuaIVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unioni32LuaIVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match i32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unioni32LuaIVec4::i32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaIVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unioni32LuaIVec4::LuaIVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "i32 | LuaIVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unioni32LuaIVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut i32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaIVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((i32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaIVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaUVec2 {
        LuaUVec2(LuaUVec2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaUVec2 {
        #[inline]
        fn clone(&self) -> UnionLuaUVec2 {
            match (&*self,) {
                (&UnionLuaUVec2::LuaUVec2(ref __self_0),) => {
                    UnionLuaUVec2::LuaUVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec2 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaUVec2::LuaUVec2(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec2 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaUVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec2::LuaUVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaUVec2",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaUVec2 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaUVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaUVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaUVec2u32 {
        LuaUVec2(LuaUVec2),
        u32(u32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaUVec2u32 {
        #[inline]
        fn clone(&self) -> UnionLuaUVec2u32 {
            match (&*self,) {
                (&UnionLuaUVec2u32::LuaUVec2(ref __self_0),) => {
                    UnionLuaUVec2u32::LuaUVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaUVec2u32::u32(ref __self_0),) => {
                    UnionLuaUVec2u32::u32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec2u32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaUVec2u32::LuaUVec2(x) => x.to_lua(lua),
                UnionLuaUVec2u32::u32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec2u32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaUVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec2u32::LuaUVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match u32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec2u32::u32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaUVec2 | u32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaUVec2u32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaUVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut u32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaUVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((u32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionu32LuaUVec2 {
        u32(u32),
        LuaUVec2(LuaUVec2),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionu32LuaUVec2 {
        #[inline]
        fn clone(&self) -> Unionu32LuaUVec2 {
            match (&*self,) {
                (&Unionu32LuaUVec2::u32(ref __self_0),) => {
                    Unionu32LuaUVec2::u32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionu32LuaUVec2::LuaUVec2(ref __self_0),) => {
                    Unionu32LuaUVec2::LuaUVec2(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionu32LuaUVec2 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionu32LuaUVec2::u32(x) => x.to_lua(lua),
                Unionu32LuaUVec2::LuaUVec2(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionu32LuaUVec2 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match u32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionu32LuaUVec2::u32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaUVec2::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionu32LuaUVec2::LuaUVec2(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "u32 | LuaUVec2",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionu32LuaUVec2 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut u32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaUVec2::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((u32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaUVec2::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaUVec3 {
        LuaUVec3(LuaUVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaUVec3 {
        #[inline]
        fn clone(&self) -> UnionLuaUVec3 {
            match (&*self,) {
                (&UnionLuaUVec3::LuaUVec3(ref __self_0),) => {
                    UnionLuaUVec3::LuaUVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaUVec3::LuaUVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaUVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec3::LuaUVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaUVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaUVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaUVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaUVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaUVec3u32 {
        LuaUVec3(LuaUVec3),
        u32(u32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaUVec3u32 {
        #[inline]
        fn clone(&self) -> UnionLuaUVec3u32 {
            match (&*self,) {
                (&UnionLuaUVec3u32::LuaUVec3(ref __self_0),) => {
                    UnionLuaUVec3u32::LuaUVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaUVec3u32::u32(ref __self_0),) => {
                    UnionLuaUVec3u32::u32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec3u32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaUVec3u32::LuaUVec3(x) => x.to_lua(lua),
                UnionLuaUVec3u32::u32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec3u32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaUVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec3u32::LuaUVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match u32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec3u32::u32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaUVec3 | u32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaUVec3u32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaUVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut u32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaUVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((u32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionu32LuaUVec3 {
        u32(u32),
        LuaUVec3(LuaUVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionu32LuaUVec3 {
        #[inline]
        fn clone(&self) -> Unionu32LuaUVec3 {
            match (&*self,) {
                (&Unionu32LuaUVec3::u32(ref __self_0),) => {
                    Unionu32LuaUVec3::u32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionu32LuaUVec3::LuaUVec3(ref __self_0),) => {
                    Unionu32LuaUVec3::LuaUVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionu32LuaUVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionu32LuaUVec3::u32(x) => x.to_lua(lua),
                Unionu32LuaUVec3::LuaUVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionu32LuaUVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match u32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionu32LuaUVec3::u32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaUVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionu32LuaUVec3::LuaUVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "u32 | LuaUVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionu32LuaUVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut u32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaUVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((u32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaUVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaUVec4 {
        LuaUVec4(LuaUVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaUVec4 {
        #[inline]
        fn clone(&self) -> UnionLuaUVec4 {
            match (&*self,) {
                (&UnionLuaUVec4::LuaUVec4(ref __self_0),) => {
                    UnionLuaUVec4::LuaUVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaUVec4::LuaUVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaUVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec4::LuaUVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaUVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaUVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaUVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaUVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaUVec4u32 {
        LuaUVec4(LuaUVec4),
        u32(u32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaUVec4u32 {
        #[inline]
        fn clone(&self) -> UnionLuaUVec4u32 {
            match (&*self,) {
                (&UnionLuaUVec4u32::LuaUVec4(ref __self_0),) => {
                    UnionLuaUVec4u32::LuaUVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaUVec4u32::u32(ref __self_0),) => {
                    UnionLuaUVec4u32::u32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec4u32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaUVec4u32::LuaUVec4(x) => x.to_lua(lua),
                UnionLuaUVec4u32::u32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec4u32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaUVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec4u32::LuaUVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match u32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaUVec4u32::u32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaUVec4 | u32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaUVec4u32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaUVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut u32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaUVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((u32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionu32LuaUVec4 {
        u32(u32),
        LuaUVec4(LuaUVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionu32LuaUVec4 {
        #[inline]
        fn clone(&self) -> Unionu32LuaUVec4 {
            match (&*self,) {
                (&Unionu32LuaUVec4::u32(ref __self_0),) => {
                    Unionu32LuaUVec4::u32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionu32LuaUVec4::LuaUVec4(ref __self_0),) => {
                    Unionu32LuaUVec4::LuaUVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionu32LuaUVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionu32LuaUVec4::u32(x) => x.to_lua(lua),
                Unionu32LuaUVec4::LuaUVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionu32LuaUVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match u32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionu32LuaUVec4::u32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaUVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionu32LuaUVec4::LuaUVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "u32 | LuaUVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionu32LuaUVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut u32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaUVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((u32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaUVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaMat3 {
        LuaMat3(LuaMat3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaMat3 {
        #[inline]
        fn clone(&self) -> UnionLuaMat3 {
            match (&*self,) {
                (&UnionLuaMat3::LuaMat3(ref __self_0),) => {
                    UnionLuaMat3::LuaMat3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaMat3::LuaMat3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaMat3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat3::LuaMat3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaMat3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaMat3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaMat3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaMat3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaMat3LuaVec3 {
        LuaMat3(LuaMat3),
        LuaVec3(LuaVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaMat3LuaVec3 {
        #[inline]
        fn clone(&self) -> UnionLuaMat3LuaVec3 {
            match (&*self,) {
                (&UnionLuaMat3LuaVec3::LuaMat3(ref __self_0),) => {
                    UnionLuaMat3LuaVec3::LuaMat3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaMat3LuaVec3::LuaVec3(ref __self_0),) => {
                    UnionLuaMat3LuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat3LuaVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaMat3LuaVec3::LuaMat3(x) => x.to_lua(lua),
                UnionLuaMat3LuaVec3::LuaVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat3LuaVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaMat3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat3LuaVec3::LuaMat3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat3LuaVec3::LuaVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaMat3 | LuaVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaMat3LuaVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaMat3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaMat3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaMat3LuaVec3f32 {
        LuaMat3(LuaMat3),
        LuaVec3(LuaVec3),
        f32(f32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaMat3LuaVec3f32 {
        #[inline]
        fn clone(&self) -> UnionLuaMat3LuaVec3f32 {
            match (&*self,) {
                (&UnionLuaMat3LuaVec3f32::LuaMat3(ref __self_0),) => {
                    UnionLuaMat3LuaVec3f32::LuaMat3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaMat3LuaVec3f32::LuaVec3(ref __self_0),) => {
                    UnionLuaMat3LuaVec3f32::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaMat3LuaVec3f32::f32(ref __self_0),) => {
                    UnionLuaMat3LuaVec3f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat3LuaVec3f32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaMat3LuaVec3f32::LuaMat3(x) => x.to_lua(lua),
                UnionLuaMat3LuaVec3f32::LuaVec3(x) => x.to_lua(lua),
                UnionLuaMat3LuaVec3f32::f32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat3LuaVec3f32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaMat3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat3LuaVec3f32::LuaMat3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat3LuaVec3f32::LuaVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat3LuaVec3f32::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaMat3 | LuaVec3 | f32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaMat3LuaVec3f32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaMat3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaMat3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf32LuaMat3 {
        f32(f32),
        LuaMat3(LuaMat3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf32LuaMat3 {
        #[inline]
        fn clone(&self) -> Unionf32LuaMat3 {
            match (&*self,) {
                (&Unionf32LuaMat3::f32(ref __self_0),) => {
                    Unionf32LuaMat3::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf32LuaMat3::LuaMat3(ref __self_0),) => {
                    Unionf32LuaMat3::LuaMat3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaMat3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf32LuaMat3::f32(x) => x.to_lua(lua),
                Unionf32LuaMat3::LuaMat3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaMat3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaMat3::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaMat3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaMat3::LuaMat3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f32 | LuaMat3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf32LuaMat3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaMat3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaMat3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaMat4 {
        LuaMat4(LuaMat4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaMat4 {
        #[inline]
        fn clone(&self) -> UnionLuaMat4 {
            match (&*self,) {
                (&UnionLuaMat4::LuaMat4(ref __self_0),) => {
                    UnionLuaMat4::LuaMat4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaMat4::LuaMat4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaMat4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat4::LuaMat4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaMat4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaMat4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaMat4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaMat4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaMat4LuaVec4 {
        LuaMat4(LuaMat4),
        LuaVec4(LuaVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaMat4LuaVec4 {
        #[inline]
        fn clone(&self) -> UnionLuaMat4LuaVec4 {
            match (&*self,) {
                (&UnionLuaMat4LuaVec4::LuaMat4(ref __self_0),) => {
                    UnionLuaMat4LuaVec4::LuaMat4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaMat4LuaVec4::LuaVec4(ref __self_0),) => {
                    UnionLuaMat4LuaVec4::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat4LuaVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaMat4LuaVec4::LuaMat4(x) => x.to_lua(lua),
                UnionLuaMat4LuaVec4::LuaVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat4LuaVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaMat4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat4LuaVec4::LuaMat4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat4LuaVec4::LuaVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaMat4 | LuaVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaMat4LuaVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaMat4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaMat4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaMat4LuaVec4f32 {
        LuaMat4(LuaMat4),
        LuaVec4(LuaVec4),
        f32(f32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaMat4LuaVec4f32 {
        #[inline]
        fn clone(&self) -> UnionLuaMat4LuaVec4f32 {
            match (&*self,) {
                (&UnionLuaMat4LuaVec4f32::LuaMat4(ref __self_0),) => {
                    UnionLuaMat4LuaVec4f32::LuaMat4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaMat4LuaVec4f32::LuaVec4(ref __self_0),) => {
                    UnionLuaMat4LuaVec4f32::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaMat4LuaVec4f32::f32(ref __self_0),) => {
                    UnionLuaMat4LuaVec4f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat4LuaVec4f32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaMat4LuaVec4f32::LuaMat4(x) => x.to_lua(lua),
                UnionLuaMat4LuaVec4f32::LuaVec4(x) => x.to_lua(lua),
                UnionLuaMat4LuaVec4f32::f32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat4LuaVec4f32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaMat4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat4LuaVec4f32::LuaMat4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat4LuaVec4f32::LuaVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaMat4LuaVec4f32::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaMat4 | LuaVec4 | f32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaMat4LuaVec4f32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaMat4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaMat4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf32LuaMat4 {
        f32(f32),
        LuaMat4(LuaMat4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf32LuaMat4 {
        #[inline]
        fn clone(&self) -> Unionf32LuaMat4 {
            match (&*self,) {
                (&Unionf32LuaMat4::f32(ref __self_0),) => {
                    Unionf32LuaMat4::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf32LuaMat4::LuaMat4(ref __self_0),) => {
                    Unionf32LuaMat4::LuaMat4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaMat4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf32LuaMat4::f32(x) => x.to_lua(lua),
                Unionf32LuaMat4::LuaMat4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaMat4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaMat4::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaMat4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaMat4::LuaMat4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f32 | LuaMat4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf32LuaMat4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaMat4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaMat4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDMat3 {
        LuaDMat3(LuaDMat3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDMat3 {
        #[inline]
        fn clone(&self) -> UnionLuaDMat3 {
            match (&*self,) {
                (&UnionLuaDMat3::LuaDMat3(ref __self_0),) => {
                    UnionLuaDMat3::LuaDMat3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDMat3::LuaDMat3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDMat3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat3::LuaDMat3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDMat3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDMat3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDMat3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDMat3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDMat3LuaDVec3 {
        LuaDMat3(LuaDMat3),
        LuaDVec3(LuaDVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDMat3LuaDVec3 {
        #[inline]
        fn clone(&self) -> UnionLuaDMat3LuaDVec3 {
            match (&*self,) {
                (&UnionLuaDMat3LuaDVec3::LuaDMat3(ref __self_0),) => {
                    UnionLuaDMat3LuaDVec3::LuaDMat3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDMat3LuaDVec3::LuaDVec3(ref __self_0),) => {
                    UnionLuaDMat3LuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat3LuaDVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDMat3LuaDVec3::LuaDMat3(x) => x.to_lua(lua),
                UnionLuaDMat3LuaDVec3::LuaDVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat3LuaDVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDMat3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat3LuaDVec3::LuaDMat3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat3LuaDVec3::LuaDVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDMat3 | LuaDVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDMat3LuaDVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDMat3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDMat3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDMat3LuaDVec3f64 {
        LuaDMat3(LuaDMat3),
        LuaDVec3(LuaDVec3),
        f64(f64),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDMat3LuaDVec3f64 {
        #[inline]
        fn clone(&self) -> UnionLuaDMat3LuaDVec3f64 {
            match (&*self,) {
                (&UnionLuaDMat3LuaDVec3f64::LuaDMat3(ref __self_0),) => {
                    UnionLuaDMat3LuaDVec3f64::LuaDMat3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDMat3LuaDVec3f64::LuaDVec3(ref __self_0),) => {
                    UnionLuaDMat3LuaDVec3f64::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDMat3LuaDVec3f64::f64(ref __self_0),) => {
                    UnionLuaDMat3LuaDVec3f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat3LuaDVec3f64 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDMat3LuaDVec3f64::LuaDMat3(x) => x.to_lua(lua),
                UnionLuaDMat3LuaDVec3f64::LuaDVec3(x) => x.to_lua(lua),
                UnionLuaDMat3LuaDVec3f64::f64(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat3LuaDVec3f64 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDMat3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat3LuaDVec3f64::LuaDMat3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat3LuaDVec3f64::LuaDVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat3LuaDVec3f64::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDMat3 | LuaDVec3 | f64",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDMat3LuaDVec3f64 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDMat3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDMat3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf64LuaDMat3 {
        f64(f64),
        LuaDMat3(LuaDMat3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf64LuaDMat3 {
        #[inline]
        fn clone(&self) -> Unionf64LuaDMat3 {
            match (&*self,) {
                (&Unionf64LuaDMat3::f64(ref __self_0),) => {
                    Unionf64LuaDMat3::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf64LuaDMat3::LuaDMat3(ref __self_0),) => {
                    Unionf64LuaDMat3::LuaDMat3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDMat3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf64LuaDMat3::f64(x) => x.to_lua(lua),
                Unionf64LuaDMat3::LuaDMat3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDMat3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDMat3::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDMat3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDMat3::LuaDMat3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f64 | LuaDMat3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf64LuaDMat3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDMat3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDMat3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDMat4 {
        LuaDMat4(LuaDMat4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDMat4 {
        #[inline]
        fn clone(&self) -> UnionLuaDMat4 {
            match (&*self,) {
                (&UnionLuaDMat4::LuaDMat4(ref __self_0),) => {
                    UnionLuaDMat4::LuaDMat4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDMat4::LuaDMat4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDMat4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat4::LuaDMat4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDMat4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDMat4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDMat4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDMat4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDMat4LuaDVec4 {
        LuaDMat4(LuaDMat4),
        LuaDVec4(LuaDVec4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDMat4LuaDVec4 {
        #[inline]
        fn clone(&self) -> UnionLuaDMat4LuaDVec4 {
            match (&*self,) {
                (&UnionLuaDMat4LuaDVec4::LuaDMat4(ref __self_0),) => {
                    UnionLuaDMat4LuaDVec4::LuaDMat4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDMat4LuaDVec4::LuaDVec4(ref __self_0),) => {
                    UnionLuaDMat4LuaDVec4::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat4LuaDVec4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDMat4LuaDVec4::LuaDMat4(x) => x.to_lua(lua),
                UnionLuaDMat4LuaDVec4::LuaDVec4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat4LuaDVec4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDMat4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat4LuaDVec4::LuaDMat4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat4LuaDVec4::LuaDVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDMat4 | LuaDVec4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDMat4LuaDVec4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDMat4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDMat4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDMat4LuaDVec4f64 {
        LuaDMat4(LuaDMat4),
        LuaDVec4(LuaDVec4),
        f64(f64),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDMat4LuaDVec4f64 {
        #[inline]
        fn clone(&self) -> UnionLuaDMat4LuaDVec4f64 {
            match (&*self,) {
                (&UnionLuaDMat4LuaDVec4f64::LuaDMat4(ref __self_0),) => {
                    UnionLuaDMat4LuaDVec4f64::LuaDMat4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDMat4LuaDVec4f64::LuaDVec4(ref __self_0),) => {
                    UnionLuaDMat4LuaDVec4f64::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDMat4LuaDVec4f64::f64(ref __self_0),) => {
                    UnionLuaDMat4LuaDVec4f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat4LuaDVec4f64 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDMat4LuaDVec4f64::LuaDMat4(x) => x.to_lua(lua),
                UnionLuaDMat4LuaDVec4f64::LuaDVec4(x) => x.to_lua(lua),
                UnionLuaDMat4LuaDVec4f64::f64(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat4LuaDVec4f64 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDMat4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat4LuaDVec4f64::LuaDMat4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat4LuaDVec4f64::LuaDVec4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDMat4LuaDVec4f64::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDMat4 | LuaDVec4 | f64",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDMat4LuaDVec4f64 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDMat4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDMat4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf64LuaDMat4 {
        f64(f64),
        LuaDMat4(LuaDMat4),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf64LuaDMat4 {
        #[inline]
        fn clone(&self) -> Unionf64LuaDMat4 {
            match (&*self,) {
                (&Unionf64LuaDMat4::f64(ref __self_0),) => {
                    Unionf64LuaDMat4::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf64LuaDMat4::LuaDMat4(ref __self_0),) => {
                    Unionf64LuaDMat4::LuaDMat4(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDMat4 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf64LuaDMat4::f64(x) => x.to_lua(lua),
                Unionf64LuaDMat4::LuaDMat4(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDMat4 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDMat4::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDMat4::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDMat4::LuaDMat4(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f64 | LuaDMat4",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf64LuaDMat4 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDMat4::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDMat4::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaQuat {
        LuaQuat(LuaQuat),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaQuat {
        #[inline]
        fn clone(&self) -> UnionLuaQuat {
            match (&*self,) {
                (&UnionLuaQuat::LuaQuat(ref __self_0),) => {
                    UnionLuaQuat::LuaQuat(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaQuat {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaQuat::LuaQuat(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaQuat {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaQuat::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaQuat::LuaQuat(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaQuat",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaQuat {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaQuat::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaQuat::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf32 {
        f32(f32),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf32 {
        #[inline]
        fn clone(&self) -> Unionf32 {
            match (&*self,) {
                (&Unionf32::f32(ref __self_0),) => {
                    Unionf32::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf32::f32(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f32",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf32 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaQuatLuaVec3 {
        LuaQuat(LuaQuat),
        LuaVec3(LuaVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaQuatLuaVec3 {
        #[inline]
        fn clone(&self) -> UnionLuaQuatLuaVec3 {
            match (&*self,) {
                (&UnionLuaQuatLuaVec3::LuaQuat(ref __self_0),) => {
                    UnionLuaQuatLuaVec3::LuaQuat(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaQuatLuaVec3::LuaVec3(ref __self_0),) => {
                    UnionLuaQuatLuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaQuatLuaVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaQuatLuaVec3::LuaQuat(x) => x.to_lua(lua),
                UnionLuaQuatLuaVec3::LuaVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaQuatLuaVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaQuat::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaQuatLuaVec3::LuaQuat(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaQuatLuaVec3::LuaVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaQuat | LuaVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaQuatLuaVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaQuat::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaQuat::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf32LuaQuatLuaVec3 {
        f32(f32),
        LuaQuat(LuaQuat),
        LuaVec3(LuaVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf32LuaQuatLuaVec3 {
        #[inline]
        fn clone(&self) -> Unionf32LuaQuatLuaVec3 {
            match (&*self,) {
                (&Unionf32LuaQuatLuaVec3::f32(ref __self_0),) => {
                    Unionf32LuaQuatLuaVec3::f32(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf32LuaQuatLuaVec3::LuaQuat(ref __self_0),) => {
                    Unionf32LuaQuatLuaVec3::LuaQuat(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf32LuaQuatLuaVec3::LuaVec3(ref __self_0),) => {
                    Unionf32LuaQuatLuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaQuatLuaVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf32LuaQuatLuaVec3::f32(x) => x.to_lua(lua),
                Unionf32LuaQuatLuaVec3::LuaQuat(x) => x.to_lua(lua),
                Unionf32LuaQuatLuaVec3::LuaVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaQuatLuaVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f32::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaQuatLuaVec3::f32(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaQuat::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaQuatLuaVec3::LuaQuat(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf32LuaQuatLuaVec3::LuaVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f32 | LuaQuat | LuaVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf32LuaQuatLuaVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f32::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaQuat::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f32::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaQuat::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDQuat {
        LuaDQuat(LuaDQuat),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDQuat {
        #[inline]
        fn clone(&self) -> UnionLuaDQuat {
            match (&*self,) {
                (&UnionLuaDQuat::LuaDQuat(ref __self_0),) => {
                    UnionLuaDQuat::LuaDQuat(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDQuat {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDQuat::LuaDQuat(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDQuat {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDQuat::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDQuat::LuaDQuat(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDQuat",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDQuat {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDQuat::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDQuat::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf64 {
        f64(f64),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf64 {
        #[inline]
        fn clone(&self) -> Unionf64 {
            match (&*self,) {
                (&Unionf64::f64(ref __self_0),) => {
                    Unionf64::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf64::f64(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f64",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf64 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum UnionLuaDQuatLuaDVec3 {
        LuaDQuat(LuaDQuat),
        LuaDVec3(LuaDVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for UnionLuaDQuatLuaDVec3 {
        #[inline]
        fn clone(&self) -> UnionLuaDQuatLuaDVec3 {
            match (&*self,) {
                (&UnionLuaDQuatLuaDVec3::LuaDQuat(ref __self_0),) => {
                    UnionLuaDQuatLuaDVec3::LuaDQuat(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnionLuaDQuatLuaDVec3::LuaDVec3(ref __self_0),) => {
                    UnionLuaDQuatLuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDQuatLuaDVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                UnionLuaDQuatLuaDVec3::LuaDQuat(x) => x.to_lua(lua),
                UnionLuaDQuatLuaDVec3::LuaDVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDQuatLuaDVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match LuaDQuat::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDQuatLuaDVec3::LuaDQuat(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(UnionLuaDQuatLuaDVec3::LuaDVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "LuaDQuat | LuaDVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for UnionLuaDQuatLuaDVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut LuaDQuat::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((LuaDQuat::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
    #[allow(non_camel_case_types)]
    pub enum Unionf64LuaDQuatLuaDVec3 {
        f64(f64),
        LuaDQuat(LuaDQuat),
        LuaDVec3(LuaDVec3),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for Unionf64LuaDQuatLuaDVec3 {
        #[inline]
        fn clone(&self) -> Unionf64LuaDQuatLuaDVec3 {
            match (&*self,) {
                (&Unionf64LuaDQuatLuaDVec3::f64(ref __self_0),) => {
                    Unionf64LuaDQuatLuaDVec3::f64(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf64LuaDQuatLuaDVec3::LuaDQuat(ref __self_0),) => {
                    Unionf64LuaDQuatLuaDVec3::LuaDQuat(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Unionf64LuaDQuatLuaDVec3::LuaDVec3(ref __self_0),) => {
                    Unionf64LuaDQuatLuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDQuatLuaDVec3 {
        fn to_lua(
            self,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
        {
            match self {
                Unionf64LuaDQuatLuaDVec3::f64(x) => x.to_lua(lua),
                Unionf64LuaDQuatLuaDVec3::LuaDQuat(x) => x.to_lua(lua),
                Unionf64LuaDQuatLuaDVec3::LuaDVec3(x) => x.to_lua(lua),
            }
        }
    }
    impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDQuatLuaDVec3 {
        fn from_lua(
            value: ::tealr::mlu::mlua::Value<'lua>,
            lua: &'lua ::tealr::mlu::mlua::Lua,
        ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
            match f64::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDQuatLuaDVec3::f64(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDQuat::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDQuatLuaDVec3::LuaDQuat(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            match LuaDVec3::from_lua(value.clone(), lua) {
                Ok(x) => return Ok(Unionf64LuaDQuatLuaDVec3::LuaDVec3(x)),
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    from: _,
                    to: _,
                    message: _,
                }) => {}
                Err(x) => return Err(x),
            };
            Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                to: "f64 | LuaDQuat | LuaDVec3",
                from: value.type_name(),
                message: None,
            })
        }
    }
    impl ::tealr::TypeName for Unionf64LuaDQuatLuaDVec3 {
        fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
            let mut name = Vec::new();
            name.append(&mut f64::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDQuat::get_type_parts().to_vec());
            name.push(" | ".into());
            name.append(&mut LuaDVec3::get_type_parts().to_vec());
            name.push(" | ".into());
            name.pop();
            std::borrow::Cow::Owned(name)
        }
        fn collect_children(v: &mut Vec<::tealr::TealType>) {
            use ::tealr::TealMultiValue;
            v.extend((f64::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDQuat::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
            v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                if let ::tealr::NamePart::Type(x) = v {
                    Some(x)
                } else {
                    None
                }
            }));
        }
        fn get_type_kind() -> ::tealr::KindOfType {
            ::tealr::KindOfType::Builtin
        }
    }
}
