mod generated {
    use bevy_mod_scripting_derive::impl_lua_newtypes;
    pub mod lua {
        use bevy::{prelude::*, asset::HandleId};
        use bevy::math::*;
        use std::sync::Weak;
        use std::ops::*;
        use phf::{phf_map, Map};
        use crate::LuaFile;
        use crate::LuaRefBase;
        use crate::ReflectPtr;
        use crate::Script;
        use crate::ScriptCollection;
        use crate::LuaRef;
        use crate::get_type_data;
        use crate::{LuaComponent, LuaResource, LuaWorld};
        use std::sync::Arc;
        use parking_lot::RwLock;
        use crate::util::impl_tealr_type;
        use num_traits::cast::ToPrimitive;
        use bevy_mod_scripting_derive::{impl_lua_newtypes, replace};
        use tealr::{
            mlu::{
                mlua,
                mlua::{prelude::*, Error, MetaMethod, Value},
            },
            create_union_mlua,
        };
        pub type LuaEntity = crate::LuaWrapper<Entity>;
        impl tealr::mlu::TealData for LuaEntity {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Lightweight identifier of an [entity](crate::entity).");
                methods.document_type("");
                methods . document_type ("The identifier is implemented using a [generational index]: a combination of an ID and a generation.") ;
                methods . document_type ("This allows fast insertion after data removal in an array while minimizing loss of spatial locality.") ;
                methods.document_type("");
                methods . document_type ("[generational index]: https://lucassardois.medium.com/generational-indices-guide-8e3c5f7fd594") ;
                methods.document_type("");
                methods.document_type("# Usage");
                methods.document_type("");
                methods . document_type ("This data type is returned by iterating a `Query` that has `Entity` as part of its query fetch type parameter ([learn more]).") ;
                methods . document_type ("It can also be obtained by calling [`EntityCommands::id`] or [`EntityMut::id`].") ;
                methods.document_type("");
                methods.document_type("```");
                methods.document_type("# use bevy_ecs::prelude::*;");
                methods.document_type("#");
                methods.document_type("fn setup(mut commands: Commands) {");
                methods.document_type("    // Calling `spawn` returns `EntityCommands`.");
                methods.document_type("    let entity = commands.spawn().id();");
                methods.document_type("}");
                methods.document_type("");
                methods.document_type("fn exclusive_system(world: &mut World) {");
                methods.document_type("    // Calling `spawn` returns `EntityMut`.");
                methods.document_type("    let entity = world.spawn().id();");
                methods.document_type("}");
                methods.document_type("#");
                methods.document_type("# bevy_ecs::system::assert_is_system(setup);");
                methods.document_type(
                    "# bevy_ecs::system::IntoExclusiveSystem::exclusive_system(exclusive_system);",
                );
                methods.document_type("```");
                methods.document_type("");
                methods . document_type ("It can be used to refer to a specific entity to apply [`EntityCommands`], or to call [`Query::get`] (or similar methods) to access its components.") ;
                methods.document_type("");
                methods.document_type("```");
                methods.document_type("# use bevy_ecs::prelude::*;");
                methods.document_type("#");
                methods.document_type("# #[derive(Component)]");
                methods.document_type("# struct Expired;");
                methods.document_type("#");
                methods . document_type ("fn dispose_expired_food(mut commands: Commands, query: Query<Entity, With<Expired>>) {") ;
                methods.document_type("    for food_entity in query.iter() {");
                methods.document_type("        commands.entity(food_entity).despawn();");
                methods.document_type("    }");
                methods.document_type("}");
                methods.document_type("#");
                methods
                    .document_type("# bevy_ecs::system::assert_is_system(dispose_expired_food);");
                methods.document_type("```");
                methods.document_type("");
                methods.document_type("[learn more]: crate::system::Query#entity-id-access");
                methods.document_type("[`EntityCommands::id`]: crate::system::EntityCommands::id");
                methods.document_type("[`EntityMut::id`]: crate::world::EntityMut::id");
                methods.document_type("[`EntityCommands`]: crate::system::EntityCommands");
                methods.document_type("[`Query::get`]: crate::system::Query::get");
                methods.document("Convert to a form convenient for passing outside of rust.");
                methods.document("");
                methods . document ("Only useful for identifying entities within the same instance of an application. Do not use") ;
                methods.document("for serialization between runs.");
                methods.document("");
                methods.document("No particular structure is guaranteed for the returned bits.");
                methods.add_method("to_bits", |_, s, (): ()| Ok(s.clone().to_bits()));
                methods.document("Return a transiently unique identifier.");
                methods.document("");
                methods . document ("No two simultaneously-live entities share the same ID, but dead entities\' IDs may collide") ;
                methods . document ("with both live and dead entities. Useful for compactly representing entities within a") ;
                methods.document("specific snapshot of the world, such as when serializing.");
                methods.add_method("id", |_, s, (): ()| Ok(s.clone().id()));
                methods . document ("Returns the generation of this Entity\'s id. The generation is incremented each time an") ;
                methods . document ("entity with a given id is despawned. This serves as a \"count\" of the number of times a") ;
                methods . document ("given id has been reused (id, generation) pairs uniquely identify a given Entity.") ;
                methods.add_method("generation", |_, s, (): ()| Ok(s.clone().generation()));
            }
        }
        impl tealr::TypeName for LuaEntity {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaEntity"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaEntity {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaEntity {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaVec2 = crate::LuaWrapper<Vec2>;
        impl tealr::mlu::TealData for LuaVec2 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 2-dimensional vector.");
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaVec2::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| match (lhs, rhs) {
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                (ud.clone()).add(v.clone()),
                            ))),
                            UnionLuaVec2f32::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| match (lhs, rhs) {
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                (ud.clone()).sub(v.clone()),
                            ))),
                            UnionLuaVec2f32::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| match (lhs, rhs) {
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                (ud.clone()).div(v.clone()),
                            ))),
                            UnionLuaVec2f32::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| match (lhs, rhs) {
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                (ud.clone()).mul(v.clone()),
                            ))),
                            UnionLuaVec2f32::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionf32LuaVec2, UnionLuaVec2f32)| match (lhs, rhs) {
                        (Unionf32LuaVec2::LuaVec2(ud), v) => match v {
                            UnionLuaVec2f32::LuaVec2(v) => Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(
                                (ud.clone()).rem(v.clone()),
                            ))),
                            UnionLuaVec2f32::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec2f32::LuaVec2(ud)) => match v {
                            Unionf32LuaVec2::f32(v) => {
                                Ok(UnionLuaVec2::LuaVec2(LuaVec2::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Creates a 3D vector from `self` and the given `z` value.");
                methods.add_method("extend", |_, s, (a_0): (f32)| {
                    Ok(LuaVec3::new(s.clone().extend(a_0)))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaVec2)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaVec2, LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaVec2::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaVec2::new(s.clone().signum()))
                });
                methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
                methods.document("`NaN`, positive or negative infinity, this will return `false`.");
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.clone().is_finite()));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.clone().is_nan()));
                methods.document("Computes the length of `self`.");
                methods.add_method("length", |_, s, (): ()| Ok(s.clone().length()));
                methods.document("Computes the squared length of `self`.");
                methods.document("");
                methods.document(
                    "This is faster than `length()` as it avoids a square root operation.",
                );
                methods.add_method("length_squared", |_, s, (): ()| {
                    Ok(s.clone().length_squared())
                });
                methods.document("Computes `1.0 / length()`.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.add_method("length_recip", |_, s, (): ()| Ok(s.clone().length_recip()));
                methods.document("Computes the Euclidean distance between two points in space.");
                methods.add_method("distance", |_, s, (a_0): (LuaVec2)| {
                    Ok(s.clone().distance(a_0.clone()))
                });
                methods.document(
                    "Compute the squared euclidean distance between two points in space.",
                );
                methods.add_method("distance_squared", |_, s, (a_0): (LuaVec2)| {
                    Ok(s.clone().distance_squared(a_0.clone()))
                });
                methods.document("Returns `self` normalized to length 1.0.");
                methods.document("");
                methods . document ("For valid results, `self` must _not_ be of length zero, nor very close to zero.") ;
                methods.document("");
                methods
                    .document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
                methods.document("");
                methods.document("Panics");
                methods.document("");
                methods
                    .document("Will panic if `self` is zero length when `glam_assert` is enabled.");
                methods.add_method("normalize", |_, s, (): ()| {
                    Ok(LuaVec2::new(s.clone().normalize()))
                });
                methods.document(
                    "Returns `self` normalized to length 1.0 if possible, else returns zero.",
                );
                methods.document("");
                methods.document(
                    "In particular, if the input is zero (or very close to zero), or non-finite,",
                );
                methods.document("the result of this operation will be zero.");
                methods.document("");
                methods.document("See also [`Self::try_normalize`].");
                methods.add_method("normalize_or_zero", |_, s, (): ()| {
                    Ok(LuaVec2::new(s.clone().normalize_or_zero()))
                });
                methods.document("Returns whether `self` is length `1.0` or not.");
                methods.document("");
                methods.document("Uses a precision threshold of `1e-6`.");
                methods.add_method("is_normalized", |_, s, (): ()| {
                    Ok(s.clone().is_normalized())
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods
                    .document("Will panic if `rhs` is zero length when `glam_assert` is enabled.");
                methods.add_method("project_onto", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().project_onto(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().reject_from(a_0.clone())))
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("project_onto_normalized", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().project_onto_normalized(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from_normalized", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().reject_from_normalized(a_0.clone())))
                });
                methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
                methods.document("Round half-way cases away from 0.0.");
                methods.add_method("round", |_, s, (): ()| Ok(LuaVec2::new(s.clone().round())));
                methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
                methods.document("element of `self`.");
                methods.add_method("floor", |_, s, (): ()| Ok(LuaVec2::new(s.clone().floor())));
                methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
                methods.document("each element of `self`.");
                methods.add_method("ceil", |_, s, (): ()| Ok(LuaVec2::new(s.clone().ceil())));
                methods.document(
                    "Returns a vector containing the fractional part of the vector, e.g. `self -",
                );
                methods.document("self.floor()`.");
                methods.document("");
                methods.document("Note that this is fast but not precise for large numbers.");
                methods.add_method("fract", |_, s, (): ()| Ok(LuaVec2::new(s.clone().fract())));
                methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
                methods.document("`self`.");
                methods.add_method("exp", |_, s, (): ()| Ok(LuaVec2::new(s.clone().exp())));
                methods . document ("Returns a vector containing each element of `self` raised to the power of `n`.") ;
                methods.add_method("powf", |_, s, (a_0): (f32)| {
                    Ok(LuaVec2::new(s.clone().powf(a_0)))
                });
                methods.document(
                    "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                );
                methods.add_method("recip", |_, s, (): ()| Ok(LuaVec2::new(s.clone().recip())));
                methods . document ("Performs a linear interpolation between `self` and `rhs` based on the value `s`.") ;
                methods.document("");
                methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
                methods . document ("will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly") ;
                methods.document("extrapolated.");
                methods.add_method("lerp", |_, s, (a_0, a_1): (LuaVec2, f32)| {
                    Ok(LuaVec2::new(s.clone().lerp(a_0.clone(), a_1)))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs` is") ;
                methods.document("less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
                methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
                methods.document("the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaVec2, f32)| {
                    Ok(s.clone().abs_diff_eq(a_0.clone(), a_1))
                });
                methods.document(
                    "Returns a vector with a length no less than `min` and no more than `max`",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp_length", |_, s, (a_0, a_1): (f32, f32)| {
                    Ok(LuaVec2::new(s.clone().clamp_length(a_0, a_1)))
                });
                methods.document("Returns a vector with a length no more than `max`");
                methods.add_method("clamp_length_max", |_, s, (a_0): (f32)| {
                    Ok(LuaVec2::new(s.clone().clamp_length_max(a_0)))
                });
                methods.document("Returns a vector with a length no less than `min`");
                methods.add_method("clamp_length_min", |_, s, (a_0): (f32)| {
                    Ok(LuaVec2::new(s.clone().clamp_length_min(a_0)))
                });
                methods . document ("Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding") ;
                methods.document(
                    "error, yielding a more accurate result than an unfused multiply-add.",
                );
                methods.document("");
                methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
                methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
                methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
                methods.document("mind.");
                methods.add_method("mul_add", |_, s, (a_0, a_1): (LuaVec2, LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().mul_add(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the angle (in radians) between `self` and `rhs`.");
                methods.document("");
                methods . document ("The input vectors do not need to be unit length however they must be non-zero.") ;
                methods.add_method("angle_between", |_, s, (a_0): (LuaVec2)| {
                    Ok(s.clone().angle_between(a_0.clone()))
                });
                methods.document("Returns a vector that is equal to `self` rotated by 90 degrees.");
                methods.add_method("perp", |_, s, (): ()| Ok(LuaVec2::new(s.clone().perp())));
                methods.document("The perpendicular dot product of `self` and `rhs`.");
                methods.document(
                    "Also known as the wedge product, 2D cross product, and determinant.",
                );
                methods.add_method("perp_dot", |_, s, (a_0): (LuaVec2)| {
                    Ok(s.clone().perp_dot(a_0.clone()))
                });
                methods.document(
                    "Returns `rhs` rotated by the angle of `self`. If `self` is normalized,",
                );
                methods
                    .document("then this just rotation. This is what you usually want. Otherwise,");
                methods.document(
                    "it will be like a rotation with a multiplication by `self`\'s length.",
                );
                methods.add_method("rotate", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.clone().rotate(a_0.clone())))
                });
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
            }
        }
        impl tealr::TypeName for LuaVec2 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaVec2"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaVec2 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaVec2 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaVec3 = crate::LuaWrapper<Vec3>;
        impl tealr::mlu::TealData for LuaVec3 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 3-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaVec3::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| match (lhs, rhs) {
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                (ud.clone()).add(v.clone()),
                            ))),
                            UnionLuaVec3f32::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| match (lhs, rhs) {
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                (ud.clone()).sub(v.clone()),
                            ))),
                            UnionLuaVec3f32::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| match (lhs, rhs) {
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                (ud.clone()).div(v.clone()),
                            ))),
                            UnionLuaVec3f32::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| match (lhs, rhs) {
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                (ud.clone()).mul(v.clone()),
                            ))),
                            UnionLuaVec3f32::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionf32LuaVec3, UnionLuaVec3f32)| match (lhs, rhs) {
                        (Unionf32LuaVec3::LuaVec3(ud), v) => match v {
                            UnionLuaVec3f32::LuaVec3(v) => Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(
                                (ud.clone()).rem(v.clone()),
                            ))),
                            UnionLuaVec3f32::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec3f32::LuaVec3(ud)) => match v {
                            Unionf32LuaVec3::f32(v) => {
                                Ok(UnionLuaVec3::LuaVec3(LuaVec3::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Creates a 4D vector from `self` and the given `w` value.");
                methods.add_method("extend", |_, s, (a_0): (f32)| {
                    Ok(LuaVec4::new(s.clone().extend(a_0)))
                });
                methods.document(
                    "Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.",
                );
                methods.document("");
                methods.document(
                    "Truncation may also be performed by using `self.xy()` or `Vec2::from()`.",
                );
                methods.add_method("truncate", |_, s, (): ()| {
                    Ok(LuaVec2::new(s.clone().truncate()))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaVec3)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods.document("Computes the cross product of `self` and `rhs`.");
                methods.add_method("cross", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().cross(a_0.clone())))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaVec3, LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaVec3::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaVec3::new(s.clone().signum()))
                });
                methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
                methods.document("`NaN`, positive or negative infinity, this will return `false`.");
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.clone().is_finite()));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.clone().is_nan()));
                methods.document("Computes the length of `self`.");
                methods.add_method("length", |_, s, (): ()| Ok(s.clone().length()));
                methods.document("Computes the squared length of `self`.");
                methods.document("");
                methods.document(
                    "This is faster than `length()` as it avoids a square root operation.",
                );
                methods.add_method("length_squared", |_, s, (): ()| {
                    Ok(s.clone().length_squared())
                });
                methods.document("Computes `1.0 / length()`.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.add_method("length_recip", |_, s, (): ()| Ok(s.clone().length_recip()));
                methods.document("Computes the Euclidean distance between two points in space.");
                methods.add_method("distance", |_, s, (a_0): (LuaVec3)| {
                    Ok(s.clone().distance(a_0.clone()))
                });
                methods.document(
                    "Compute the squared euclidean distance between two points in space.",
                );
                methods.add_method("distance_squared", |_, s, (a_0): (LuaVec3)| {
                    Ok(s.clone().distance_squared(a_0.clone()))
                });
                methods.document("Returns `self` normalized to length 1.0.");
                methods.document("");
                methods . document ("For valid results, `self` must _not_ be of length zero, nor very close to zero.") ;
                methods.document("");
                methods
                    .document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
                methods.document("");
                methods.document("Panics");
                methods.document("");
                methods
                    .document("Will panic if `self` is zero length when `glam_assert` is enabled.");
                methods.add_method("normalize", |_, s, (): ()| {
                    Ok(LuaVec3::new(s.clone().normalize()))
                });
                methods.document(
                    "Returns `self` normalized to length 1.0 if possible, else returns zero.",
                );
                methods.document("");
                methods.document(
                    "In particular, if the input is zero (or very close to zero), or non-finite,",
                );
                methods.document("the result of this operation will be zero.");
                methods.document("");
                methods.document("See also [`Self::try_normalize`].");
                methods.add_method("normalize_or_zero", |_, s, (): ()| {
                    Ok(LuaVec3::new(s.clone().normalize_or_zero()))
                });
                methods.document("Returns whether `self` is length `1.0` or not.");
                methods.document("");
                methods.document("Uses a precision threshold of `1e-6`.");
                methods.add_method("is_normalized", |_, s, (): ()| {
                    Ok(s.clone().is_normalized())
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods
                    .document("Will panic if `rhs` is zero length when `glam_assert` is enabled.");
                methods.add_method("project_onto", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().project_onto(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().reject_from(a_0.clone())))
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("project_onto_normalized", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().project_onto_normalized(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from_normalized", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().reject_from_normalized(a_0.clone())))
                });
                methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
                methods.document("Round half-way cases away from 0.0.");
                methods.add_method("round", |_, s, (): ()| Ok(LuaVec3::new(s.clone().round())));
                methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
                methods.document("element of `self`.");
                methods.add_method("floor", |_, s, (): ()| Ok(LuaVec3::new(s.clone().floor())));
                methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
                methods.document("each element of `self`.");
                methods.add_method("ceil", |_, s, (): ()| Ok(LuaVec3::new(s.clone().ceil())));
                methods.document(
                    "Returns a vector containing the fractional part of the vector, e.g. `self -",
                );
                methods.document("self.floor()`.");
                methods.document("");
                methods.document("Note that this is fast but not precise for large numbers.");
                methods.add_method("fract", |_, s, (): ()| Ok(LuaVec3::new(s.clone().fract())));
                methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
                methods.document("`self`.");
                methods.add_method("exp", |_, s, (): ()| Ok(LuaVec3::new(s.clone().exp())));
                methods . document ("Returns a vector containing each element of `self` raised to the power of `n`.") ;
                methods.add_method("powf", |_, s, (a_0): (f32)| {
                    Ok(LuaVec3::new(s.clone().powf(a_0)))
                });
                methods.document(
                    "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                );
                methods.add_method("recip", |_, s, (): ()| Ok(LuaVec3::new(s.clone().recip())));
                methods . document ("Performs a linear interpolation between `self` and `rhs` based on the value `s`.") ;
                methods.document("");
                methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
                methods . document ("will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly") ;
                methods.document("extrapolated.");
                methods.add_method("lerp", |_, s, (a_0, a_1): (LuaVec3, f32)| {
                    Ok(LuaVec3::new(s.clone().lerp(a_0.clone(), a_1)))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs` is") ;
                methods.document("less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
                methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
                methods.document("the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaVec3, f32)| {
                    Ok(s.clone().abs_diff_eq(a_0.clone(), a_1))
                });
                methods.document(
                    "Returns a vector with a length no less than `min` and no more than `max`",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp_length", |_, s, (a_0, a_1): (f32, f32)| {
                    Ok(LuaVec3::new(s.clone().clamp_length(a_0, a_1)))
                });
                methods.document("Returns a vector with a length no more than `max`");
                methods.add_method("clamp_length_max", |_, s, (a_0): (f32)| {
                    Ok(LuaVec3::new(s.clone().clamp_length_max(a_0)))
                });
                methods.document("Returns a vector with a length no less than `min`");
                methods.add_method("clamp_length_min", |_, s, (a_0): (f32)| {
                    Ok(LuaVec3::new(s.clone().clamp_length_min(a_0)))
                });
                methods . document ("Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding") ;
                methods.document(
                    "error, yielding a more accurate result than an unfused multiply-add.",
                );
                methods.document("");
                methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
                methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
                methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
                methods.document("mind.");
                methods.add_method("mul_add", |_, s, (a_0, a_1): (LuaVec3, LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().mul_add(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the angle (in radians) between two vectors.");
                methods.document("");
                methods . document ("The input vectors do not need to be unit length however they must be non-zero.") ;
                methods.add_method("angle_between", |_, s, (a_0): (LuaVec3)| {
                    Ok(s.clone().angle_between(a_0.clone()))
                });
                methods.document("Returns some vector that is orthogonal to the given one.");
                methods.document("");
                methods.document("The input vector must be finite and non-zero.");
                methods.document("");
                methods.document("The output vector is not necessarily unit-length.");
                methods.document("For that use [`Self::any_orthonormal_vector`] instead.");
                methods.add_method("any_orthogonal_vector", |_, s, (): ()| {
                    Ok(LuaVec3::new(s.val(|s| s.any_orthogonal_vector())))
                });
                methods.document(
                    "Returns any unit-length vector that is orthogonal to the given one.",
                );
                methods.document("The input vector must be finite and non-zero.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `self` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("any_orthonormal_vector", |_, s, (): ()| {
                    Ok(LuaVec3::new(s.val(|s| s.any_orthonormal_vector())))
                });
            }
        }
        impl tealr::TypeName for LuaVec3 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaVec3"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaVec3 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaVec3 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaVec4 = crate::LuaWrapper<Vec4>;
        impl tealr::mlu::TealData for LuaVec4 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 4-dimensional vector with SIMD support.");
                methods.document_type("");
                methods
                    .document_type("This type uses 16 byte aligned SIMD vector type for storage.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaVec4::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| match (lhs, rhs) {
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                (ud.clone()).add(v.clone()),
                            ))),
                            UnionLuaVec4f32::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| match (lhs, rhs) {
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                (ud.clone()).sub(v.clone()),
                            ))),
                            UnionLuaVec4f32::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| match (lhs, rhs) {
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                (ud.clone()).div(v.clone()),
                            ))),
                            UnionLuaVec4f32::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| match (lhs, rhs) {
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                (ud.clone()).mul(v.clone()),
                            ))),
                            UnionLuaVec4f32::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionf32LuaVec4, UnionLuaVec4f32)| match (lhs, rhs) {
                        (Unionf32LuaVec4::LuaVec4(ud), v) => match v {
                            UnionLuaVec4f32::LuaVec4(v) => Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(
                                (ud.clone()).rem(v.clone()),
                            ))),
                            UnionLuaVec4f32::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaVec4f32::LuaVec4(ud)) => match v {
                            Unionf32LuaVec4::f32(v) => {
                                Ok(UnionLuaVec4::LuaVec4(LuaVec4::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods . document ("Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.") ;
                methods.document("");
                methods . document ("Truncation to `Vec3` may also be performed by using `self.xyz()` or `Vec3::from()`.") ;
                methods.document("");
                methods.document("To truncate to `Vec3A` use `Vec3A::from()`.");
                methods.add_method("truncate", |_, s, (): ()| {
                    Ok(LuaVec3::new(s.clone().truncate()))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaVec4)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaVec4)| {
                    Ok(LuaVec4::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaVec4)| {
                    Ok(LuaVec4::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaVec4, LuaVec4)| {
                    Ok(LuaVec4::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaVec4::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaVec4::new(s.clone().signum()))
                });
                methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
                methods.document("`NaN`, positive or negative infinity, this will return `false`.");
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.clone().is_finite()));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.clone().is_nan()));
                methods.document("Computes the length of `self`.");
                methods.add_method("length", |_, s, (): ()| Ok(s.clone().length()));
                methods.document("Computes the squared length of `self`.");
                methods.document("");
                methods.document(
                    "This is faster than `length()` as it avoids a square root operation.",
                );
                methods.add_method("length_squared", |_, s, (): ()| {
                    Ok(s.clone().length_squared())
                });
                methods.document("Computes `1.0 / length()`.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.add_method("length_recip", |_, s, (): ()| Ok(s.clone().length_recip()));
                methods.document("Computes the Euclidean distance between two points in space.");
                methods.add_method("distance", |_, s, (a_0): (LuaVec4)| {
                    Ok(s.clone().distance(a_0.clone()))
                });
                methods.document(
                    "Compute the squared euclidean distance between two points in space.",
                );
                methods.add_method("distance_squared", |_, s, (a_0): (LuaVec4)| {
                    Ok(s.clone().distance_squared(a_0.clone()))
                });
                methods.document("Returns `self` normalized to length 1.0.");
                methods.document("");
                methods . document ("For valid results, `self` must _not_ be of length zero, nor very close to zero.") ;
                methods.document("");
                methods
                    .document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
                methods.document("");
                methods.document("Panics");
                methods.document("");
                methods
                    .document("Will panic if `self` is zero length when `glam_assert` is enabled.");
                methods.add_method("normalize", |_, s, (): ()| {
                    Ok(LuaVec4::new(s.clone().normalize()))
                });
                methods.document(
                    "Returns `self` normalized to length 1.0 if possible, else returns zero.",
                );
                methods.document("");
                methods.document(
                    "In particular, if the input is zero (or very close to zero), or non-finite,",
                );
                methods.document("the result of this operation will be zero.");
                methods.document("");
                methods.document("See also [`Self::try_normalize`].");
                methods.add_method("normalize_or_zero", |_, s, (): ()| {
                    Ok(LuaVec4::new(s.clone().normalize_or_zero()))
                });
                methods.document("Returns whether `self` is length `1.0` or not.");
                methods.document("");
                methods.document("Uses a precision threshold of `1e-6`.");
                methods.add_method("is_normalized", |_, s, (): ()| {
                    Ok(s.clone().is_normalized())
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods
                    .document("Will panic if `rhs` is zero length when `glam_assert` is enabled.");
                methods.add_method("project_onto", |_, s, (a_0): (LuaVec4)| {
                    Ok(LuaVec4::new(s.clone().project_onto(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from", |_, s, (a_0): (LuaVec4)| {
                    Ok(LuaVec4::new(s.clone().reject_from(a_0.clone())))
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("project_onto_normalized", |_, s, (a_0): (LuaVec4)| {
                    Ok(LuaVec4::new(s.clone().project_onto_normalized(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from_normalized", |_, s, (a_0): (LuaVec4)| {
                    Ok(LuaVec4::new(s.clone().reject_from_normalized(a_0.clone())))
                });
                methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
                methods.document("Round half-way cases away from 0.0.");
                methods.add_method("round", |_, s, (): ()| Ok(LuaVec4::new(s.clone().round())));
                methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
                methods.document("element of `self`.");
                methods.add_method("floor", |_, s, (): ()| Ok(LuaVec4::new(s.clone().floor())));
                methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
                methods.document("each element of `self`.");
                methods.add_method("ceil", |_, s, (): ()| Ok(LuaVec4::new(s.clone().ceil())));
                methods.document(
                    "Returns a vector containing the fractional part of the vector, e.g. `self -",
                );
                methods.document("self.floor()`.");
                methods.document("");
                methods.document("Note that this is fast but not precise for large numbers.");
                methods.add_method("fract", |_, s, (): ()| Ok(LuaVec4::new(s.clone().fract())));
                methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
                methods.document("`self`.");
                methods.add_method("exp", |_, s, (): ()| Ok(LuaVec4::new(s.clone().exp())));
                methods . document ("Returns a vector containing each element of `self` raised to the power of `n`.") ;
                methods.add_method("powf", |_, s, (a_0): (f32)| {
                    Ok(LuaVec4::new(s.clone().powf(a_0)))
                });
                methods.document(
                    "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                );
                methods.add_method("recip", |_, s, (): ()| Ok(LuaVec4::new(s.clone().recip())));
                methods . document ("Performs a linear interpolation between `self` and `rhs` based on the value `s`.") ;
                methods.document("");
                methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
                methods . document ("will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly") ;
                methods.document("extrapolated.");
                methods.add_method("lerp", |_, s, (a_0, a_1): (LuaVec4, f32)| {
                    Ok(LuaVec4::new(s.clone().lerp(a_0.clone(), a_1)))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs` is") ;
                methods.document("less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
                methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
                methods.document("the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaVec4, f32)| {
                    Ok(s.clone().abs_diff_eq(a_0.clone(), a_1))
                });
                methods.document(
                    "Returns a vector with a length no less than `min` and no more than `max`",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp_length", |_, s, (a_0, a_1): (f32, f32)| {
                    Ok(LuaVec4::new(s.clone().clamp_length(a_0, a_1)))
                });
                methods.document("Returns a vector with a length no more than `max`");
                methods.add_method("clamp_length_max", |_, s, (a_0): (f32)| {
                    Ok(LuaVec4::new(s.clone().clamp_length_max(a_0)))
                });
                methods.document("Returns a vector with a length no less than `min`");
                methods.add_method("clamp_length_min", |_, s, (a_0): (f32)| {
                    Ok(LuaVec4::new(s.clone().clamp_length_min(a_0)))
                });
                methods . document ("Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding") ;
                methods.document(
                    "error, yielding a more accurate result than an unfused multiply-add.",
                );
                methods.document("");
                methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
                methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
                methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
                methods.document("mind.");
                methods.add_method("mul_add", |_, s, (a_0, a_1): (LuaVec4, LuaVec4)| {
                    Ok(LuaVec4::new(s.clone().mul_add(a_0.clone(), a_1.clone())))
                });
            }
        }
        impl tealr::TypeName for LuaVec4 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaVec4"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaVec4 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaVec4 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaDVec2 = crate::LuaWrapper<DVec2>;
        impl tealr::mlu::TealData for LuaDVec2 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 2-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f64)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaDVec2::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => Ok(UnionLuaDVec2::LuaDVec2(
                                LuaDVec2::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaDVec2f64::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaDVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => Ok(UnionLuaDVec2::LuaDVec2(
                                LuaDVec2::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaDVec2f64::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaDVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => Ok(UnionLuaDVec2::LuaDVec2(
                                LuaDVec2::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaDVec2f64::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaDVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaDVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaDVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => Ok(UnionLuaDVec2::LuaDVec2(
                                LuaDVec2::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaDVec2f64::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaDVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec2, UnionLuaDVec2f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec2::LuaDVec2(ud), v) => match v {
                            UnionLuaDVec2f64::LuaDVec2(v) => Ok(UnionLuaDVec2::LuaDVec2(
                                LuaDVec2::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaDVec2f64::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaDVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec2f64::LuaDVec2(ud)) => match v {
                            Unionf64LuaDVec2::f64(v) => {
                                Ok(UnionLuaDVec2::LuaDVec2(LuaDVec2::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaDVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaDVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Creates a 3D vector from `self` and the given `z` value.");
                methods.add_method("extend", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec3::new(s.clone().extend(a_0)))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaDVec2)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaDVec2, LuaDVec2)| {
                    Ok(LuaDVec2::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaDVec2::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaDVec2::new(s.clone().signum()))
                });
                methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
                methods.document("`NaN`, positive or negative infinity, this will return `false`.");
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.clone().is_finite()));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.clone().is_nan()));
                methods.document("Computes the length of `self`.");
                methods.add_method("length", |_, s, (): ()| Ok(s.clone().length()));
                methods.document("Computes the squared length of `self`.");
                methods.document("");
                methods.document(
                    "This is faster than `length()` as it avoids a square root operation.",
                );
                methods.add_method("length_squared", |_, s, (): ()| {
                    Ok(s.clone().length_squared())
                });
                methods.document("Computes `1.0 / length()`.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.add_method("length_recip", |_, s, (): ()| Ok(s.clone().length_recip()));
                methods.document("Computes the Euclidean distance between two points in space.");
                methods.add_method("distance", |_, s, (a_0): (LuaDVec2)| {
                    Ok(s.clone().distance(a_0.clone()))
                });
                methods.document(
                    "Compute the squared euclidean distance between two points in space.",
                );
                methods.add_method("distance_squared", |_, s, (a_0): (LuaDVec2)| {
                    Ok(s.clone().distance_squared(a_0.clone()))
                });
                methods.document("Returns `self` normalized to length 1.0.");
                methods.document("");
                methods . document ("For valid results, `self` must _not_ be of length zero, nor very close to zero.") ;
                methods.document("");
                methods
                    .document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
                methods.document("");
                methods.document("Panics");
                methods.document("");
                methods
                    .document("Will panic if `self` is zero length when `glam_assert` is enabled.");
                methods.add_method("normalize", |_, s, (): ()| {
                    Ok(LuaDVec2::new(s.clone().normalize()))
                });
                methods.document(
                    "Returns `self` normalized to length 1.0 if possible, else returns zero.",
                );
                methods.document("");
                methods.document(
                    "In particular, if the input is zero (or very close to zero), or non-finite,",
                );
                methods.document("the result of this operation will be zero.");
                methods.document("");
                methods.document("See also [`Self::try_normalize`].");
                methods.add_method("normalize_or_zero", |_, s, (): ()| {
                    Ok(LuaDVec2::new(s.clone().normalize_or_zero()))
                });
                methods.document("Returns whether `self` is length `1.0` or not.");
                methods.document("");
                methods.document("Uses a precision threshold of `1e-6`.");
                methods.add_method("is_normalized", |_, s, (): ()| {
                    Ok(s.clone().is_normalized())
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods
                    .document("Will panic if `rhs` is zero length when `glam_assert` is enabled.");
                methods.add_method("project_onto", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(s.clone().project_onto(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(s.clone().reject_from(a_0.clone())))
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("project_onto_normalized", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(
                        s.clone().project_onto_normalized(a_0.clone()),
                    ))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from_normalized", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(s.clone().reject_from_normalized(a_0.clone())))
                });
                methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
                methods.document("Round half-way cases away from 0.0.");
                methods.add_method("round", |_, s, (): ()| Ok(LuaDVec2::new(s.clone().round())));
                methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
                methods.document("element of `self`.");
                methods.add_method("floor", |_, s, (): ()| Ok(LuaDVec2::new(s.clone().floor())));
                methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
                methods.document("each element of `self`.");
                methods.add_method("ceil", |_, s, (): ()| Ok(LuaDVec2::new(s.clone().ceil())));
                methods.document(
                    "Returns a vector containing the fractional part of the vector, e.g. `self -",
                );
                methods.document("self.floor()`.");
                methods.document("");
                methods.document("Note that this is fast but not precise for large numbers.");
                methods.add_method("fract", |_, s, (): ()| Ok(LuaDVec2::new(s.clone().fract())));
                methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
                methods.document("`self`.");
                methods.add_method("exp", |_, s, (): ()| Ok(LuaDVec2::new(s.clone().exp())));
                methods . document ("Returns a vector containing each element of `self` raised to the power of `n`.") ;
                methods.add_method("powf", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec2::new(s.clone().powf(a_0)))
                });
                methods.document(
                    "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                );
                methods.add_method("recip", |_, s, (): ()| Ok(LuaDVec2::new(s.clone().recip())));
                methods . document ("Performs a linear interpolation between `self` and `rhs` based on the value `s`.") ;
                methods.document("");
                methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
                methods . document ("will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly") ;
                methods.document("extrapolated.");
                methods.add_method("lerp", |_, s, (a_0, a_1): (LuaDVec2, f64)| {
                    Ok(LuaDVec2::new(s.clone().lerp(a_0.clone(), a_1)))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs` is") ;
                methods.document("less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
                methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
                methods.document("the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaDVec2, f64)| {
                    Ok(s.clone().abs_diff_eq(a_0.clone(), a_1))
                });
                methods.document(
                    "Returns a vector with a length no less than `min` and no more than `max`",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp_length", |_, s, (a_0, a_1): (f64, f64)| {
                    Ok(LuaDVec2::new(s.clone().clamp_length(a_0, a_1)))
                });
                methods.document("Returns a vector with a length no more than `max`");
                methods.add_method("clamp_length_max", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec2::new(s.clone().clamp_length_max(a_0)))
                });
                methods.document("Returns a vector with a length no less than `min`");
                methods.add_method("clamp_length_min", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec2::new(s.clone().clamp_length_min(a_0)))
                });
                methods . document ("Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding") ;
                methods.document(
                    "error, yielding a more accurate result than an unfused multiply-add.",
                );
                methods.document("");
                methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
                methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
                methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
                methods.document("mind.");
                methods.add_method("mul_add", |_, s, (a_0, a_1): (LuaDVec2, LuaDVec2)| {
                    Ok(LuaDVec2::new(s.clone().mul_add(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the angle (in radians) between `self` and `rhs`.");
                methods.document("");
                methods . document ("The input vectors do not need to be unit length however they must be non-zero.") ;
                methods.add_method("angle_between", |_, s, (a_0): (LuaDVec2)| {
                    Ok(s.clone().angle_between(a_0.clone()))
                });
                methods.document("Returns a vector that is equal to `self` rotated by 90 degrees.");
                methods.add_method("perp", |_, s, (): ()| Ok(LuaDVec2::new(s.clone().perp())));
                methods.document("The perpendicular dot product of `self` and `rhs`.");
                methods.document(
                    "Also known as the wedge product, 2D cross product, and determinant.",
                );
                methods.add_method("perp_dot", |_, s, (a_0): (LuaDVec2)| {
                    Ok(s.clone().perp_dot(a_0.clone()))
                });
                methods.document(
                    "Returns `rhs` rotated by the angle of `self`. If `self` is normalized,",
                );
                methods
                    .document("then this just rotation. This is what you usually want. Otherwise,");
                methods.document(
                    "it will be like a rotation with a multiplication by `self`\'s length.",
                );
                methods.add_method("rotate", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(s.clone().rotate(a_0.clone())))
                });
            }
        }
        impl tealr::TypeName for LuaDVec2 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDVec2"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDVec2 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDVec2 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaDVec3 = crate::LuaWrapper<DVec3>;
        impl tealr::mlu::TealData for LuaDVec3 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 3-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f64)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaDVec3::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => Ok(UnionLuaDVec3::LuaDVec3(
                                LuaDVec3::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaDVec3f64::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaDVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => Ok(UnionLuaDVec3::LuaDVec3(
                                LuaDVec3::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaDVec3f64::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaDVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => Ok(UnionLuaDVec3::LuaDVec3(
                                LuaDVec3::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaDVec3f64::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaDVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaDVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaDVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => Ok(UnionLuaDVec3::LuaDVec3(
                                LuaDVec3::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaDVec3f64::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaDVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec3, UnionLuaDVec3f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec3::LuaDVec3(ud), v) => match v {
                            UnionLuaDVec3f64::LuaDVec3(v) => Ok(UnionLuaDVec3::LuaDVec3(
                                LuaDVec3::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaDVec3f64::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaDVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec3f64::LuaDVec3(ud)) => match v {
                            Unionf64LuaDVec3::f64(v) => {
                                Ok(UnionLuaDVec3::LuaDVec3(LuaDVec3::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaDVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaDVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Creates a 4D vector from `self` and the given `w` value.");
                methods.add_method("extend", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec4::new(s.clone().extend(a_0)))
                });
                methods.document(
                    "Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.",
                );
                methods.document("");
                methods.document(
                    "Truncation may also be performed by using `self.xy()` or `DVec2::from()`.",
                );
                methods.add_method("truncate", |_, s, (): ()| {
                    Ok(LuaDVec2::new(s.clone().truncate()))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaDVec3)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods.document("Computes the cross product of `self` and `rhs`.");
                methods.add_method("cross", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().cross(a_0.clone())))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaDVec3, LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaDVec3::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaDVec3::new(s.clone().signum()))
                });
                methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
                methods.document("`NaN`, positive or negative infinity, this will return `false`.");
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.clone().is_finite()));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.clone().is_nan()));
                methods.document("Computes the length of `self`.");
                methods.add_method("length", |_, s, (): ()| Ok(s.clone().length()));
                methods.document("Computes the squared length of `self`.");
                methods.document("");
                methods.document(
                    "This is faster than `length()` as it avoids a square root operation.",
                );
                methods.add_method("length_squared", |_, s, (): ()| {
                    Ok(s.clone().length_squared())
                });
                methods.document("Computes `1.0 / length()`.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.add_method("length_recip", |_, s, (): ()| Ok(s.clone().length_recip()));
                methods.document("Computes the Euclidean distance between two points in space.");
                methods.add_method("distance", |_, s, (a_0): (LuaDVec3)| {
                    Ok(s.clone().distance(a_0.clone()))
                });
                methods.document(
                    "Compute the squared euclidean distance between two points in space.",
                );
                methods.add_method("distance_squared", |_, s, (a_0): (LuaDVec3)| {
                    Ok(s.clone().distance_squared(a_0.clone()))
                });
                methods.document("Returns `self` normalized to length 1.0.");
                methods.document("");
                methods . document ("For valid results, `self` must _not_ be of length zero, nor very close to zero.") ;
                methods.document("");
                methods
                    .document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
                methods.document("");
                methods.document("Panics");
                methods.document("");
                methods
                    .document("Will panic if `self` is zero length when `glam_assert` is enabled.");
                methods.add_method("normalize", |_, s, (): ()| {
                    Ok(LuaDVec3::new(s.clone().normalize()))
                });
                methods.document(
                    "Returns `self` normalized to length 1.0 if possible, else returns zero.",
                );
                methods.document("");
                methods.document(
                    "In particular, if the input is zero (or very close to zero), or non-finite,",
                );
                methods.document("the result of this operation will be zero.");
                methods.document("");
                methods.document("See also [`Self::try_normalize`].");
                methods.add_method("normalize_or_zero", |_, s, (): ()| {
                    Ok(LuaDVec3::new(s.clone().normalize_or_zero()))
                });
                methods.document("Returns whether `self` is length `1.0` or not.");
                methods.document("");
                methods.document("Uses a precision threshold of `1e-6`.");
                methods.add_method("is_normalized", |_, s, (): ()| {
                    Ok(s.clone().is_normalized())
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods
                    .document("Will panic if `rhs` is zero length when `glam_assert` is enabled.");
                methods.add_method("project_onto", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().project_onto(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().reject_from(a_0.clone())))
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("project_onto_normalized", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(
                        s.clone().project_onto_normalized(a_0.clone()),
                    ))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from_normalized", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().reject_from_normalized(a_0.clone())))
                });
                methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
                methods.document("Round half-way cases away from 0.0.");
                methods.add_method("round", |_, s, (): ()| Ok(LuaDVec3::new(s.clone().round())));
                methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
                methods.document("element of `self`.");
                methods.add_method("floor", |_, s, (): ()| Ok(LuaDVec3::new(s.clone().floor())));
                methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
                methods.document("each element of `self`.");
                methods.add_method("ceil", |_, s, (): ()| Ok(LuaDVec3::new(s.clone().ceil())));
                methods.document(
                    "Returns a vector containing the fractional part of the vector, e.g. `self -",
                );
                methods.document("self.floor()`.");
                methods.document("");
                methods.document("Note that this is fast but not precise for large numbers.");
                methods.add_method("fract", |_, s, (): ()| Ok(LuaDVec3::new(s.clone().fract())));
                methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
                methods.document("`self`.");
                methods.add_method("exp", |_, s, (): ()| Ok(LuaDVec3::new(s.clone().exp())));
                methods . document ("Returns a vector containing each element of `self` raised to the power of `n`.") ;
                methods.add_method("powf", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec3::new(s.clone().powf(a_0)))
                });
                methods.document(
                    "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                );
                methods.add_method("recip", |_, s, (): ()| Ok(LuaDVec3::new(s.clone().recip())));
                methods . document ("Performs a linear interpolation between `self` and `rhs` based on the value `s`.") ;
                methods.document("");
                methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
                methods . document ("will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly") ;
                methods.document("extrapolated.");
                methods.add_method("lerp", |_, s, (a_0, a_1): (LuaDVec3, f64)| {
                    Ok(LuaDVec3::new(s.clone().lerp(a_0.clone(), a_1)))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs` is") ;
                methods.document("less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
                methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
                methods.document("the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaDVec3, f64)| {
                    Ok(s.clone().abs_diff_eq(a_0.clone(), a_1))
                });
                methods.document(
                    "Returns a vector with a length no less than `min` and no more than `max`",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp_length", |_, s, (a_0, a_1): (f64, f64)| {
                    Ok(LuaDVec3::new(s.clone().clamp_length(a_0, a_1)))
                });
                methods.document("Returns a vector with a length no more than `max`");
                methods.add_method("clamp_length_max", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec3::new(s.clone().clamp_length_max(a_0)))
                });
                methods.document("Returns a vector with a length no less than `min`");
                methods.add_method("clamp_length_min", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec3::new(s.clone().clamp_length_min(a_0)))
                });
                methods . document ("Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding") ;
                methods.document(
                    "error, yielding a more accurate result than an unfused multiply-add.",
                );
                methods.document("");
                methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
                methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
                methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
                methods.document("mind.");
                methods.add_method("mul_add", |_, s, (a_0, a_1): (LuaDVec3, LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().mul_add(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the angle (in radians) between two vectors.");
                methods.document("");
                methods . document ("The input vectors do not need to be unit length however they must be non-zero.") ;
                methods.add_method("angle_between", |_, s, (a_0): (LuaDVec3)| {
                    Ok(s.clone().angle_between(a_0.clone()))
                });
                methods.document("Returns some vector that is orthogonal to the given one.");
                methods.document("");
                methods.document("The input vector must be finite and non-zero.");
                methods.document("");
                methods.document("The output vector is not necessarily unit-length.");
                methods.document("For that use [`Self::any_orthonormal_vector`] instead.");
                methods.add_method("any_orthogonal_vector", |_, s, (): ()| {
                    Ok(LuaDVec3::new(s.val(|s| s.any_orthogonal_vector())))
                });
                methods.document(
                    "Returns any unit-length vector that is orthogonal to the given one.",
                );
                methods.document("The input vector must be finite and non-zero.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `self` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("any_orthonormal_vector", |_, s, (): ()| {
                    Ok(LuaDVec3::new(s.val(|s| s.any_orthonormal_vector())))
                });
            }
        }
        impl tealr::TypeName for LuaDVec3 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDVec3"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDVec3 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDVec3 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaDVec4 = crate::LuaWrapper<DVec4>;
        impl tealr::mlu::TealData for LuaDVec4 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 4-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, f64)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaDVec4::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => Ok(UnionLuaDVec4::LuaDVec4(
                                LuaDVec4::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaDVec4f64::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaDVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => Ok(UnionLuaDVec4::LuaDVec4(
                                LuaDVec4::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaDVec4f64::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaDVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => Ok(UnionLuaDVec4::LuaDVec4(
                                LuaDVec4::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaDVec4f64::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaDVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaDVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaDVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => Ok(UnionLuaDVec4::LuaDVec4(
                                LuaDVec4::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaDVec4f64::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaDVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionf64LuaDVec4, UnionLuaDVec4f64)| match (lhs, rhs) {
                        (Unionf64LuaDVec4::LuaDVec4(ud), v) => match v {
                            UnionLuaDVec4f64::LuaDVec4(v) => Ok(UnionLuaDVec4::LuaDVec4(
                                LuaDVec4::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaDVec4f64::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaDVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDVec4f64::LuaDVec4(ud)) => match v {
                            Unionf64LuaDVec4::f64(v) => {
                                Ok(UnionLuaDVec4::LuaDVec4(LuaDVec4::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaDVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaDVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods . document ("Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.") ;
                methods.document("");
                methods . document ("Truncation to `DVec3` may also be performed by using `self.xyz()` or `DVec3::from()`.") ;
                methods.add_method("truncate", |_, s, (): ()| {
                    Ok(LuaDVec3::new(s.clone().truncate()))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaDVec4)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaDVec4)| {
                    Ok(LuaDVec4::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaDVec4)| {
                    Ok(LuaDVec4::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaDVec4, LuaDVec4)| {
                    Ok(LuaDVec4::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaDVec4::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaDVec4::new(s.clone().signum()))
                });
                methods . document ("Returns `true` if, and only if, all elements are finite.  If any element is either") ;
                methods.document("`NaN`, positive or negative infinity, this will return `false`.");
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.clone().is_finite()));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.clone().is_nan()));
                methods.document("Computes the length of `self`.");
                methods.add_method("length", |_, s, (): ()| Ok(s.clone().length()));
                methods.document("Computes the squared length of `self`.");
                methods.document("");
                methods.document(
                    "This is faster than `length()` as it avoids a square root operation.",
                );
                methods.add_method("length_squared", |_, s, (): ()| {
                    Ok(s.clone().length_squared())
                });
                methods.document("Computes `1.0 / length()`.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.add_method("length_recip", |_, s, (): ()| Ok(s.clone().length_recip()));
                methods.document("Computes the Euclidean distance between two points in space.");
                methods.add_method("distance", |_, s, (a_0): (LuaDVec4)| {
                    Ok(s.clone().distance(a_0.clone()))
                });
                methods.document(
                    "Compute the squared euclidean distance between two points in space.",
                );
                methods.add_method("distance_squared", |_, s, (a_0): (LuaDVec4)| {
                    Ok(s.clone().distance_squared(a_0.clone()))
                });
                methods.document("Returns `self` normalized to length 1.0.");
                methods.document("");
                methods . document ("For valid results, `self` must _not_ be of length zero, nor very close to zero.") ;
                methods.document("");
                methods
                    .document("See also [`Self::try_normalize`] and [`Self::normalize_or_zero`].");
                methods.document("");
                methods.document("Panics");
                methods.document("");
                methods
                    .document("Will panic if `self` is zero length when `glam_assert` is enabled.");
                methods.add_method("normalize", |_, s, (): ()| {
                    Ok(LuaDVec4::new(s.clone().normalize()))
                });
                methods.document(
                    "Returns `self` normalized to length 1.0 if possible, else returns zero.",
                );
                methods.document("");
                methods.document(
                    "In particular, if the input is zero (or very close to zero), or non-finite,",
                );
                methods.document("the result of this operation will be zero.");
                methods.document("");
                methods.document("See also [`Self::try_normalize`].");
                methods.add_method("normalize_or_zero", |_, s, (): ()| {
                    Ok(LuaDVec4::new(s.clone().normalize_or_zero()))
                });
                methods.document("Returns whether `self` is length `1.0` or not.");
                methods.document("");
                methods.document("Uses a precision threshold of `1e-6`.");
                methods.add_method("is_normalized", |_, s, (): ()| {
                    Ok(s.clone().is_normalized())
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods
                    .document("Will panic if `rhs` is zero length when `glam_assert` is enabled.");
                methods.add_method("project_onto", |_, s, (a_0): (LuaDVec4)| {
                    Ok(LuaDVec4::new(s.clone().project_onto(a_0.clone())))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be of non-zero length.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` has a length of zero when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from", |_, s, (a_0): (LuaDVec4)| {
                    Ok(LuaDVec4::new(s.clone().reject_from(a_0.clone())))
                });
                methods.document("Returns the vector projection of `self` onto `rhs`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("project_onto_normalized", |_, s, (a_0): (LuaDVec4)| {
                    Ok(LuaDVec4::new(
                        s.clone().project_onto_normalized(a_0.clone()),
                    ))
                });
                methods.document("Returns the vector rejection of `self` from `rhs`.");
                methods.document("");
                methods . document ("The vector rejection is the vector perpendicular to the projection of `self` onto") ;
                methods
                    .document("`rhs`, in rhs words the result of `self - self.project_onto(rhs)`.");
                methods.document("");
                methods.document("`rhs` must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rhs` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("reject_from_normalized", |_, s, (a_0): (LuaDVec4)| {
                    Ok(LuaDVec4::new(s.clone().reject_from_normalized(a_0.clone())))
                });
                methods . document ("Returns a vector containing the nearest integer to a number for each element of `self`.") ;
                methods.document("Round half-way cases away from 0.0.");
                methods.add_method("round", |_, s, (): ()| Ok(LuaDVec4::new(s.clone().round())));
                methods . document ("Returns a vector containing the largest integer less than or equal to a number for each") ;
                methods.document("element of `self`.");
                methods.add_method("floor", |_, s, (): ()| Ok(LuaDVec4::new(s.clone().floor())));
                methods . document ("Returns a vector containing the smallest integer greater than or equal to a number for") ;
                methods.document("each element of `self`.");
                methods.add_method("ceil", |_, s, (): ()| Ok(LuaDVec4::new(s.clone().ceil())));
                methods.document(
                    "Returns a vector containing the fractional part of the vector, e.g. `self -",
                );
                methods.document("self.floor()`.");
                methods.document("");
                methods.document("Note that this is fast but not precise for large numbers.");
                methods.add_method("fract", |_, s, (): ()| Ok(LuaDVec4::new(s.clone().fract())));
                methods . document ("Returns a vector containing `e^self` (the exponential function) for each element of") ;
                methods.document("`self`.");
                methods.add_method("exp", |_, s, (): ()| Ok(LuaDVec4::new(s.clone().exp())));
                methods . document ("Returns a vector containing each element of `self` raised to the power of `n`.") ;
                methods.add_method("powf", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec4::new(s.clone().powf(a_0)))
                });
                methods.document(
                    "Returns a vector containing the reciprocal `1.0/n` of each element of `self`.",
                );
                methods.add_method("recip", |_, s, (): ()| Ok(LuaDVec4::new(s.clone().recip())));
                methods . document ("Performs a linear interpolation between `self` and `rhs` based on the value `s`.") ;
                methods.document("");
                methods . document ("When `s` is `0.0`, the result will be equal to `self`.  When `s` is `1.0`, the result") ;
                methods . document ("will be equal to `rhs`. When `s` is outside of range `[0, 1]`, the result is linearly") ;
                methods.document("extrapolated.");
                methods.add_method("lerp", |_, s, (a_0, a_1): (LuaDVec4, f64)| {
                    Ok(LuaDVec4::new(s.clone().lerp(a_0.clone(), a_1)))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs` is") ;
                methods.document("less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two vectors contain similar elements. It works best when") ;
                methods . document ("comparing with a known value. The `max_abs_diff` that should be used used depends on") ;
                methods.document("the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaDVec4, f64)| {
                    Ok(s.clone().abs_diff_eq(a_0.clone(), a_1))
                });
                methods.document(
                    "Returns a vector with a length no less than `min` and no more than `max`",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp_length", |_, s, (a_0, a_1): (f64, f64)| {
                    Ok(LuaDVec4::new(s.clone().clamp_length(a_0, a_1)))
                });
                methods.document("Returns a vector with a length no more than `max`");
                methods.add_method("clamp_length_max", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec4::new(s.clone().clamp_length_max(a_0)))
                });
                methods.document("Returns a vector with a length no less than `min`");
                methods.add_method("clamp_length_min", |_, s, (a_0): (f64)| {
                    Ok(LuaDVec4::new(s.clone().clamp_length_min(a_0)))
                });
                methods . document ("Fused multiply-add. Computes `(self * a) + b` element-wise with only one rounding") ;
                methods.document(
                    "error, yielding a more accurate result than an unfused multiply-add.",
                );
                methods.document("");
                methods . document ("Using `mul_add` *may* be more performant than an unfused multiply-add if the target") ;
                methods . document ("architecture has a dedicated fma CPU instruction. However, this is not always true,") ;
                methods . document ("and will be heavily dependant on designing algorithms with specific target hardware in") ;
                methods.document("mind.");
                methods.add_method("mul_add", |_, s, (a_0, a_1): (LuaDVec4, LuaDVec4)| {
                    Ok(LuaDVec4::new(s.clone().mul_add(a_0.clone(), a_1.clone())))
                });
            }
        }
        impl tealr::TypeName for LuaDVec4 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDVec4"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDVec4 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDVec4 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaIVec2 = crate::LuaWrapper<IVec2>;
        impl tealr::mlu::TealData for LuaIVec2 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 2-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, i32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaIVec2::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => Ok(UnionLuaIVec2::LuaIVec2(
                                LuaIVec2::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaIVec2i32::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaIVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaIVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaIVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => Ok(UnionLuaIVec2::LuaIVec2(
                                LuaIVec2::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaIVec2i32::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaIVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaIVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaIVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => Ok(UnionLuaIVec2::LuaIVec2(
                                LuaIVec2::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaIVec2i32::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaIVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaIVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaIVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => Ok(UnionLuaIVec2::LuaIVec2(
                                LuaIVec2::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaIVec2i32::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaIVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaIVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaIVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec2, UnionLuaIVec2i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec2::LuaIVec2(ud), v) => match v {
                            UnionLuaIVec2i32::LuaIVec2(v) => Ok(UnionLuaIVec2::LuaIVec2(
                                LuaIVec2::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaIVec2i32::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaIVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec2i32::LuaIVec2(ud)) => match v {
                            Unioni32LuaIVec2::i32(v) => {
                                Ok(UnionLuaIVec2::LuaIVec2(LuaIVec2::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaIVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaIVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Creates a 3D vector from `self` and the given `z` value.");
                methods.add_method("extend", |_, s, (a_0): (i32)| {
                    Ok(LuaIVec3::new(s.clone().extend(a_0)))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaIVec2)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaIVec2)| {
                    Ok(LuaIVec2::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaIVec2)| {
                    Ok(LuaIVec2::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaIVec2, LuaIVec2)| {
                    Ok(LuaIVec2::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaIVec2::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaIVec2::new(s.clone().signum()))
                });
                methods.document("Returns a vector that is equal to `self` rotated by 90 degrees.");
                methods.add_method("perp", |_, s, (): ()| Ok(LuaIVec2::new(s.clone().perp())));
                methods.document("The perpendicular dot product of `self` and `rhs`.");
                methods.document(
                    "Also known as the wedge product, 2D cross product, and determinant.",
                );
                methods.add_method("perp_dot", |_, s, (a_0): (LuaIVec2)| {
                    Ok(s.clone().perp_dot(a_0.clone()))
                });
                methods.document(
                    "Returns `rhs` rotated by the angle of `self`. If `self` is normalized,",
                );
                methods
                    .document("then this just rotation. This is what you usually want. Otherwise,");
                methods.document(
                    "it will be like a rotation with a multiplication by `self`\'s length.",
                );
                methods.add_method("rotate", |_, s, (a_0): (LuaIVec2)| {
                    Ok(LuaIVec2::new(s.clone().rotate(a_0.clone())))
                });
            }
        }
        impl tealr::TypeName for LuaIVec2 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaIVec2"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaIVec2 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaIVec2 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaIVec3 = crate::LuaWrapper<IVec3>;
        impl tealr::mlu::TealData for LuaIVec3 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 3-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, i32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaIVec3::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => Ok(UnionLuaIVec3::LuaIVec3(
                                LuaIVec3::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaIVec3i32::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaIVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaIVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaIVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => Ok(UnionLuaIVec3::LuaIVec3(
                                LuaIVec3::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaIVec3i32::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaIVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaIVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaIVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => Ok(UnionLuaIVec3::LuaIVec3(
                                LuaIVec3::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaIVec3i32::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaIVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaIVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaIVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => Ok(UnionLuaIVec3::LuaIVec3(
                                LuaIVec3::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaIVec3i32::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaIVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaIVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaIVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec3, UnionLuaIVec3i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec3::LuaIVec3(ud), v) => match v {
                            UnionLuaIVec3i32::LuaIVec3(v) => Ok(UnionLuaIVec3::LuaIVec3(
                                LuaIVec3::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaIVec3i32::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaIVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec3i32::LuaIVec3(ud)) => match v {
                            Unioni32LuaIVec3::i32(v) => {
                                Ok(UnionLuaIVec3::LuaIVec3(LuaIVec3::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaIVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaIVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Creates a 4D vector from `self` and the given `w` value.");
                methods.add_method("extend", |_, s, (a_0): (i32)| {
                    Ok(LuaIVec4::new(s.clone().extend(a_0)))
                });
                methods.document(
                    "Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.",
                );
                methods.document("");
                methods.document(
                    "Truncation may also be performed by using `self.xy()` or `IVec2::from()`.",
                );
                methods.add_method("truncate", |_, s, (): ()| {
                    Ok(LuaIVec2::new(s.clone().truncate()))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaIVec3)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods.document("Computes the cross product of `self` and `rhs`.");
                methods.add_method("cross", |_, s, (a_0): (LuaIVec3)| {
                    Ok(LuaIVec3::new(s.clone().cross(a_0.clone())))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaIVec3)| {
                    Ok(LuaIVec3::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaIVec3)| {
                    Ok(LuaIVec3::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaIVec3, LuaIVec3)| {
                    Ok(LuaIVec3::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaIVec3::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaIVec3::new(s.clone().signum()))
                });
            }
        }
        impl tealr::TypeName for LuaIVec3 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaIVec3"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaIVec3 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaIVec3 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaIVec4 = crate::LuaWrapper<IVec4>;
        impl tealr::mlu::TealData for LuaIVec4 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 4-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, i32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaIVec4::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => Ok(UnionLuaIVec4::LuaIVec4(
                                LuaIVec4::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaIVec4i32::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaIVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaIVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaIVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => Ok(UnionLuaIVec4::LuaIVec4(
                                LuaIVec4::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaIVec4i32::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaIVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaIVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaIVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => Ok(UnionLuaIVec4::LuaIVec4(
                                LuaIVec4::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaIVec4i32::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaIVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaIVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaIVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => Ok(UnionLuaIVec4::LuaIVec4(
                                LuaIVec4::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaIVec4i32::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaIVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaIVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaIVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unioni32LuaIVec4, UnionLuaIVec4i32)| match (lhs, rhs) {
                        (Unioni32LuaIVec4::LuaIVec4(ud), v) => match v {
                            UnionLuaIVec4i32::LuaIVec4(v) => Ok(UnionLuaIVec4::LuaIVec4(
                                LuaIVec4::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaIVec4i32::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaIVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaIVec4i32::LuaIVec4(ud)) => match v {
                            Unioni32LuaIVec4::i32(v) => {
                                Ok(UnionLuaIVec4::LuaIVec4(LuaIVec4::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaIVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaIVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods . document ("Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.") ;
                methods.document("");
                methods . document ("Truncation to `IVec3` may also be performed by using `self.xyz()` or `IVec3::from()`.") ;
                methods.add_method("truncate", |_, s, (): ()| {
                    Ok(LuaIVec3::new(s.clone().truncate()))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaIVec4)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaIVec4)| {
                    Ok(LuaIVec4::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaIVec4)| {
                    Ok(LuaIVec4::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaIVec4, LuaIVec4)| {
                    Ok(LuaIVec4::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
                methods.document(
                    "Returns a vector containing the absolute value of each element of `self`.",
                );
                methods.add_method("abs", |_, s, (): ()| Ok(LuaIVec4::new(s.clone().abs())));
                methods.document("Returns a vector with elements representing the sign of `self`.");
                methods.document("");
                methods.document("- `1.0` if the number is positive, `+0.0` or `INFINITY`");
                methods.document("- `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`");
                methods.document("- `NAN` if the number is `NAN`");
                methods.add_method("signum", |_, s, (): ()| {
                    Ok(LuaIVec4::new(s.clone().signum()))
                });
            }
        }
        impl tealr::TypeName for LuaIVec4 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaIVec4"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaIVec4 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaIVec4 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaUVec2 = crate::LuaWrapper<UVec2>;
        impl tealr::mlu::TealData for LuaUVec2 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 2-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, u32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => Ok(UnionLuaUVec2::LuaUVec2(
                                LuaUVec2::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaUVec2u32::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaUVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaUVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaUVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => Ok(UnionLuaUVec2::LuaUVec2(
                                LuaUVec2::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaUVec2u32::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaUVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaUVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaUVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => Ok(UnionLuaUVec2::LuaUVec2(
                                LuaUVec2::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaUVec2u32::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaUVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaUVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaUVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => Ok(UnionLuaUVec2::LuaUVec2(
                                LuaUVec2::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaUVec2u32::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaUVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaUVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaUVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec2, UnionLuaUVec2u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec2::LuaUVec2(ud), v) => match v {
                            UnionLuaUVec2u32::LuaUVec2(v) => Ok(UnionLuaUVec2::LuaUVec2(
                                LuaUVec2::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaUVec2u32::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaUVec2", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec2u32::LuaUVec2(ud)) => match v {
                            Unionu32LuaUVec2::u32(v) => {
                                Ok(UnionLuaUVec2::LuaUVec2(LuaUVec2::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaUVec2", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaUVec2") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Creates a 3D vector from `self` and the given `z` value.");
                methods.add_method("extend", |_, s, (a_0): (u32)| {
                    Ok(LuaUVec3::new(s.clone().extend(a_0)))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaUVec2)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaUVec2)| {
                    Ok(LuaUVec2::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaUVec2)| {
                    Ok(LuaUVec2::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaUVec2, LuaUVec2)| {
                    Ok(LuaUVec2::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
            }
        }
        impl tealr::TypeName for LuaUVec2 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaUVec2"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaUVec2 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaUVec2 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaUVec3 = crate::LuaWrapper<UVec3>;
        impl tealr::mlu::TealData for LuaUVec3 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 3-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, u32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => Ok(UnionLuaUVec3::LuaUVec3(
                                LuaUVec3::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaUVec3u32::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaUVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaUVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaUVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => Ok(UnionLuaUVec3::LuaUVec3(
                                LuaUVec3::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaUVec3u32::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaUVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaUVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaUVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => Ok(UnionLuaUVec3::LuaUVec3(
                                LuaUVec3::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaUVec3u32::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaUVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaUVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaUVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => Ok(UnionLuaUVec3::LuaUVec3(
                                LuaUVec3::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaUVec3u32::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaUVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaUVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaUVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec3, UnionLuaUVec3u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec3::LuaUVec3(ud), v) => match v {
                            UnionLuaUVec3u32::LuaUVec3(v) => Ok(UnionLuaUVec3::LuaUVec3(
                                LuaUVec3::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaUVec3u32::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaUVec3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec3u32::LuaUVec3(ud)) => match v {
                            Unionu32LuaUVec3::u32(v) => {
                                Ok(UnionLuaUVec3::LuaUVec3(LuaUVec3::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaUVec3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaUVec3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Creates a 4D vector from `self` and the given `w` value.");
                methods.add_method("extend", |_, s, (a_0): (u32)| {
                    Ok(LuaUVec4::new(s.clone().extend(a_0)))
                });
                methods.document(
                    "Creates a 2D vector from the `x` and `y` elements of `self`, discarding `z`.",
                );
                methods.document("");
                methods.document(
                    "Truncation may also be performed by using `self.xy()` or `UVec2::from()`.",
                );
                methods.add_method("truncate", |_, s, (): ()| {
                    Ok(LuaUVec2::new(s.clone().truncate()))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaUVec3)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods.document("Computes the cross product of `self` and `rhs`.");
                methods.add_method("cross", |_, s, (a_0): (LuaUVec3)| {
                    Ok(LuaUVec3::new(s.clone().cross(a_0.clone())))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaUVec3)| {
                    Ok(LuaUVec3::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaUVec3)| {
                    Ok(LuaUVec3::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaUVec3, LuaUVec3)| {
                    Ok(LuaUVec3::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
            }
        }
        impl tealr::TypeName for LuaUVec3 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaUVec3"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaUVec3 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaUVec3 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaUVec4 = crate::LuaWrapper<UVec4>;
        impl tealr::mlu::TealData for LuaUVec4 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 4-dimensional vector.");
                methods
                    .add_meta_method(MetaMethod::Index, |_, s, idx: usize| Ok(s.clone()[idx - 1]));
                methods
                    .add_meta_method_mut(MetaMethod::NewIndex, |_, s, (idx, val): (usize, u32)| {
                        Ok(s.val_mut(|s| s[idx - 1] = val))
                    });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => Ok(UnionLuaUVec4::LuaUVec4(
                                LuaUVec4::new((ud.clone()).add(v.clone())),
                            )),
                            UnionLuaUVec4u32::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new((ud.clone()).add(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaUVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(v.add((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaUVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaUVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => Ok(UnionLuaUVec4::LuaUVec4(
                                LuaUVec4::new((ud.clone()).sub(v.clone())),
                            )),
                            UnionLuaUVec4u32::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new((ud.clone()).sub(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaUVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(v.sub((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaUVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaUVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => Ok(UnionLuaUVec4::LuaUVec4(
                                LuaUVec4::new((ud.clone()).div(v.clone())),
                            )),
                            UnionLuaUVec4u32::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaUVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(v.div((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaUVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaUVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => Ok(UnionLuaUVec4::LuaUVec4(
                                LuaUVec4::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaUVec4u32::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new((ud.clone()).mul(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaUVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(v.mul((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaUVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaUVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mod,
                    |ctx, (lhs, rhs): (Unionu32LuaUVec4, UnionLuaUVec4u32)| match (lhs, rhs) {
                        (Unionu32LuaUVec4::LuaUVec4(ud), v) => match v {
                            UnionLuaUVec4u32::LuaUVec4(v) => Ok(UnionLuaUVec4::LuaUVec4(
                                LuaUVec4::new((ud.clone()).rem(v.clone())),
                            )),
                            UnionLuaUVec4u32::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new((ud.clone()).rem(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaUVec4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaUVec4u32::LuaUVec4(ud)) => match v {
                            Unionu32LuaUVec4::u32(v) => {
                                Ok(UnionLuaUVec4::LuaUVec4(LuaUVec4::new(v.rem((ud.clone())))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mod", &"LuaUVec4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mod", &"LuaUVec4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods . document ("Creates a 2D vector from the `x`, `y` and `z` elements of `self`, discarding `w`.") ;
                methods.document("");
                methods . document ("Truncation to `UVec3` may also be performed by using `self.xyz()` or `UVec3::from()`.") ;
                methods.add_method("truncate", |_, s, (): ()| {
                    Ok(LuaUVec3::new(s.clone().truncate()))
                });
                methods.document("Computes the dot product of `self` and `rhs`.");
                methods.add_method("dot", |_, s, (a_0): (LuaUVec4)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods . document ("Returns a vector containing the minimum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.min(rhs.x), self.y.min(rhs.y), ..]`.",
                );
                methods.add_method("min", |_, s, (a_0): (LuaUVec4)| {
                    Ok(LuaUVec4::new(s.clone().min(a_0.clone())))
                });
                methods . document ("Returns a vector containing the maximum values for each element of `self` and `rhs`.") ;
                methods.document("");
                methods.document(
                    "In other words this computes `[self.x.max(rhs.x), self.y.max(rhs.y), ..]`.",
                );
                methods.add_method("max", |_, s, (a_0): (LuaUVec4)| {
                    Ok(LuaUVec4::new(s.clone().max(a_0.clone())))
                });
                methods.document("Component-wise clamping of values, similar to [`f32::clamp`].");
                methods.document("");
                methods . document ("Each element in `min` must be less-or-equal to the corresponding element in `max`.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `min` is greater than `max` when `glam_assert` is enabled.",
                );
                methods.add_method("clamp", |_, s, (a_0, a_1): (LuaUVec4, LuaUVec4)| {
                    Ok(LuaUVec4::new(s.clone().clamp(a_0.clone(), a_1.clone())))
                });
                methods.document("Returns the horizontal minimum of `self`.");
                methods.document("");
                methods.document("In other words this computes `min(x, y, ..)`.");
                methods.add_method("min_element", |_, s, (): ()| Ok(s.clone().min_element()));
                methods.document("Returns the horizontal maximum of `self`.");
                methods.document("");
                methods.document("In other words this computes `max(x, y, ..)`.");
                methods.add_method("max_element", |_, s, (): ()| Ok(s.clone().max_element()));
            }
        }
        impl tealr::TypeName for LuaUVec4 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaUVec4"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaUVec4 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaUVec4 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaMat3 = crate::LuaWrapper<Mat3>;
        impl tealr::mlu::TealData for LuaMat3 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 3x3 column major matrix.");
                methods.document_type("");
                methods . document_type ("This 3x3 matrix type features convenience methods for creating and using linear and") ;
                methods . document_type ("affine transformations. If you are primarily dealing with 2D affine transformations the") ;
                methods.document_type(
                    "[`Affine2`](crate::Affine2) type is much faster and more space efficient than",
                );
                methods.document_type("using a 3x3 matrix.");
                methods.document_type("");
                methods . document_type ("Linear transformations including 3D rotation and scale can be created using methods") ;
                methods . document_type ("such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],") ;
                methods
                    .document_type("[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or");
                methods.document_type("[`Self::from_rotation_z()`].");
                methods.document_type("");
                methods . document_type ("The resulting matrices can be use to transform 3D vectors using regular vector") ;
                methods.document_type("multiplication.");
                methods.document_type("");
                methods . document_type ("Affine transformations including 2D translation, rotation and scale can be created") ;
                methods.document_type(
                    "using methods such as [`Self::from_translation()`], [`Self::from_angle()`],",
                );
                methods.document_type(
                    "[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].",
                );
                methods.document_type("");
                methods . document_type ("The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods") ;
                methods . document_type ("are provided for performing affine transforms on 2D vectors and points. These multiply") ;
                methods . document_type ("2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for") ;
                methods . document_type ("vectors respectively. These methods assume that `Self` contains a valid affine") ;
                methods.document_type("transform.");
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaMat3::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (UnionLuaMat3, UnionLuaMat3)| match (lhs, rhs) {
                        (UnionLuaMat3::LuaMat3(ud), v) => match v {
                            UnionLuaMat3::LuaMat3(v) => Ok(UnionLuaMat3::LuaMat3(LuaMat3::new(
                                (ud.clone()).add(v.clone()),
                            ))),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaMat3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaMat3::LuaMat3(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaMat3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaMat3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (UnionLuaMat3, UnionLuaMat3)| match (lhs, rhs) {
                        (UnionLuaMat3::LuaMat3(ud), v) => match v {
                            UnionLuaMat3::LuaMat3(v) => Ok(UnionLuaMat3::LuaMat3(LuaMat3::new(
                                (ud.clone()).sub(v.clone()),
                            ))),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaMat3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaMat3::LuaMat3(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaMat3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaMat3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf32LuaMat3, UnionLuaMat3LuaVec3f32)| match (lhs, rhs) {
                        (Unionf32LuaMat3::LuaMat3(ud), v) => match v {
                            UnionLuaMat3LuaVec3f32::LuaMat3(v) => Ok(UnionLuaMat3LuaVec3::LuaMat3(
                                LuaMat3::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaMat3LuaVec3f32::LuaVec3(v) => Ok(UnionLuaMat3LuaVec3::LuaVec3(
                                LuaVec3::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaMat3LuaVec3f32::f32(v) => Ok(UnionLuaMat3LuaVec3::LuaMat3(
                                LuaMat3::new((ud.clone()).mul(v)),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaMat3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaMat3LuaVec3f32::LuaMat3(ud)) => match v {
                            Unionf32LuaMat3::f32(v) => Ok(UnionLuaMat3LuaVec3::LuaMat3(
                                LuaMat3::new(v.mul((ud.clone()))),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaMat3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaMat3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Returns the matrix column for the given `index`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document("Panics if `index` is greater than 2.");
                methods.add_method("col", |_, s, (a_0): (usize)| {
                    Ok(LuaVec3::new(s.val(|s| s.col(a_0))))
                });
                methods.document("Returns the matrix row for the given `index`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document("Panics if `index` is greater than 2.");
                methods.add_method("row", |_, s, (a_0): (usize)| {
                    Ok(LuaVec3::new(s.val(|s| s.row(a_0))))
                });
                methods.document("Returns `true` if, and only if, all elements are finite.");
                methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.val(|s| s.is_finite())));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.val(|s| s.is_nan())));
                methods.document("Returns the transpose of `self`.");
                methods.add_method("transpose", |_, s, (): ()| {
                    Ok(LuaMat3::new(s.val(|s| s.transpose())))
                });
                methods.document("Returns the determinant of `self`.");
                methods.add_method("determinant", |_, s, (): ()| Ok(s.val(|s| s.determinant())));
                methods.document("Returns the inverse of `self`.");
                methods.document("");
                methods.document(
                    "If the matrix is not invertible the returned matrix will be invalid.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if the determinant of `self` is zero when `glam_assert` is enabled.") ;
                methods.add_method("inverse", |_, s, (): ()| {
                    Ok(LuaMat3::new(s.val(|s| s.inverse())))
                });
                methods.document("Transforms the given 2D vector as a point.");
                methods.document("");
                methods.document(
                    "This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.",
                );
                methods.document("");
                methods
                    .document("This method assumes that `self` contains a valid affine transform.");
                methods.add_method("transform_point2", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.val(|s| s.transform_point2(a_0.clone()))))
                });
                methods.document("Rotates the given 2D vector.");
                methods.document("");
                methods.document(
                    "This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.",
                );
                methods.document("");
                methods
                    .document("This method assumes that `self` contains a valid affine transform.");
                methods.add_method("transform_vector2", |_, s, (a_0): (LuaVec2)| {
                    Ok(LuaVec2::new(s.val(|s| s.transform_vector2(a_0.clone()))))
                });
                methods.document("Transforms a 3D vector.");
                methods.add_method("mul_vec3", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.val(|s| s.mul_vec3(a_0.clone()))))
                });
                methods.document("Multiplies two 3x3 matrices.");
                methods.add_method("mul_mat3", |_, s, (a_0): (LuaMat3)| {
                    Ok(a_0.val(|a_0| LuaMat3::new(s.val(|s| s.mul_mat3(a_0)))))
                });
                methods.document("Adds two 3x3 matrices.");
                methods.add_method("add_mat3", |_, s, (a_0): (LuaMat3)| {
                    Ok(a_0.val(|a_0| LuaMat3::new(s.val(|s| s.add_mat3(a_0)))))
                });
                methods.document("Subtracts two 3x3 matrices.");
                methods.add_method("sub_mat3", |_, s, (a_0): (LuaMat3)| {
                    Ok(a_0.val(|a_0| LuaMat3::new(s.val(|s| s.sub_mat3(a_0)))))
                });
                methods.document("Multiplies a 3x3 matrix by a scalar.");
                methods.add_method("mul_scalar", |_, s, (a_0): (f32)| {
                    Ok(LuaMat3::new(s.val(|s| s.mul_scalar(a_0))))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs`") ;
                methods.document("is less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two matrices contain similar elements. It works best") ;
                methods . document ("when comparing with a known value. The `max_abs_diff` that should be used used") ;
                methods.document("depends on the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaMat3, f32)| {
                    Ok(s.val(|s| s.abs_diff_eq(a_0.clone(), a_1)))
                });
                methods.add_method("as_dmat3", |_, s, (): ()| {
                    Ok(LuaDMat3::new(s.val(|s| s.as_dmat3())))
                });
                methods.add_meta_method_mut(MetaMethod::Index, |_, s, idx: usize| match s {
                    LuaMat3::Owned(ref mut v, ref valid) => Ok(LuaVec3::Ref(LuaRef {
                        root: LuaRefBase::LuaOwned {
                            valid: Arc::downgrade((valid)),
                        },
                        r: ReflectPtr::Mut(v.col_mut(idx - 1)),
                        path: None,
                    })),
                    LuaMat3::Ref(ref mut r) => r.get_mut(|s, r| {
                        Ok(LuaVec3::Ref(LuaRef {
                            root: r.root.clone(),
                            r: ReflectPtr::Mut(s.downcast_mut::<Mat3>().unwrap().col_mut(idx - 1)),
                            path: None,
                        }))
                    }),
                });
            }
        }
        impl tealr::TypeName for LuaMat3 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaMat3"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaMat3 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaMat3 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaMat4 = crate::LuaWrapper<Mat4>;
        impl tealr::mlu::TealData for LuaMat4 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 4x4 column major matrix.");
                methods.document_type("");
                methods . document_type ("This 4x4 matrix type features convenience methods for creating and using affine transforms and") ;
                methods . document_type ("perspective projections. If you are primarily dealing with 3D affine transformations") ;
                methods . document_type ("considering using [`Affine3A`](crate::Affine3A) which is faster than a 4x4 matrix") ;
                methods.document_type("for some affine operations.");
                methods.document_type("");
                methods . document_type ("Affine transformations including 3D translation, rotation and scale can be created") ;
                methods.document_type(
                    "using methods such as [`Self::from_translation()`], [`Self::from_quat()`],",
                );
                methods.document_type(
                    "[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].",
                );
                methods.document_type("");
                methods . document_type ("Othographic projections can be created using the methods [`Self::orthographic_lh()`] for") ;
                methods . document_type ("left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed") ;
                methods.document_type(
                    "systems. The resulting matrix is also an affine transformation.",
                );
                methods.document_type("");
                methods . document_type ("The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods") ;
                methods . document_type ("are provided for performing affine transformations on 3D vectors and points. These") ;
                methods . document_type ("multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`") ;
                methods . document_type ("for vectors respectively. These methods assume that `Self` contains a valid affine") ;
                methods.document_type("transform.");
                methods.document_type("");
                methods
                    .document_type("Perspective projections can be created using methods such as");
                methods.document_type(
                    "[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and",
                );
                methods . document_type ("[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and") ;
                methods.document_type(
                    "[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and",
                );
                methods . document_type ("[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.") ;
                methods.document_type("");
                methods . document_type ("The resulting perspective project can be use to transform 3D vectors as points with") ;
                methods . document_type ("perspective correction using the [`Self::project_point3()`] convenience method.") ;
                methods.add_meta_method_mut(MetaMethod::Index, |_, s, idx: usize| match s {
                    LuaMat4::Owned(ref mut v, ref valid) => Ok(LuaVec4::Ref(LuaRef {
                        root: LuaRefBase::LuaOwned {
                            valid: Arc::downgrade((valid)),
                        },
                        r: ReflectPtr::Mut(v.col_mut(idx - 1)),
                        path: None,
                    })),
                    LuaMat4::Ref(ref mut r) => r.get_mut(|s, r| {
                        Ok(LuaVec4::Ref(LuaRef {
                            root: r.root.clone(),
                            r: ReflectPtr::Mut(s.downcast_mut::<Mat4>().unwrap().col_mut(idx - 1)),
                            path: None,
                        }))
                    }),
                });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaMat4::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (UnionLuaMat4, UnionLuaMat4)| match (lhs, rhs) {
                        (UnionLuaMat4::LuaMat4(ud), v) => match v {
                            UnionLuaMat4::LuaMat4(v) => Ok(UnionLuaMat4::LuaMat4(LuaMat4::new(
                                (ud.clone()).add(v.clone()),
                            ))),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaMat4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaMat4::LuaMat4(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaMat4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaMat4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (UnionLuaMat4, UnionLuaMat4)| match (lhs, rhs) {
                        (UnionLuaMat4::LuaMat4(ud), v) => match v {
                            UnionLuaMat4::LuaMat4(v) => Ok(UnionLuaMat4::LuaMat4(LuaMat4::new(
                                (ud.clone()).sub(v.clone()),
                            ))),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaMat4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaMat4::LuaMat4(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaMat4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaMat4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf32LuaMat4, UnionLuaMat4LuaVec4f32)| match (lhs, rhs) {
                        (Unionf32LuaMat4::LuaMat4(ud), v) => match v {
                            UnionLuaMat4LuaVec4f32::LuaMat4(v) => Ok(UnionLuaMat4LuaVec4::LuaMat4(
                                LuaMat4::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaMat4LuaVec4f32::LuaVec4(v) => Ok(UnionLuaMat4LuaVec4::LuaVec4(
                                LuaVec4::new((ud.clone()).mul(v.clone())),
                            )),
                            UnionLuaMat4LuaVec4f32::f32(v) => Ok(UnionLuaMat4LuaVec4::LuaMat4(
                                LuaMat4::new((ud.clone()).mul(v)),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaMat4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaMat4LuaVec4f32::LuaMat4(ud)) => match v {
                            Unionf32LuaMat4::f32(v) => Ok(UnionLuaMat4LuaVec4::LuaMat4(
                                LuaMat4::new(v.mul((ud.clone()))),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaMat4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaMat4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Returns the matrix column for the given `index`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document("Panics if `index` is greater than 3.");
                methods.add_method("col", |_, s, (a_0): (usize)| {
                    Ok(LuaVec4::new(s.val(|s| s.col(a_0))))
                });
                methods.document("Returns the matrix row for the given `index`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document("Panics if `index` is greater than 3.");
                methods.add_method("row", |_, s, (a_0): (usize)| {
                    Ok(LuaVec4::new(s.val(|s| s.row(a_0))))
                });
                methods.document("Returns `true` if, and only if, all elements are finite.");
                methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.val(|s| s.is_finite())));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.val(|s| s.is_nan())));
                methods.document("Returns the transpose of `self`.");
                methods.add_method("transpose", |_, s, (): ()| {
                    Ok(LuaMat4::new(s.val(|s| s.transpose())))
                });
                methods.document("Returns the determinant of `self`.");
                methods.add_method("determinant", |_, s, (): ()| Ok(s.val(|s| s.determinant())));
                methods.document("Returns the inverse of `self`.");
                methods.document("");
                methods.document(
                    "If the matrix is not invertible the returned matrix will be invalid.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if the determinant of `self` is zero when `glam_assert` is enabled.") ;
                methods.add_method("inverse", |_, s, (): ()| {
                    Ok(LuaMat4::new(s.val(|s| s.inverse())))
                });
                methods.document(
                    "Transforms the given 3D vector as a point, applying perspective correction.",
                );
                methods.document("");
                methods . document ("This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.") ;
                methods . document ("The perspective divide is performed meaning the resulting 3D vector is divided by `w`.") ;
                methods.document("");
                methods
                    .document("This method assumes that `self` contains a projective transform.");
                methods.add_method("project_point3", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.val(|s| s.project_point3(a_0.clone()))))
                });
                methods.document("Transforms the given 3D vector as a point.");
                methods.document("");
                methods . document ("This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is") ;
                methods.document("`1.0`.");
                methods.document("");
                methods . document ("This method assumes that `self` contains a valid affine transform. It does not perform") ;
                methods . document ("a persective divide, if `self` contains a perspective transform, or if you are unsure,") ;
                methods.document("the [`Self::project_point3()`] method should be used instead.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.") ;
                methods.add_method("transform_point3", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.val(|s| s.transform_point3(a_0.clone()))))
                });
                methods.document("Transforms the give 3D vector as a direction.");
                methods.document("");
                methods . document ("This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is") ;
                methods.document("`0.0`.");
                methods.document("");
                methods
                    .document("This method assumes that `self` contains a valid affine transform.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.") ;
                methods.add_method("transform_vector3", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.val(|s| s.transform_vector3(a_0.clone()))))
                });
                methods.document("Transforms a 4D vector.");
                methods.add_method("mul_vec4", |_, s, (a_0): (LuaVec4)| {
                    Ok(LuaVec4::new(s.val(|s| s.mul_vec4(a_0.clone()))))
                });
                methods.document("Multiplies two 4x4 matrices.");
                methods.add_method("mul_mat4", |_, s, (a_0): (LuaMat4)| {
                    Ok(a_0.val(|a_0| LuaMat4::new(s.val(|s| s.mul_mat4(a_0)))))
                });
                methods.document("Adds two 4x4 matrices.");
                methods.add_method("add_mat4", |_, s, (a_0): (LuaMat4)| {
                    Ok(a_0.val(|a_0| LuaMat4::new(s.val(|s| s.add_mat4(a_0)))))
                });
                methods.document("Subtracts two 4x4 matrices.");
                methods.add_method("sub_mat4", |_, s, (a_0): (LuaMat4)| {
                    Ok(a_0.val(|a_0| LuaMat4::new(s.val(|s| s.sub_mat4(a_0)))))
                });
                methods.document("Multiplies a 4x4 matrix by a scalar.");
                methods.add_method("mul_scalar", |_, s, (a_0): (f32)| {
                    Ok(LuaMat4::new(s.val(|s| s.mul_scalar(a_0))))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs`") ;
                methods.document("is less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two matrices contain similar elements. It works best") ;
                methods . document ("when comparing with a known value. The `max_abs_diff` that should be used used") ;
                methods.document("depends on the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaMat4, f32)| {
                    Ok(s.val(|s| s.abs_diff_eq(a_0.clone(), a_1)))
                });
                methods.add_method("as_dmat4", |_, s, (): ()| {
                    Ok(LuaDMat4::new(s.val(|s| s.as_dmat4())))
                });
            }
        }
        impl tealr::TypeName for LuaMat4 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaMat4"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaMat4 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaMat4 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaDMat3 = crate::LuaWrapper<DMat3>;
        impl tealr::mlu::TealData for LuaDMat3 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 3x3 column major matrix.");
                methods.document_type("");
                methods . document_type ("This 3x3 matrix type features convenience methods for creating and using linear and") ;
                methods . document_type ("affine transformations. If you are primarily dealing with 2D affine transformations the") ;
                methods . document_type ("[`DAffine2`](crate::DAffine2) type is much faster and more space efficient than") ;
                methods.document_type("using a 3x3 matrix.");
                methods.document_type("");
                methods . document_type ("Linear transformations including 3D rotation and scale can be created using methods") ;
                methods . document_type ("such as [`Self::from_diagonal()`], [`Self::from_quat()`], [`Self::from_axis_angle()`],") ;
                methods
                    .document_type("[`Self::from_rotation_x()`], [`Self::from_rotation_y()`], or");
                methods.document_type("[`Self::from_rotation_z()`].");
                methods.document_type("");
                methods . document_type ("The resulting matrices can be use to transform 3D vectors using regular vector") ;
                methods.document_type("multiplication.");
                methods.document_type("");
                methods . document_type ("Affine transformations including 2D translation, rotation and scale can be created") ;
                methods.document_type(
                    "using methods such as [`Self::from_translation()`], [`Self::from_angle()`],",
                );
                methods.document_type(
                    "[`Self::from_scale()`] and [`Self::from_scale_angle_translation()`].",
                );
                methods.document_type("");
                methods . document_type ("The [`Self::transform_point2()`] and [`Self::transform_vector2()`] convenience methods") ;
                methods . document_type ("are provided for performing affine transforms on 2D vectors and points. These multiply") ;
                methods . document_type ("2D inputs as 3D vectors with an implicit `z` value of `1` for points and `0` for") ;
                methods . document_type ("vectors respectively. These methods assume that `Self` contains a valid affine") ;
                methods.document_type("transform.");
                methods.add_meta_method_mut(MetaMethod::Index, |_, s, idx: usize| match s {
                    LuaDMat3::Owned(ref mut v, ref valid) => Ok(LuaDVec3::Ref(LuaRef {
                        root: LuaRefBase::LuaOwned {
                            valid: Arc::downgrade((valid)),
                        },
                        r: ReflectPtr::Mut(v.col_mut(idx - 1)),
                        path: None,
                    })),
                    LuaDMat3::Ref(ref mut r) => r.get_mut(|s, r| {
                        Ok(LuaDVec3::Ref(LuaRef {
                            root: r.root.clone(),
                            r: ReflectPtr::Mut(s.downcast_mut::<DMat3>().unwrap().col_mut(idx - 1)),
                            path: None,
                        }))
                    }),
                });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaDMat3::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (UnionLuaDMat3, UnionLuaDMat3)| match (lhs, rhs) {
                        (UnionLuaDMat3::LuaDMat3(ud), v) => match v {
                            UnionLuaDMat3::LuaDMat3(v) => Ok(UnionLuaDMat3::LuaDMat3(
                                LuaDMat3::new((ud.clone()).add(v.clone())),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDMat3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDMat3::LuaDMat3(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDMat3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaDMat3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (UnionLuaDMat3, UnionLuaDMat3)| match (lhs, rhs) {
                        (UnionLuaDMat3::LuaDMat3(ud), v) => match v {
                            UnionLuaDMat3::LuaDMat3(v) => Ok(UnionLuaDMat3::LuaDMat3(
                                LuaDMat3::new((ud.clone()).sub(v.clone())),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDMat3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDMat3::LuaDMat3(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDMat3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaDMat3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf64LuaDMat3, UnionLuaDMat3LuaDVec3f64)| match (lhs, rhs)
                    {
                        (Unionf64LuaDMat3::LuaDMat3(ud), v) => match v {
                            UnionLuaDMat3LuaDVec3f64::LuaDMat3(v) => {
                                Ok(UnionLuaDMat3LuaDVec3::LuaDMat3(LuaDMat3::new(
                                    (ud.clone()).mul(v.clone()),
                                )))
                            }
                            UnionLuaDMat3LuaDVec3f64::LuaDVec3(v) => {
                                Ok(UnionLuaDMat3LuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.clone()).mul(v.clone()),
                                )))
                            }
                            UnionLuaDMat3LuaDVec3f64::f64(v) => Ok(
                                UnionLuaDMat3LuaDVec3::LuaDMat3(LuaDMat3::new((ud.clone()).mul(v))),
                            ),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDMat3", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDMat3LuaDVec3f64::LuaDMat3(ud)) => match v {
                            Unionf64LuaDMat3::f64(v) => Ok(UnionLuaDMat3LuaDVec3::LuaDMat3(
                                LuaDMat3::new(v.mul((ud.clone()))),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDMat3", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaDMat3") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Returns the matrix column for the given `index`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document("Panics if `index` is greater than 2.");
                methods.add_method("col", |_, s, (a_0): (usize)| {
                    Ok(LuaDVec3::new(s.val(|s| s.col(a_0))))
                });
                methods.document("Returns the matrix row for the given `index`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document("Panics if `index` is greater than 2.");
                methods.add_method("row", |_, s, (a_0): (usize)| {
                    Ok(LuaDVec3::new(s.val(|s| s.row(a_0))))
                });
                methods.document("Returns `true` if, and only if, all elements are finite.");
                methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.val(|s| s.is_finite())));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.val(|s| s.is_nan())));
                methods.document("Returns the transpose of `self`.");
                methods.add_method("transpose", |_, s, (): ()| {
                    Ok(LuaDMat3::new(s.val(|s| s.transpose())))
                });
                methods.document("Returns the determinant of `self`.");
                methods.add_method("determinant", |_, s, (): ()| Ok(s.val(|s| s.determinant())));
                methods.document("Returns the inverse of `self`.");
                methods.document("");
                methods.document(
                    "If the matrix is not invertible the returned matrix will be invalid.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if the determinant of `self` is zero when `glam_assert` is enabled.") ;
                methods.add_method("inverse", |_, s, (): ()| {
                    Ok(LuaDMat3::new(s.val(|s| s.inverse())))
                });
                methods.document("Transforms the given 2D vector as a point.");
                methods.document("");
                methods.document(
                    "This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `1`.",
                );
                methods.document("");
                methods
                    .document("This method assumes that `self` contains a valid affine transform.");
                methods.add_method("transform_point2", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(s.val(|s| s.transform_point2(a_0.clone()))))
                });
                methods.document("Rotates the given 2D vector.");
                methods.document("");
                methods.document(
                    "This is the equivalent of multiplying `rhs` as a 3D vector where `z` is `0`.",
                );
                methods.document("");
                methods
                    .document("This method assumes that `self` contains a valid affine transform.");
                methods.add_method("transform_vector2", |_, s, (a_0): (LuaDVec2)| {
                    Ok(LuaDVec2::new(s.val(|s| s.transform_vector2(a_0.clone()))))
                });
                methods.document("Transforms a 3D vector.");
                methods.add_method("mul_vec3", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.val(|s| s.mul_vec3(a_0.clone()))))
                });
                methods.document("Multiplies two 3x3 matrices.");
                methods.add_method("mul_mat3", |_, s, (a_0): (LuaDMat3)| {
                    Ok(a_0.val(|a_0| LuaDMat3::new(s.val(|s| s.mul_mat3(a_0)))))
                });
                methods.document("Adds two 3x3 matrices.");
                methods.add_method("add_mat3", |_, s, (a_0): (LuaDMat3)| {
                    Ok(a_0.val(|a_0| LuaDMat3::new(s.val(|s| s.add_mat3(a_0)))))
                });
                methods.document("Subtracts two 3x3 matrices.");
                methods.add_method("sub_mat3", |_, s, (a_0): (LuaDMat3)| {
                    Ok(a_0.val(|a_0| LuaDMat3::new(s.val(|s| s.sub_mat3(a_0)))))
                });
                methods.document("Multiplies a 3x3 matrix by a scalar.");
                methods.add_method("mul_scalar", |_, s, (a_0): (f64)| {
                    Ok(LuaDMat3::new(s.val(|s| s.mul_scalar(a_0))))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs`") ;
                methods.document("is less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two matrices contain similar elements. It works best") ;
                methods . document ("when comparing with a known value. The `max_abs_diff` that should be used used") ;
                methods.document("depends on the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaDMat3, f64)| {
                    Ok(s.val(|s| s.abs_diff_eq(a_0.clone(), a_1)))
                });
                methods.add_method("as_mat3", |_, s, (): ()| {
                    Ok(LuaMat3::new(s.val(|s| s.as_mat3())))
                });
            }
        }
        impl tealr::TypeName for LuaDMat3 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDMat3"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDMat3 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDMat3 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaDMat4 = crate::LuaWrapper<DMat4>;
        impl tealr::mlu::TealData for LuaDMat4 {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A 4x4 column major matrix.");
                methods.document_type("");
                methods . document_type ("This 4x4 matrix type features convenience methods for creating and using affine transforms and") ;
                methods . document_type ("perspective projections. If you are primarily dealing with 3D affine transformations") ;
                methods . document_type ("considering using [`DAffine3`](crate::DAffine3) which is faster than a 4x4 matrix") ;
                methods.document_type("for some affine operations.");
                methods.document_type("");
                methods . document_type ("Affine transformations including 3D translation, rotation and scale can be created") ;
                methods.document_type(
                    "using methods such as [`Self::from_translation()`], [`Self::from_quat()`],",
                );
                methods.document_type(
                    "[`Self::from_scale()`] and [`Self::from_scale_rotation_translation()`].",
                );
                methods.document_type("");
                methods . document_type ("Othographic projections can be created using the methods [`Self::orthographic_lh()`] for") ;
                methods . document_type ("left-handed coordinate systems and [`Self::orthographic_rh()`] for right-handed") ;
                methods.document_type(
                    "systems. The resulting matrix is also an affine transformation.",
                );
                methods.document_type("");
                methods . document_type ("The [`Self::transform_point3()`] and [`Self::transform_vector3()`] convenience methods") ;
                methods . document_type ("are provided for performing affine transformations on 3D vectors and points. These") ;
                methods . document_type ("multiply 3D inputs as 4D vectors with an implicit `w` value of `1` for points and `0`") ;
                methods . document_type ("for vectors respectively. These methods assume that `Self` contains a valid affine") ;
                methods.document_type("transform.");
                methods.document_type("");
                methods
                    .document_type("Perspective projections can be created using methods such as");
                methods.document_type(
                    "[`Self::perspective_lh()`], [`Self::perspective_infinite_lh()`] and",
                );
                methods . document_type ("[`Self::perspective_infinite_reverse_lh()`] for left-handed co-ordinate systems and") ;
                methods.document_type(
                    "[`Self::perspective_rh()`], [`Self::perspective_infinite_rh()`] and",
                );
                methods . document_type ("[`Self::perspective_infinite_reverse_rh()`] for right-handed co-ordinate systems.") ;
                methods.document_type("");
                methods . document_type ("The resulting perspective project can be use to transform 3D vectors as points with") ;
                methods . document_type ("perspective correction using the [`Self::project_point3()`] convenience method.") ;
                methods.add_meta_method_mut(MetaMethod::Index, |_, s, idx: usize| match s {
                    LuaDMat4::Owned(ref mut v, ref valid) => Ok(LuaDVec4::Ref(LuaRef {
                        root: LuaRefBase::LuaOwned {
                            valid: Arc::downgrade((valid)),
                        },
                        r: ReflectPtr::Mut(v.col_mut(idx - 1)),
                        path: None,
                    })),
                    LuaDMat4::Ref(ref mut r) => r.get_mut(|s, r| {
                        Ok(LuaDVec4::Ref(LuaRef {
                            root: r.root.clone(),
                            r: ReflectPtr::Mut(s.downcast_mut::<DMat4>().unwrap().col_mut(idx - 1)),
                            path: None,
                        }))
                    }),
                });
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaDMat4::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (UnionLuaDMat4, UnionLuaDMat4)| match (lhs, rhs) {
                        (UnionLuaDMat4::LuaDMat4(ud), v) => match v {
                            UnionLuaDMat4::LuaDMat4(v) => Ok(UnionLuaDMat4::LuaDMat4(
                                LuaDMat4::new((ud.clone()).add(v.clone())),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDMat4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDMat4::LuaDMat4(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDMat4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaDMat4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (UnionLuaDMat4, UnionLuaDMat4)| match (lhs, rhs) {
                        (UnionLuaDMat4::LuaDMat4(ud), v) => match v {
                            UnionLuaDMat4::LuaDMat4(v) => Ok(UnionLuaDMat4::LuaDMat4(
                                LuaDMat4::new((ud.clone()).sub(v.clone())),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDMat4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDMat4::LuaDMat4(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDMat4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaDMat4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (Unionf64LuaDMat4, UnionLuaDMat4LuaDVec4f64)| match (lhs, rhs)
                    {
                        (Unionf64LuaDMat4::LuaDMat4(ud), v) => match v {
                            UnionLuaDMat4LuaDVec4f64::LuaDMat4(v) => {
                                Ok(UnionLuaDMat4LuaDVec4::LuaDMat4(LuaDMat4::new(
                                    (ud.clone()).mul(v.clone()),
                                )))
                            }
                            UnionLuaDMat4LuaDVec4f64::LuaDVec4(v) => {
                                Ok(UnionLuaDMat4LuaDVec4::LuaDVec4(LuaDVec4::new(
                                    (ud.clone()).mul(v.clone()),
                                )))
                            }
                            UnionLuaDMat4LuaDVec4f64::f64(v) => Ok(
                                UnionLuaDMat4LuaDVec4::LuaDMat4(LuaDMat4::new((ud.clone()).mul(v))),
                            ),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDMat4", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDMat4LuaDVec4f64::LuaDMat4(ud)) => match v {
                            Unionf64LuaDMat4::f64(v) => Ok(UnionLuaDMat4LuaDVec4::LuaDMat4(
                                LuaDMat4::new(v.mul((ud.clone()))),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDMat4", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaDMat4") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Returns the matrix column for the given `index`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document("Panics if `index` is greater than 3.");
                methods.add_method("col", |_, s, (a_0): (usize)| {
                    Ok(LuaDVec4::new(s.val(|s| s.col(a_0))))
                });
                methods.document("Returns the matrix row for the given `index`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document("Panics if `index` is greater than 3.");
                methods.add_method("row", |_, s, (a_0): (usize)| {
                    Ok(LuaDVec4::new(s.val(|s| s.row(a_0))))
                });
                methods.document("Returns `true` if, and only if, all elements are finite.");
                methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.val(|s| s.is_finite())));
                methods.document("Returns `true` if any elements are `NaN`.");
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.val(|s| s.is_nan())));
                methods.document("Returns the transpose of `self`.");
                methods.add_method("transpose", |_, s, (): ()| {
                    Ok(LuaDMat4::new(s.val(|s| s.transpose())))
                });
                methods.document("Returns the determinant of `self`.");
                methods.add_method("determinant", |_, s, (): ()| Ok(s.val(|s| s.determinant())));
                methods.document("Returns the inverse of `self`.");
                methods.document("");
                methods.document(
                    "If the matrix is not invertible the returned matrix will be invalid.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if the determinant of `self` is zero when `glam_assert` is enabled.") ;
                methods.add_method("inverse", |_, s, (): ()| {
                    Ok(LuaDMat4::new(s.val(|s| s.inverse())))
                });
                methods.document(
                    "Transforms the given 3D vector as a point, applying perspective correction.",
                );
                methods.document("");
                methods . document ("This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is `1.0`.") ;
                methods . document ("The perspective divide is performed meaning the resulting 3D vector is divided by `w`.") ;
                methods.document("");
                methods
                    .document("This method assumes that `self` contains a projective transform.");
                methods.add_method("project_point3", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.val(|s| s.project_point3(a_0.clone()))))
                });
                methods.document("Transforms the given 3D vector as a point.");
                methods.document("");
                methods . document ("This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is") ;
                methods.document("`1.0`.");
                methods.document("");
                methods . document ("This method assumes that `self` contains a valid affine transform. It does not perform") ;
                methods . document ("a persective divide, if `self` contains a perspective transform, or if you are unsure,") ;
                methods.document("the [`Self::project_point3()`] method should be used instead.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.") ;
                methods.add_method("transform_point3", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.val(|s| s.transform_point3(a_0.clone()))))
                });
                methods.document("Transforms the give 3D vector as a direction.");
                methods.document("");
                methods . document ("This is the equivalent of multiplying the 3D vector as a 4D vector where `w` is") ;
                methods.document("`0.0`.");
                methods.document("");
                methods
                    .document("This method assumes that `self` contains a valid affine transform.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if the 3rd row of `self` is not `(0, 0, 0, 1)` when `glam_assert` is enabled.") ;
                methods.add_method("transform_vector3", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.val(|s| s.transform_vector3(a_0.clone()))))
                });
                methods.document("Transforms a 4D vector.");
                methods.add_method("mul_vec4", |_, s, (a_0): (LuaDVec4)| {
                    Ok(LuaDVec4::new(s.val(|s| s.mul_vec4(a_0.clone()))))
                });
                methods.document("Multiplies two 4x4 matrices.");
                methods.add_method("mul_mat4", |_, s, (a_0): (LuaDMat4)| {
                    Ok(a_0.val(|a_0| LuaDMat4::new(s.val(|s| s.mul_mat4(a_0)))))
                });
                methods.document("Adds two 4x4 matrices.");
                methods.add_method("add_mat4", |_, s, (a_0): (LuaDMat4)| {
                    Ok(a_0.val(|a_0| LuaDMat4::new(s.val(|s| s.add_mat4(a_0)))))
                });
                methods.document("Subtracts two 4x4 matrices.");
                methods.add_method("sub_mat4", |_, s, (a_0): (LuaDMat4)| {
                    Ok(a_0.val(|a_0| LuaDMat4::new(s.val(|s| s.sub_mat4(a_0)))))
                });
                methods.document("Multiplies a 4x4 matrix by a scalar.");
                methods.add_method("mul_scalar", |_, s, (a_0): (f64)| {
                    Ok(LuaDMat4::new(s.val(|s| s.mul_scalar(a_0))))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs`") ;
                methods.document("is less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two matrices contain similar elements. It works best") ;
                methods . document ("when comparing with a known value. The `max_abs_diff` that should be used used") ;
                methods.document("depends on the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaDMat4, f64)| {
                    Ok(s.val(|s| s.abs_diff_eq(a_0.clone(), a_1)))
                });
                methods.add_method("as_mat4", |_, s, (): ()| {
                    Ok(LuaMat4::new(s.val(|s| s.as_mat4())))
                });
            }
        }
        impl tealr::TypeName for LuaDMat4 {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDMat4"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDMat4 {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDMat4 {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaQuat = crate::LuaWrapper<Quat>;
        impl tealr::mlu::TealData for LuaQuat {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A quaternion representing an orientation.");
                methods.document_type("");
                methods.document_type(
                    "This quaternion is intended to be of unit length but may denormalize due to",
                );
                methods.document_type(
                    "floating point \"error creep\" which can occur when successive quaternion",
                );
                methods.document_type("operations are applied.");
                methods.document_type("");
                methods.document_type("This type is 16 byte aligned.");
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaQuat::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (UnionLuaQuat, UnionLuaQuat)| match (lhs, rhs) {
                        (UnionLuaQuat::LuaQuat(ud), v) => match v {
                            UnionLuaQuat::LuaQuat(v) => Ok(UnionLuaQuat::LuaQuat(LuaQuat::new(
                                (ud.clone()).add(v.clone()),
                            ))),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaQuat", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaQuat::LuaQuat(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaQuat", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaQuat") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (UnionLuaQuat, UnionLuaQuat)| match (lhs, rhs) {
                        (UnionLuaQuat::LuaQuat(ud), v) => match v {
                            UnionLuaQuat::LuaQuat(v) => Ok(UnionLuaQuat::LuaQuat(LuaQuat::new(
                                (ud.clone()).sub(v.clone()),
                            ))),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaQuat", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaQuat::LuaQuat(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaQuat", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaQuat") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (UnionLuaQuat, Unionf32)| match (lhs, rhs) {
                        (UnionLuaQuat::LuaQuat(ud), v) => match v {
                            Unionf32::f32(v) => {
                                Ok(UnionLuaQuat::LuaQuat(LuaQuat::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaQuat", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaQuat") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (UnionLuaQuat, Unionf32LuaQuatLuaVec3)| match (lhs, rhs) {
                        (UnionLuaQuat::LuaQuat(ud), v) => match v {
                            Unionf32LuaQuatLuaVec3::f32(v) => Ok(UnionLuaQuatLuaVec3::LuaQuat(
                                LuaQuat::new((ud.clone()).mul(v)),
                            )),
                            Unionf32LuaQuatLuaVec3::LuaQuat(v) => Ok(UnionLuaQuatLuaVec3::LuaQuat(
                                LuaQuat::new((ud.clone()).mul(v.clone())),
                            )),
                            Unionf32LuaQuatLuaVec3::LuaVec3(v) => Ok(UnionLuaQuatLuaVec3::LuaVec3(
                                LuaVec3::new((ud.clone()).mul(v.clone())),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaQuat", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, Unionf32LuaQuatLuaVec3::LuaQuat(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaQuat", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaQuat") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Returns the rotation axis scaled by the rotation in radians.");
                methods.add_method("to_scaled_axis", |_, s, (): ()| {
                    Ok(LuaVec3::new(s.clone().to_scaled_axis()))
                });
                methods.document("Returns the vector part of the quaternion.");
                methods.add_method("xyz", |_, s, (): ()| Ok(LuaVec3::new(s.clone().xyz())));
                methods.document(
                    "Returns the quaternion conjugate of `self`. For a unit quaternion the",
                );
                methods.document("conjugate is also the inverse.");
                methods.add_method("conjugate", |_, s, (): ()| {
                    Ok(LuaQuat::new(s.clone().conjugate()))
                });
                methods.document("Returns the inverse of a normalized quaternion.");
                methods.document("");
                methods . document ("Typically quaternion inverse returns the conjugate of a normalized quaternion.") ;
                methods . document ("Because `self` is assumed to already be unit length this method *does not* normalize") ;
                methods.document("before returning the conjugate.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `self` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("inverse", |_, s, (): ()| {
                    Ok(LuaQuat::new(s.clone().inverse()))
                });
                methods
                    .document("Computes the dot product of `self` and `rhs`. The dot product is");
                methods
                    .document("equal to the cosine of the angle between two quaternion rotations.");
                methods.add_method("dot", |_, s, (a_0): (LuaQuat)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods.document("Computes the length of `self`.");
                methods.add_method("length", |_, s, (): ()| Ok(s.clone().length()));
                methods.document("Computes the squared length of `self`.");
                methods.document("");
                methods.document("This is generally faster than `length()` as it avoids a square");
                methods.document("root operation.");
                methods.add_method("length_squared", |_, s, (): ()| {
                    Ok(s.clone().length_squared())
                });
                methods.document("Computes `1.0 / length()`.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.add_method("length_recip", |_, s, (): ()| Ok(s.clone().length_recip()));
                methods.document("Returns `self` normalized to length 1.0.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.document("");
                methods.document("Panics");
                methods.document("");
                methods
                    .document("Will panic if `self` is zero length when `glam_assert` is enabled.");
                methods.add_method("normalize", |_, s, (): ()| {
                    Ok(LuaQuat::new(s.clone().normalize()))
                });
                methods.document("Returns `true` if, and only if, all elements are finite.");
                methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.clone().is_finite()));
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.clone().is_nan()));
                methods.document("Returns whether `self` of length `1.0` or not.");
                methods.document("");
                methods.document("Uses a precision threshold of `1e-6`.");
                methods.add_method("is_normalized", |_, s, (): ()| {
                    Ok(s.clone().is_normalized())
                });
                methods.add_method("is_near_identity", |_, s, (): ()| {
                    Ok(s.clone().is_near_identity())
                });
                methods.document("Returns the angle (in radians) for the minimal rotation");
                methods.document("for transforming this quaternion into another.");
                methods.document("");
                methods.document("Both quaternions must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.") ;
                methods.add_method("angle_between", |_, s, (a_0): (LuaQuat)| {
                    Ok(s.clone().angle_between(a_0.clone()))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs`") ;
                methods.document("is less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two quaternions contain similar elements. It works") ;
                methods . document ("best when comparing with a known value. The `max_abs_diff` that should be used used") ;
                methods.document("depends on the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaQuat, f32)| {
                    Ok(s.clone().abs_diff_eq(a_0.clone(), a_1))
                });
                methods
                    .document("Performs a linear interpolation between `self` and `rhs` based on");
                methods.document("the value `s`.");
                methods.document("");
                methods
                    .document("When `s` is `0.0`, the result will be equal to `self`.  When `s`");
                methods.document("is `1.0`, the result will be equal to `rhs`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.") ;
                methods.add_method("lerp", |_, s, (a_0, a_1): (LuaQuat, f32)| {
                    Ok(LuaQuat::new(s.clone().lerp(a_0.clone(), a_1)))
                });
                methods
                    .document("Performs a spherical linear interpolation between `self` and `end`");
                methods.document("based on the value `s`.");
                methods.document("");
                methods
                    .document("When `s` is `0.0`, the result will be equal to `self`.  When `s`");
                methods.document("is `1.0`, the result will be equal to `end`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.") ;
                methods.add_method("slerp", |_, s, (a_0, a_1): (LuaQuat, f32)| {
                    Ok(LuaQuat::new(s.clone().slerp(a_0.clone(), a_1)))
                });
                methods.document(
                    "Multiplies a quaternion and a 3D vector, returning the rotated vector.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `self` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("mul_vec3", |_, s, (a_0): (LuaVec3)| {
                    Ok(LuaVec3::new(s.clone().mul_vec3(a_0.clone())))
                });
                methods . document ("Multiplies two quaternions. If they each represent a rotation, the result will") ;
                methods.document("represent the combined rotation.");
                methods.document("");
                methods . document ("Note that due to floating point rounding the result may not be perfectly normalized.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.") ;
                methods.add_method("mul_quat", |_, s, (a_0): (LuaQuat)| {
                    Ok(LuaQuat::new(s.clone().mul_quat(a_0.clone())))
                });
                methods.add_method("as_f64", |_, s, (): ()| {
                    Ok(LuaDQuat::new(s.clone().as_f64()))
                });
            }
        }
        impl tealr::TypeName for LuaQuat {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaQuat"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaQuat {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaQuat {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaDQuat = crate::LuaWrapper<DQuat>;
        impl tealr::mlu::TealData for LuaDQuat {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("A quaternion representing an orientation.");
                methods.document_type("");
                methods.document_type(
                    "This quaternion is intended to be of unit length but may denormalize due to",
                );
                methods.document_type(
                    "floating point \"error creep\" which can occur when successive quaternion",
                );
                methods.document_type("operations are applied.");
                methods.add_meta_method(mlua::MetaMethod::Unm, |_, ud, ()| {
                    return Ok(LuaDQuat::new(ud.clone().neg()));
                });
                methods.add_meta_function(
                    mlua::MetaMethod::Add,
                    |ctx, (lhs, rhs): (UnionLuaDQuat, UnionLuaDQuat)| match (lhs, rhs) {
                        (UnionLuaDQuat::LuaDQuat(ud), v) => match v {
                            UnionLuaDQuat::LuaDQuat(v) => Ok(UnionLuaDQuat::LuaDQuat(
                                LuaDQuat::new((ud.clone()).add(v.clone())),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDQuat", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDQuat::LuaDQuat(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Add", &"LuaDQuat", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Add", &"LuaDQuat") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Sub,
                    |ctx, (lhs, rhs): (UnionLuaDQuat, UnionLuaDQuat)| match (lhs, rhs) {
                        (UnionLuaDQuat::LuaDQuat(ud), v) => match v {
                            UnionLuaDQuat::LuaDQuat(v) => Ok(UnionLuaDQuat::LuaDQuat(
                                LuaDQuat::new((ud.clone()).sub(v.clone())),
                            )),
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDQuat", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, UnionLuaDQuat::LuaDQuat(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Sub", &"LuaDQuat", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Sub", &"LuaDQuat") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Div,
                    |ctx, (lhs, rhs): (UnionLuaDQuat, Unionf64)| match (lhs, rhs) {
                        (UnionLuaDQuat::LuaDQuat(ud), v) => match v {
                            Unionf64::f64(v) => {
                                Ok(UnionLuaDQuat::LuaDQuat(LuaDQuat::new((ud.clone()).div(v))))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Div", &"LuaDQuat", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Div", &"LuaDQuat") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.add_meta_function(
                    mlua::MetaMethod::Mul,
                    |ctx, (lhs, rhs): (UnionLuaDQuat, Unionf64LuaDQuatLuaDVec3)| match (lhs, rhs) {
                        (UnionLuaDQuat::LuaDQuat(ud), v) => match v {
                            Unionf64LuaDQuatLuaDVec3::f64(v) => Ok(
                                UnionLuaDQuatLuaDVec3::LuaDQuat(LuaDQuat::new((ud.clone()).mul(v))),
                            ),
                            Unionf64LuaDQuatLuaDVec3::LuaDQuat(v) => {
                                Ok(UnionLuaDQuatLuaDVec3::LuaDQuat(LuaDQuat::new(
                                    (ud.clone()).mul(v.clone()),
                                )))
                            }
                            Unionf64LuaDQuatLuaDVec3::LuaDVec3(v) => {
                                Ok(UnionLuaDQuatLuaDVec3::LuaDVec3(LuaDVec3::new(
                                    (ud.clone()).mul(v.clone()),
                                )))
                            }
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDQuat", &"right") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        (v, Unionf64LuaDQuatLuaDVec3::LuaDQuat(ud)) => match v {
                            _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[
                                        "tried to `",
                                        "` `",
                                        "` with another argument on the `",
                                        "` side, but its type is not supported",
                                    ],
                                    &match (&"Mul", &"LuaDQuat", &"left") {
                                        args => [
                                            ::core::fmt::ArgumentV1::new_display(args.0),
                                            ::core::fmt::ArgumentV1::new_display(args.1),
                                            ::core::fmt::ArgumentV1::new_display(args.2),
                                        ],
                                    },
                                ));
                                res
                            })),
                        },
                        _ => Err(tealr::mlu::mlua::Error::RuntimeError({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "tried to `",
                                    "` two arguments, none of which are of type `",
                                    "` ",
                                ],
                                &match (&"Mul", &"LuaDQuat") {
                                    args => [
                                        ::core::fmt::ArgumentV1::new_display(args.0),
                                        ::core::fmt::ArgumentV1::new_display(args.1),
                                    ],
                                },
                            ));
                            res
                        })),
                    },
                );
                methods.document("Returns the rotation axis scaled by the rotation in radians.");
                methods.add_method("to_scaled_axis", |_, s, (): ()| {
                    Ok(LuaDVec3::new(s.clone().to_scaled_axis()))
                });
                methods.document("Returns the vector part of the quaternion.");
                methods.add_method("xyz", |_, s, (): ()| Ok(LuaDVec3::new(s.clone().xyz())));
                methods.document(
                    "Returns the quaternion conjugate of `self`. For a unit quaternion the",
                );
                methods.document("conjugate is also the inverse.");
                methods.add_method("conjugate", |_, s, (): ()| {
                    Ok(LuaDQuat::new(s.clone().conjugate()))
                });
                methods.document("Returns the inverse of a normalized quaternion.");
                methods.document("");
                methods . document ("Typically quaternion inverse returns the conjugate of a normalized quaternion.") ;
                methods . document ("Because `self` is assumed to already be unit length this method *does not* normalize") ;
                methods.document("before returning the conjugate.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `self` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("inverse", |_, s, (): ()| {
                    Ok(LuaDQuat::new(s.clone().inverse()))
                });
                methods
                    .document("Computes the dot product of `self` and `rhs`. The dot product is");
                methods
                    .document("equal to the cosine of the angle between two quaternion rotations.");
                methods.add_method("dot", |_, s, (a_0): (LuaDQuat)| {
                    Ok(s.clone().dot(a_0.clone()))
                });
                methods.document("Computes the length of `self`.");
                methods.add_method("length", |_, s, (): ()| Ok(s.clone().length()));
                methods.document("Computes the squared length of `self`.");
                methods.document("");
                methods.document("This is generally faster than `length()` as it avoids a square");
                methods.document("root operation.");
                methods.add_method("length_squared", |_, s, (): ()| {
                    Ok(s.clone().length_squared())
                });
                methods.document("Computes `1.0 / length()`.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.add_method("length_recip", |_, s, (): ()| Ok(s.clone().length_recip()));
                methods.document("Returns `self` normalized to length 1.0.");
                methods.document("");
                methods.document("For valid results, `self` must _not_ be of length zero.");
                methods.document("");
                methods.document("Panics");
                methods.document("");
                methods
                    .document("Will panic if `self` is zero length when `glam_assert` is enabled.");
                methods.add_method("normalize", |_, s, (): ()| {
                    Ok(LuaDQuat::new(s.clone().normalize()))
                });
                methods.document("Returns `true` if, and only if, all elements are finite.");
                methods . document ("If any element is either `NaN`, positive or negative infinity, this will return `false`.") ;
                methods.add_method("is_finite", |_, s, (): ()| Ok(s.clone().is_finite()));
                methods.add_method("is_nan", |_, s, (): ()| Ok(s.clone().is_nan()));
                methods.document("Returns whether `self` of length `1.0` or not.");
                methods.document("");
                methods.document("Uses a precision threshold of `1e-6`.");
                methods.add_method("is_normalized", |_, s, (): ()| {
                    Ok(s.clone().is_normalized())
                });
                methods.add_method("is_near_identity", |_, s, (): ()| {
                    Ok(s.clone().is_near_identity())
                });
                methods.document("Returns the angle (in radians) for the minimal rotation");
                methods.document("for transforming this quaternion into another.");
                methods.document("");
                methods.document("Both quaternions must be normalized.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.") ;
                methods.add_method("angle_between", |_, s, (a_0): (LuaDQuat)| {
                    Ok(s.clone().angle_between(a_0.clone()))
                });
                methods . document ("Returns true if the absolute difference of all elements between `self` and `rhs`") ;
                methods.document("is less than or equal to `max_abs_diff`.");
                methods.document("");
                methods . document ("This can be used to compare if two quaternions contain similar elements. It works") ;
                methods . document ("best when comparing with a known value. The `max_abs_diff` that should be used used") ;
                methods.document("depends on the values being compared against.");
                methods.document("");
                methods.document("For more see");
                methods . document ("[comparing floating point numbers](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).") ;
                methods.add_method("abs_diff_eq", |_, s, (a_0, a_1): (LuaDQuat, f64)| {
                    Ok(s.clone().abs_diff_eq(a_0.clone(), a_1))
                });
                methods
                    .document("Performs a linear interpolation between `self` and `rhs` based on");
                methods.document("the value `s`.");
                methods.document("");
                methods
                    .document("When `s` is `0.0`, the result will be equal to `self`.  When `s`");
                methods.document("is `1.0`, the result will be equal to `rhs`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.") ;
                methods.add_method("lerp", |_, s, (a_0, a_1): (LuaDQuat, f64)| {
                    Ok(LuaDQuat::new(s.clone().lerp(a_0.clone(), a_1)))
                });
                methods
                    .document("Performs a spherical linear interpolation between `self` and `end`");
                methods.document("based on the value `s`.");
                methods.document("");
                methods
                    .document("When `s` is `0.0`, the result will be equal to `self`.  When `s`");
                methods.document("is `1.0`, the result will be equal to `end`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `self` or `end` are not normalized when `glam_assert` is enabled.") ;
                methods.add_method("slerp", |_, s, (a_0, a_1): (LuaDQuat, f64)| {
                    Ok(LuaDQuat::new(s.clone().slerp(a_0.clone(), a_1)))
                });
                methods.document(
                    "Multiplies a quaternion and a 3D vector, returning the rotated vector.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `self` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_method("mul_vec3", |_, s, (a_0): (LuaDVec3)| {
                    Ok(LuaDVec3::new(s.clone().mul_vec3(a_0.clone())))
                });
                methods . document ("Multiplies two quaternions. If they each represent a rotation, the result will") ;
                methods.document("represent the combined rotation.");
                methods.document("");
                methods . document ("Note that due to floating point rounding the result may not be perfectly normalized.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `self` or `rhs` are not normalized when `glam_assert` is enabled.") ;
                methods.add_method("mul_quat", |_, s, (a_0): (LuaDQuat)| {
                    Ok(LuaDQuat::new(s.clone().mul_quat(a_0.clone())))
                });
                methods.add_method("as_f32", |_, s, (): ()| {
                    Ok(LuaQuat::new(s.clone().as_f32()))
                });
            }
        }
        impl tealr::TypeName for LuaDQuat {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDQuat"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDQuat {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDQuat {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub type LuaEulerRot = crate::LuaWrapper<EulerRot>;
        impl tealr::mlu::TealData for LuaEulerRot {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Euler rotation sequences.");
                methods.document_type("");
                methods.document_type("The angles are applied starting from the right.");
                methods.document_type("E.g. XYZ will first apply the z-axis rotation.");
                methods.document_type("");
                methods.document_type(
                    "YXZ can be used for yaw (y-axis), pitch (x-axis), roll (z-axis).",
                );
                methods.document_type("");
                methods . document_type ("The two-axis rotations (e.g. ZYZ) are not fully tested and have to be treated with caution.") ;
            }
        }
        impl tealr::TypeName for LuaEulerRot {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaEulerRot"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaEulerRot {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaEulerRot {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct BevyAPIGlobals;
        impl tealr::mlu::ExportInstances for BevyAPIGlobals {
            fn add_instances<'lua, T: tealr::mlu::InstanceCollector<'lua>>(
                instance_collector: &mut T,
            ) -> mlua::Result<()> {
                instance_collector.document_instance("Global methods for Entity");
                instance_collector.add_instance("Entity".into(), |_| Ok(LuaEntityGlobals))?;
                instance_collector.document_instance("Global methods for Vec2");
                instance_collector.add_instance("Vec2".into(), |_| Ok(LuaVec2Globals))?;
                instance_collector.document_instance("Global methods for Vec3");
                instance_collector.add_instance("Vec3".into(), |_| Ok(LuaVec3Globals))?;
                instance_collector.document_instance("Global methods for Vec4");
                instance_collector.add_instance("Vec4".into(), |_| Ok(LuaVec4Globals))?;
                instance_collector.document_instance("Global methods for DVec2");
                instance_collector.add_instance("DVec2".into(), |_| Ok(LuaDVec2Globals))?;
                instance_collector.document_instance("Global methods for DVec3");
                instance_collector.add_instance("DVec3".into(), |_| Ok(LuaDVec3Globals))?;
                instance_collector.document_instance("Global methods for DVec4");
                instance_collector.add_instance("DVec4".into(), |_| Ok(LuaDVec4Globals))?;
                instance_collector.document_instance("Global methods for IVec2");
                instance_collector.add_instance("IVec2".into(), |_| Ok(LuaIVec2Globals))?;
                instance_collector.document_instance("Global methods for IVec3");
                instance_collector.add_instance("IVec3".into(), |_| Ok(LuaIVec3Globals))?;
                instance_collector.document_instance("Global methods for IVec4");
                instance_collector.add_instance("IVec4".into(), |_| Ok(LuaIVec4Globals))?;
                instance_collector.document_instance("Global methods for UVec2");
                instance_collector.add_instance("UVec2".into(), |_| Ok(LuaUVec2Globals))?;
                instance_collector.document_instance("Global methods for UVec3");
                instance_collector.add_instance("UVec3".into(), |_| Ok(LuaUVec3Globals))?;
                instance_collector.document_instance("Global methods for UVec4");
                instance_collector.add_instance("UVec4".into(), |_| Ok(LuaUVec4Globals))?;
                instance_collector.document_instance("Global methods for Mat3");
                instance_collector.add_instance("Mat3".into(), |_| Ok(LuaMat3Globals))?;
                instance_collector.document_instance("Global methods for Mat4");
                instance_collector.add_instance("Mat4".into(), |_| Ok(LuaMat4Globals))?;
                instance_collector.document_instance("Global methods for DMat3");
                instance_collector.add_instance("DMat3".into(), |_| Ok(LuaDMat3Globals))?;
                instance_collector.document_instance("Global methods for DMat4");
                instance_collector.add_instance("DMat4".into(), |_| Ok(LuaDMat4Globals))?;
                instance_collector.document_instance("Global methods for Quat");
                instance_collector.add_instance("Quat".into(), |_| Ok(LuaQuatGlobals))?;
                instance_collector.document_instance("Global methods for DQuat");
                instance_collector.add_instance("DQuat".into(), |_| Ok(LuaDQuatGlobals))?;
                Ok(())
            }
        }
        struct LuaEntityGlobals;
        impl tealr::mlu::TealData for LuaEntityGlobals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for Entity");
                methods.document(
                    "Creates a new entity reference with the specified `id` and a generation of 0.",
                );
                methods.document("");
                methods.document("# Note");
                methods.document("");
                methods . document ("Spawning a specific `entity` value is __rarely the right choice__. Most apps should favor") ;
                methods . document ("[`Commands::spawn`](crate::system::Commands::spawn). This method should generally") ;
                methods . document ("only be used for sharing entities across apps, and only when they have a scheme") ;
                methods.document(
                    "worked out to share an ID space (which doesn\'t happen by default).",
                );
                methods.document("");
                methods . document ("In general, one should not try to synchronize the ECS by attempting to ensure that") ;
                methods . document ("`Entity` lines up between instances, but instead insert a secondary identifier as") ;
                methods.document("a component.");
                methods.document("");
                methods . document ("There are still some use cases where it might be appropriate to use this function") ;
                methods.document("externally.");
                methods.document("");
                methods.document("## Examples");
                methods.document("");
                methods.document(
                    "Initializing a collection (e.g. `array` or `Vec`) with a known size:",
                );
                methods.document("");
                methods.document("```no_run");
                methods.document("# use bevy_ecs::prelude::*;");
                methods.document("let mut entities: [Entity; 10] = [Entity::from_raw(0); 10];");
                methods.document("");
                methods.document("```");
                methods.document("");
                methods.document("Deriving `Reflect` for a component that has an `Entity` field:");
                methods.document("");
                methods.document("```no_run");
                methods.document("# use bevy_ecs::{prelude::*, component::*};");
                methods.document("# use bevy_reflect::Reflect;");
                methods.document("#[derive(Reflect, Component)]");
                methods.document("#[reflect(Component)]");
                methods.document("pub struct MyStruct {");
                methods.document("    pub entity: Entity,");
                methods.document("}");
                methods.document("");
                methods.document("impl FromWorld for MyStruct {");
                methods.document("    fn from_world(_world: &mut World) -> Self {");
                methods.document("        Self {");
                methods.document("            entity: Entity::from_raw(u32::MAX),");
                methods.document("        }");
                methods.document("    }");
                methods.document("}");
                methods.document("```");
                methods.add_function("from_raw", |_, (a_0): (u32)| {
                    Ok(LuaEntity::new(Entity::from_raw(a_0)))
                });
                methods.document(
                    "Reconstruct an `Entity` previously destructured with [`Entity::to_bits`].",
                );
                methods.document("");
                methods . document ("Only useful when applied to results from `to_bits` in the same instance of an application.") ;
                methods.add_function("from_bits", |_, (a_0): (u64)| {
                    Ok(LuaEntity::new(Entity::from_bits(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaEntityGlobals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaEntityGlobals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaEntityGlobals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaEntityGlobals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaVec2Globals;
        impl tealr::mlu::TealData for LuaVec2Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for Vec2");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1): (f32, f32)| {
                    Ok(LuaVec2::new(Vec2::new(a_0, a_1)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (f32)| {
                    Ok(LuaVec2::new(Vec2::splat(a_0)))
                });
                methods . document ("Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in") ;
                methods . document ("conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will") ;
                methods . document ("create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.") ;
                methods.add_function("from_angle", |_, (a_0): (f32)| {
                    Ok(LuaVec2::new(Vec2::from_angle(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaVec2Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaVec2Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaVec2Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaVec2Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaVec3Globals;
        impl tealr::mlu::TealData for LuaVec3Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for Vec3");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1, a_2): (f32, f32, f32)| {
                    Ok(LuaVec3::new(Vec3::new(a_0, a_1, a_2)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (f32)| {
                    Ok(LuaVec3::new(Vec3::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaVec3Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaVec3Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaVec3Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaVec3Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaVec4Globals;
        impl tealr::mlu::TealData for LuaVec4Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for Vec4");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1, a_2, a_3): (f32, f32, f32, f32)| {
                    Ok(LuaVec4::new(Vec4::new(a_0, a_1, a_2, a_3)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (f32)| {
                    Ok(LuaVec4::new(Vec4::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaVec4Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaVec4Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaVec4Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaVec4Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaDVec2Globals;
        impl tealr::mlu::TealData for LuaDVec2Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for DVec2");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1): (f64, f64)| {
                    Ok(LuaDVec2::new(DVec2::new(a_0, a_1)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (f64)| {
                    Ok(LuaDVec2::new(DVec2::splat(a_0)))
                });
                methods . document ("Creates a 2D vector containing `[angle.cos(), angle.sin()]`. This can be used in") ;
                methods . document ("conjunction with the `rotate` method, e.g. `Vec2::from_angle(PI).rotate(Vec2::Y)` will") ;
                methods . document ("create the vector [-1, 0] and rotate `Vec2::Y` around it returning `-Vec2::Y`.") ;
                methods.add_function("from_angle", |_, (a_0): (f64)| {
                    Ok(LuaDVec2::new(DVec2::from_angle(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaDVec2Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDVec2Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDVec2Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDVec2Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaDVec3Globals;
        impl tealr::mlu::TealData for LuaDVec3Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for DVec3");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1, a_2): (f64, f64, f64)| {
                    Ok(LuaDVec3::new(DVec3::new(a_0, a_1, a_2)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (f64)| {
                    Ok(LuaDVec3::new(DVec3::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaDVec3Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDVec3Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDVec3Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDVec3Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaDVec4Globals;
        impl tealr::mlu::TealData for LuaDVec4Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for DVec4");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1, a_2, a_3): (f64, f64, f64, f64)| {
                    Ok(LuaDVec4::new(DVec4::new(a_0, a_1, a_2, a_3)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (f64)| {
                    Ok(LuaDVec4::new(DVec4::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaDVec4Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDVec4Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDVec4Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDVec4Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaIVec2Globals;
        impl tealr::mlu::TealData for LuaIVec2Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for IVec2");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1): (i32, i32)| {
                    Ok(LuaIVec2::new(IVec2::new(a_0, a_1)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (i32)| {
                    Ok(LuaIVec2::new(IVec2::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaIVec2Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaIVec2Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaIVec2Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaIVec2Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaIVec3Globals;
        impl tealr::mlu::TealData for LuaIVec3Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for IVec3");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1, a_2): (i32, i32, i32)| {
                    Ok(LuaIVec3::new(IVec3::new(a_0, a_1, a_2)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (i32)| {
                    Ok(LuaIVec3::new(IVec3::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaIVec3Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaIVec3Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaIVec3Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaIVec3Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaIVec4Globals;
        impl tealr::mlu::TealData for LuaIVec4Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for IVec4");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1, a_2, a_3): (i32, i32, i32, i32)| {
                    Ok(LuaIVec4::new(IVec4::new(a_0, a_1, a_2, a_3)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (i32)| {
                    Ok(LuaIVec4::new(IVec4::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaIVec4Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaIVec4Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaIVec4Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaIVec4Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaUVec2Globals;
        impl tealr::mlu::TealData for LuaUVec2Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for UVec2");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1): (u32, u32)| {
                    Ok(LuaUVec2::new(UVec2::new(a_0, a_1)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (u32)| {
                    Ok(LuaUVec2::new(UVec2::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaUVec2Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaUVec2Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaUVec2Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaUVec2Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaUVec3Globals;
        impl tealr::mlu::TealData for LuaUVec3Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for UVec3");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1, a_2): (u32, u32, u32)| {
                    Ok(LuaUVec3::new(UVec3::new(a_0, a_1, a_2)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (u32)| {
                    Ok(LuaUVec3::new(UVec3::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaUVec3Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaUVec3Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaUVec3Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaUVec3Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaUVec4Globals;
        impl tealr::mlu::TealData for LuaUVec4Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for UVec4");
                methods.document("Creates a new vector.");
                methods.add_function("new", |_, (a_0, a_1, a_2, a_3): (u32, u32, u32, u32)| {
                    Ok(LuaUVec4::new(UVec4::new(a_0, a_1, a_2, a_3)))
                });
                methods.document("Creates a vector with all elements set to `v`.");
                methods.add_function("splat", |_, (a_0): (u32)| {
                    Ok(LuaUVec4::new(UVec4::splat(a_0)))
                });
            }
        }
        impl tealr::TypeName for LuaUVec4Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaUVec4Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaUVec4Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaUVec4Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaMat3Globals;
        impl tealr::mlu::TealData for LuaMat3Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for Mat3");
                methods.document("Creates a 3x3 matrix from two column vectors.");
                methods.add_function(
                    "from_cols",
                    |_, (a_0, a_1, a_2): (LuaVec3, LuaVec3, LuaVec3)| {
                        Ok(LuaMat3::new(Mat3::from_cols(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                        )))
                    },
                );
                methods . document ("Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.") ;
                methods.add_function("from_diagonal", |_, (a_0): (LuaVec3)| {
                    Ok(LuaMat3::new(Mat3::from_diagonal(a_0.clone())))
                });
                methods.document(
                    "Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.",
                );
                methods.add_function("from_mat4", |_, (a_0): (LuaMat4)| {
                    Ok(LuaMat3::new(Mat3::from_mat4(a_0.clone())))
                });
                methods.document("Creates a 3D rotation matrix from the given quaternion.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_quat", |_, (a_0): (LuaQuat)| {
                    Ok(LuaMat3::new(Mat3::from_quat(a_0.clone())))
                });
                methods . document ("Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in") ;
                methods.document("radians).");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_axis_angle", |_, (a_0, a_1): (LuaVec3, f32)| {
                    Ok(LuaMat3::new(Mat3::from_axis_angle(a_0.clone(), a_1)))
                });
                methods . document ("Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in") ;
                methods.document("radians).");
                methods.add_function(
                    "from_euler",
                    |_, (a_0, a_1, a_2, a_3): (LuaEulerRot, f32, f32, f32)| {
                        Ok(LuaMat3::new(Mat3::from_euler(a_0.clone(), a_1, a_2, a_3)))
                    },
                );
                methods.document(
                    "Creates a 3D rotation matrix from `angle` (in radians) around the x axis.",
                );
                methods.add_function("from_rotation_x", |_, (a_0): (f32)| {
                    Ok(LuaMat3::new(Mat3::from_rotation_x(a_0)))
                });
                methods.document(
                    "Creates a 3D rotation matrix from `angle` (in radians) around the y axis.",
                );
                methods.add_function("from_rotation_y", |_, (a_0): (f32)| {
                    Ok(LuaMat3::new(Mat3::from_rotation_y(a_0)))
                });
                methods.document(
                    "Creates a 3D rotation matrix from `angle` (in radians) around the z axis.",
                );
                methods.add_function("from_rotation_z", |_, (a_0): (f32)| {
                    Ok(LuaMat3::new(Mat3::from_rotation_z(a_0)))
                });
                methods.document(
                    "Creates an affine transformation matrix from the given 2D `translation`.",
                );
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 2D points and vectors. See",
                );
                methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
                methods.add_function("from_translation", |_, (a_0): (LuaVec2)| {
                    Ok(LuaMat3::new(Mat3::from_translation(a_0.clone())))
                });
                methods . document ("Creates an affine transformation matrix from the given 2D rotation `angle` (in") ;
                methods.document("radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 2D points and vectors. See",
                );
                methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
                methods.add_function("from_angle", |_, (a_0): (f32)| {
                    Ok(LuaMat3::new(Mat3::from_angle(a_0)))
                });
                methods . document ("Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in") ;
                methods.document("radians) and `translation`.");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 2D points and vectors. See",
                );
                methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
                methods.add_function(
                    "from_scale_angle_translation",
                    |_, (a_0, a_1, a_2): (LuaVec2, f32, LuaVec2)| {
                        Ok(LuaMat3::new(Mat3::from_scale_angle_translation(
                            a_0.clone(),
                            a_1,
                            a_2.clone(),
                        )))
                    },
                );
                methods . document ("Creates an affine transformation matrix from the given non-uniform 2D `scale`.") ;
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 2D points and vectors. See",
                );
                methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                );
                methods.add_function("from_scale", |_, (a_0): (LuaVec2)| {
                    Ok(LuaMat3::new(Mat3::from_scale(a_0.clone())))
                });
            }
        }
        impl tealr::TypeName for LuaMat3Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaMat3Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaMat3Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaMat3Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaMat4Globals;
        impl tealr::mlu::TealData for LuaMat4Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for Mat4");
                methods.document("Creates a 4x4 matrix from two column vectors.");
                methods.add_function(
                    "from_cols",
                    |_, (a_0, a_1, a_2, a_3): (LuaVec4, LuaVec4, LuaVec4, LuaVec4)| {
                        Ok(LuaMat4::new(Mat4::from_cols(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                            a_3.clone(),
                        )))
                    },
                );
                methods . document ("Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.") ;
                methods.add_function("from_diagonal", |_, (a_0): (LuaVec4)| {
                    Ok(LuaMat4::new(Mat4::from_diagonal(a_0.clone())))
                });
                methods . document ("Creates an affine transformation matrix from the given 3D `scale`, `rotation` and") ;
                methods.document("`translation`.");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function(
                    "from_scale_rotation_translation",
                    |_, (a_0, a_1, a_2): (LuaVec3, LuaQuat, LuaVec3)| {
                        Ok(LuaMat4::new(Mat4::from_scale_rotation_translation(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                        )))
                    },
                );
                methods.document(
                    "Creates an affine transformation matrix from the given 3D `translation`.",
                );
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function(
                    "from_rotation_translation",
                    |_, (a_0, a_1): (LuaQuat, LuaVec3)| {
                        Ok(LuaMat4::new(Mat4::from_rotation_translation(
                            a_0.clone(),
                            a_1.clone(),
                        )))
                    },
                );
                methods.document(
                    "Creates an affine transformation matrix from the given `rotation` quaternion.",
                );
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_quat", |_, (a_0): (LuaQuat)| {
                    Ok(LuaMat4::new(Mat4::from_quat(a_0.clone())))
                });
                methods . document ("Creates an affine transformation matrix from the given 3x3 linear transformation") ;
                methods.document("matrix.");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_mat3", |_, (a_0): (LuaMat3)| {
                    Ok(LuaMat4::new(Mat4::from_mat3(a_0.clone())))
                });
                methods.document(
                    "Creates an affine transformation matrix from the given 3D `translation`.",
                );
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_translation", |_, (a_0): (LuaVec3)| {
                    Ok(LuaMat4::new(Mat4::from_translation(a_0.clone())))
                });
                methods . document ("Creates an affine transformation matrix containing a 3D rotation around a normalized") ;
                methods.document("rotation `axis` of `angle` (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_axis_angle", |_, (a_0, a_1): (LuaVec3, f32)| {
                    Ok(LuaMat4::new(Mat4::from_axis_angle(a_0.clone(), a_1)))
                });
                methods . document ("Creates a affine transformation matrix containing a rotation from the given euler") ;
                methods.document("rotation sequence and angles (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function(
                    "from_euler",
                    |_, (a_0, a_1, a_2, a_3): (LuaEulerRot, f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::from_euler(a_0.clone(), a_1, a_2, a_3)))
                    },
                );
                methods . document ("Creates an affine transformation matrix containing a 3D rotation around the x axis of") ;
                methods.document("`angle` (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_rotation_x", |_, (a_0): (f32)| {
                    Ok(LuaMat4::new(Mat4::from_rotation_x(a_0)))
                });
                methods . document ("Creates an affine transformation matrix containing a 3D rotation around the y axis of") ;
                methods.document("`angle` (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_rotation_y", |_, (a_0): (f32)| {
                    Ok(LuaMat4::new(Mat4::from_rotation_y(a_0)))
                });
                methods . document ("Creates an affine transformation matrix containing a 3D rotation around the z axis of") ;
                methods.document("`angle` (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_rotation_z", |_, (a_0): (f32)| {
                    Ok(LuaMat4::new(Mat4::from_rotation_z(a_0)))
                });
                methods . document ("Creates an affine transformation matrix containing the given 3D non-uniform `scale`.") ;
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                );
                methods.add_function("from_scale", |_, (a_0): (LuaVec3)| {
                    Ok(LuaMat4::new(Mat4::from_scale(a_0.clone())))
                });
                methods . document ("Creates a left-handed view matrix using a camera position, an up direction, and a focal") ;
                methods.document("point.");
                methods.document(
                    "For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `up` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function(
                    "look_at_lh",
                    |_, (a_0, a_1, a_2): (LuaVec3, LuaVec3, LuaVec3)| {
                        Ok(LuaMat4::new(Mat4::look_at_lh(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                        )))
                    },
                );
                methods . document ("Creates a right-handed view matrix using a camera position, an up direction, and a focal") ;
                methods.document("point.");
                methods.document(
                    "For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `up` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function(
                    "look_at_rh",
                    |_, (a_0, a_1, a_2): (LuaVec3, LuaVec3, LuaVec3)| {
                        Ok(LuaMat4::new(Mat4::look_at_rh(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                        )))
                    },
                );
                methods.document(
                    "Creates a right-handed perspective projection matrix with [-1,1] depth range.",
                );
                methods.document("This is the same as the OpenGL `gluPerspective` function.");
                methods . document ("See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>") ;
                methods.add_function(
                    "perspective_rh_gl",
                    |_, (a_0, a_1, a_2, a_3): (f32, f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::perspective_rh_gl(a_0, a_1, a_2, a_3)))
                    },
                );
                methods.document(
                    "Creates a left-handed perspective projection matrix with `[0,1]` depth range.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is") ;
                methods.document("enabled.");
                methods.add_function(
                    "perspective_lh",
                    |_, (a_0, a_1, a_2, a_3): (f32, f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::perspective_lh(a_0, a_1, a_2, a_3)))
                    },
                );
                methods . document ("Creates a right-handed perspective projection matrix with `[0,1]` depth range.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is") ;
                methods.document("enabled.");
                methods.add_function(
                    "perspective_rh",
                    |_, (a_0, a_1, a_2, a_3): (f32, f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::perspective_rh(a_0, a_1, a_2, a_3)))
                    },
                );
                methods . document ("Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.") ;
                methods.add_function(
                    "perspective_infinite_lh",
                    |_, (a_0, a_1, a_2): (f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::perspective_infinite_lh(a_0, a_1, a_2)))
                    },
                );
                methods . document ("Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.") ;
                methods.add_function(
                    "perspective_infinite_reverse_lh",
                    |_, (a_0, a_1, a_2): (f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::perspective_infinite_reverse_lh(
                            a_0, a_1, a_2,
                        )))
                    },
                );
                methods.document(
                    "Creates an infinite right-handed perspective projection matrix with",
                );
                methods.document("`[0,1]` depth range.");
                methods.add_function(
                    "perspective_infinite_rh",
                    |_, (a_0, a_1, a_2): (f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::perspective_infinite_rh(a_0, a_1, a_2)))
                    },
                );
                methods.document(
                    "Creates an infinite reverse right-handed perspective projection matrix",
                );
                methods.document("with `[0,1]` depth range.");
                methods.add_function(
                    "perspective_infinite_reverse_rh",
                    |_, (a_0, a_1, a_2): (f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::perspective_infinite_reverse_rh(
                            a_0, a_1, a_2,
                        )))
                    },
                );
                methods.document(
                    "Creates a right-handed orthographic projection matrix with `[-1,1]` depth",
                );
                methods.document(
                    "range.  This is the same as the OpenGL `glOrtho` function in OpenGL.",
                );
                methods.document("See");
                methods.document(
                    "<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>",
                );
                methods.add_function(
                    "orthographic_rh_gl",
                    |_, (a_0, a_1, a_2, a_3, a_4, a_5): (f32, f32, f32, f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::orthographic_rh_gl(
                            a_0, a_1, a_2, a_3, a_4, a_5,
                        )))
                    },
                );
                methods . document ("Creates a left-handed orthographic projection matrix with `[0,1]` depth range.") ;
                methods.add_function(
                    "orthographic_lh",
                    |_, (a_0, a_1, a_2, a_3, a_4, a_5): (f32, f32, f32, f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::orthographic_lh(
                            a_0, a_1, a_2, a_3, a_4, a_5,
                        )))
                    },
                );
                methods . document ("Creates a right-handed orthographic projection matrix with `[0,1]` depth range.") ;
                methods.add_function(
                    "orthographic_rh",
                    |_, (a_0, a_1, a_2, a_3, a_4, a_5): (f32, f32, f32, f32, f32, f32)| {
                        Ok(LuaMat4::new(Mat4::orthographic_rh(
                            a_0, a_1, a_2, a_3, a_4, a_5,
                        )))
                    },
                );
            }
        }
        impl tealr::TypeName for LuaMat4Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaMat4Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaMat4Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaMat4Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaDMat3Globals;
        impl tealr::mlu::TealData for LuaDMat3Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for DMat3");
                methods.document("Creates a 3x3 matrix from two column vectors.");
                methods.add_function(
                    "from_cols",
                    |_, (a_0, a_1, a_2): (LuaDVec3, LuaDVec3, LuaDVec3)| {
                        Ok(LuaDMat3::new(DMat3::from_cols(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                        )))
                    },
                );
                methods . document ("Creates a 3x3 matrix with its diagonal set to `diagonal` and all other entries set to 0.") ;
                methods.add_function("from_diagonal", |_, (a_0): (LuaDVec3)| {
                    Ok(LuaDMat3::new(DMat3::from_diagonal(a_0.clone())))
                });
                methods.document(
                    "Creates a 3x3 matrix from a 4x4 matrix, discarding the 3rd row and column.",
                );
                methods.add_function("from_mat4", |_, (a_0): (LuaDMat4)| {
                    Ok(LuaDMat3::new(DMat3::from_mat4(a_0.clone())))
                });
                methods.document("Creates a 3D rotation matrix from the given quaternion.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_quat", |_, (a_0): (LuaDQuat)| {
                    Ok(LuaDMat3::new(DMat3::from_quat(a_0.clone())))
                });
                methods . document ("Creates a 3D rotation matrix from a normalized rotation `axis` and `angle` (in") ;
                methods.document("radians).");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_axis_angle", |_, (a_0, a_1): (LuaDVec3, f64)| {
                    Ok(LuaDMat3::new(DMat3::from_axis_angle(a_0.clone(), a_1)))
                });
                methods . document ("Creates a 3D rotation matrix from the given euler rotation sequence and the angles (in") ;
                methods.document("radians).");
                methods.add_function(
                    "from_euler",
                    |_, (a_0, a_1, a_2, a_3): (LuaEulerRot, f64, f64, f64)| {
                        Ok(LuaDMat3::new(DMat3::from_euler(a_0.clone(), a_1, a_2, a_3)))
                    },
                );
                methods.document(
                    "Creates a 3D rotation matrix from `angle` (in radians) around the x axis.",
                );
                methods.add_function("from_rotation_x", |_, (a_0): (f64)| {
                    Ok(LuaDMat3::new(DMat3::from_rotation_x(a_0)))
                });
                methods.document(
                    "Creates a 3D rotation matrix from `angle` (in radians) around the y axis.",
                );
                methods.add_function("from_rotation_y", |_, (a_0): (f64)| {
                    Ok(LuaDMat3::new(DMat3::from_rotation_y(a_0)))
                });
                methods.document(
                    "Creates a 3D rotation matrix from `angle` (in radians) around the z axis.",
                );
                methods.add_function("from_rotation_z", |_, (a_0): (f64)| {
                    Ok(LuaDMat3::new(DMat3::from_rotation_z(a_0)))
                });
                methods.document(
                    "Creates an affine transformation matrix from the given 2D `translation`.",
                );
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 2D points and vectors. See",
                );
                methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
                methods.add_function("from_translation", |_, (a_0): (LuaDVec2)| {
                    Ok(LuaDMat3::new(DMat3::from_translation(a_0.clone())))
                });
                methods . document ("Creates an affine transformation matrix from the given 2D rotation `angle` (in") ;
                methods.document("radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 2D points and vectors. See",
                );
                methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
                methods.add_function("from_angle", |_, (a_0): (f64)| {
                    Ok(LuaDMat3::new(DMat3::from_angle(a_0)))
                });
                methods . document ("Creates an affine transformation matrix from the given 2D `scale`, rotation `angle` (in") ;
                methods.document("radians) and `translation`.");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 2D points and vectors. See",
                );
                methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
                methods.add_function(
                    "from_scale_angle_translation",
                    |_, (a_0, a_1, a_2): (LuaDVec2, f64, LuaDVec2)| {
                        Ok(LuaDMat3::new(DMat3::from_scale_angle_translation(
                            a_0.clone(),
                            a_1,
                            a_2.clone(),
                        )))
                    },
                );
                methods . document ("Creates an affine transformation matrix from the given non-uniform 2D `scale`.") ;
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 2D points and vectors. See",
                );
                methods.document("[`Self::transform_point2()`] and [`Self::transform_vector2()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                );
                methods.add_function("from_scale", |_, (a_0): (LuaDVec2)| {
                    Ok(LuaDMat3::new(DMat3::from_scale(a_0.clone())))
                });
            }
        }
        impl tealr::TypeName for LuaDMat3Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDMat3Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDMat3Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDMat3Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaDMat4Globals;
        impl tealr::mlu::TealData for LuaDMat4Globals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for DMat4");
                methods.document("Creates a 4x4 matrix from two column vectors.");
                methods.add_function(
                    "from_cols",
                    |_, (a_0, a_1, a_2, a_3): (LuaDVec4, LuaDVec4, LuaDVec4, LuaDVec4)| {
                        Ok(LuaDMat4::new(DMat4::from_cols(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                            a_3.clone(),
                        )))
                    },
                );
                methods . document ("Creates a 4x4 matrix with its diagonal set to `diagonal` and all other entries set to 0.") ;
                methods.add_function("from_diagonal", |_, (a_0): (LuaDVec4)| {
                    Ok(LuaDMat4::new(DMat4::from_diagonal(a_0.clone())))
                });
                methods . document ("Creates an affine transformation matrix from the given 3D `scale`, `rotation` and") ;
                methods.document("`translation`.");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function(
                    "from_scale_rotation_translation",
                    |_, (a_0, a_1, a_2): (LuaDVec3, LuaDQuat, LuaDVec3)| {
                        Ok(LuaDMat4::new(DMat4::from_scale_rotation_translation(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                        )))
                    },
                );
                methods.document(
                    "Creates an affine transformation matrix from the given 3D `translation`.",
                );
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function(
                    "from_rotation_translation",
                    |_, (a_0, a_1): (LuaDQuat, LuaDVec3)| {
                        Ok(LuaDMat4::new(DMat4::from_rotation_translation(
                            a_0.clone(),
                            a_1.clone(),
                        )))
                    },
                );
                methods.document(
                    "Creates an affine transformation matrix from the given `rotation` quaternion.",
                );
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `rotation` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_quat", |_, (a_0): (LuaDQuat)| {
                    Ok(LuaDMat4::new(DMat4::from_quat(a_0.clone())))
                });
                methods . document ("Creates an affine transformation matrix from the given 3x3 linear transformation") ;
                methods.document("matrix.");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_mat3", |_, (a_0): (LuaDMat3)| {
                    Ok(LuaDMat4::new(DMat4::from_mat3(a_0.clone())))
                });
                methods.document(
                    "Creates an affine transformation matrix from the given 3D `translation`.",
                );
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_translation", |_, (a_0): (LuaDVec3)| {
                    Ok(LuaDMat4::new(DMat4::from_translation(a_0.clone())))
                });
                methods . document ("Creates an affine transformation matrix containing a 3D rotation around a normalized") ;
                methods.document("rotation `axis` of `angle` (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_axis_angle", |_, (a_0, a_1): (LuaDVec3, f64)| {
                    Ok(LuaDMat4::new(DMat4::from_axis_angle(a_0.clone(), a_1)))
                });
                methods . document ("Creates a affine transformation matrix containing a rotation from the given euler") ;
                methods.document("rotation sequence and angles (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function(
                    "from_euler",
                    |_, (a_0, a_1, a_2, a_3): (LuaEulerRot, f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::from_euler(a_0.clone(), a_1, a_2, a_3)))
                    },
                );
                methods . document ("Creates an affine transformation matrix containing a 3D rotation around the x axis of") ;
                methods.document("`angle` (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_rotation_x", |_, (a_0): (f64)| {
                    Ok(LuaDMat4::new(DMat4::from_rotation_x(a_0)))
                });
                methods . document ("Creates an affine transformation matrix containing a 3D rotation around the y axis of") ;
                methods.document("`angle` (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_rotation_y", |_, (a_0): (f64)| {
                    Ok(LuaDMat4::new(DMat4::from_rotation_y(a_0)))
                });
                methods . document ("Creates an affine transformation matrix containing a 3D rotation around the z axis of") ;
                methods.document("`angle` (in radians).");
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.add_function("from_rotation_z", |_, (a_0): (f64)| {
                    Ok(LuaDMat4::new(DMat4::from_rotation_z(a_0)))
                });
                methods . document ("Creates an affine transformation matrix containing the given 3D non-uniform `scale`.") ;
                methods.document("");
                methods.document(
                    "The resulting matrix can be used to transform 3D points and vectors. See",
                );
                methods.document("[`Self::transform_point3()`] and [`Self::transform_vector3()`].");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if all elements of `scale` are zero when `glam_assert` is enabled.",
                );
                methods.add_function("from_scale", |_, (a_0): (LuaDVec3)| {
                    Ok(LuaDMat4::new(DMat4::from_scale(a_0.clone())))
                });
                methods . document ("Creates a left-handed view matrix using a camera position, an up direction, and a focal") ;
                methods.document("point.");
                methods.document(
                    "For a view coordinate system with `+X=right`, `+Y=up` and `+Z=forward`.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `up` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function(
                    "look_at_lh",
                    |_, (a_0, a_1, a_2): (LuaDVec3, LuaDVec3, LuaDVec3)| {
                        Ok(LuaDMat4::new(DMat4::look_at_lh(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                        )))
                    },
                );
                methods . document ("Creates a right-handed view matrix using a camera position, an up direction, and a focal") ;
                methods.document("point.");
                methods.document(
                    "For a view coordinate system with `+X=right`, `+Y=up` and `+Z=back`.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `up` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function(
                    "look_at_rh",
                    |_, (a_0, a_1, a_2): (LuaDVec3, LuaDVec3, LuaDVec3)| {
                        Ok(LuaDMat4::new(DMat4::look_at_rh(
                            a_0.clone(),
                            a_1.clone(),
                            a_2.clone(),
                        )))
                    },
                );
                methods.document(
                    "Creates a right-handed perspective projection matrix with [-1,1] depth range.",
                );
                methods.document("This is the same as the OpenGL `gluPerspective` function.");
                methods . document ("See <https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml>") ;
                methods.add_function(
                    "perspective_rh_gl",
                    |_, (a_0, a_1, a_2, a_3): (f64, f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::perspective_rh_gl(a_0, a_1, a_2, a_3)))
                    },
                );
                methods.document(
                    "Creates a left-handed perspective projection matrix with `[0,1]` depth range.",
                );
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is") ;
                methods.document("enabled.");
                methods.add_function(
                    "perspective_lh",
                    |_, (a_0, a_1, a_2, a_3): (f64, f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::perspective_lh(a_0, a_1, a_2, a_3)))
                    },
                );
                methods . document ("Creates a right-handed perspective projection matrix with `[0,1]` depth range.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `z_near` or `z_far` are less than or equal to zero when `glam_assert` is") ;
                methods.document("enabled.");
                methods.add_function(
                    "perspective_rh",
                    |_, (a_0, a_1, a_2, a_3): (f64, f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::perspective_rh(a_0, a_1, a_2, a_3)))
                    },
                );
                methods . document ("Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.") ;
                methods.add_function(
                    "perspective_infinite_lh",
                    |_, (a_0, a_1, a_2): (f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::perspective_infinite_lh(a_0, a_1, a_2)))
                    },
                );
                methods . document ("Creates an infinite left-handed perspective projection matrix with `[0,1]` depth range.") ;
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `z_near` is less than or equal to zero when `glam_assert` is enabled.") ;
                methods.add_function(
                    "perspective_infinite_reverse_lh",
                    |_, (a_0, a_1, a_2): (f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::perspective_infinite_reverse_lh(
                            a_0, a_1, a_2,
                        )))
                    },
                );
                methods.document(
                    "Creates an infinite right-handed perspective projection matrix with",
                );
                methods.document("`[0,1]` depth range.");
                methods.add_function(
                    "perspective_infinite_rh",
                    |_, (a_0, a_1, a_2): (f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::perspective_infinite_rh(a_0, a_1, a_2)))
                    },
                );
                methods.document(
                    "Creates an infinite reverse right-handed perspective projection matrix",
                );
                methods.document("with `[0,1]` depth range.");
                methods.add_function(
                    "perspective_infinite_reverse_rh",
                    |_, (a_0, a_1, a_2): (f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::perspective_infinite_reverse_rh(
                            a_0, a_1, a_2,
                        )))
                    },
                );
                methods.document(
                    "Creates a right-handed orthographic projection matrix with `[-1,1]` depth",
                );
                methods.document(
                    "range.  This is the same as the OpenGL `glOrtho` function in OpenGL.",
                );
                methods.document("See");
                methods.document(
                    "<https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml>",
                );
                methods.add_function(
                    "orthographic_rh_gl",
                    |_, (a_0, a_1, a_2, a_3, a_4, a_5): (f64, f64, f64, f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::orthographic_rh_gl(
                            a_0, a_1, a_2, a_3, a_4, a_5,
                        )))
                    },
                );
                methods . document ("Creates a left-handed orthographic projection matrix with `[0,1]` depth range.") ;
                methods.add_function(
                    "orthographic_lh",
                    |_, (a_0, a_1, a_2, a_3, a_4, a_5): (f64, f64, f64, f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::orthographic_lh(
                            a_0, a_1, a_2, a_3, a_4, a_5,
                        )))
                    },
                );
                methods . document ("Creates a right-handed orthographic projection matrix with `[0,1]` depth range.") ;
                methods.add_function(
                    "orthographic_rh",
                    |_, (a_0, a_1, a_2, a_3, a_4, a_5): (f64, f64, f64, f64, f64, f64)| {
                        Ok(LuaDMat4::new(DMat4::orthographic_rh(
                            a_0, a_1, a_2, a_3, a_4, a_5,
                        )))
                    },
                );
            }
        }
        impl tealr::TypeName for LuaDMat4Globals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDMat4Globals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDMat4Globals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDMat4Globals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaQuatGlobals;
        impl tealr::mlu::TealData for LuaQuatGlobals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for Quat");
                methods.document("Creates a new rotation quaternion.");
                methods.document("");
                methods . document ("This should generally not be called manually unless you know what you are doing.") ;
                methods . document ("Use one of the other constructors instead such as `identity` or `from_axis_angle`.") ;
                methods.document("");
                methods.document(
                    "`from_xyzw` is mostly used by unit tests and `serde` deserialization.",
                );
                methods.document("");
                methods.document("# Preconditions");
                methods.document("");
                methods . document ("This function does not check if the input is normalized, it is up to the user to") ;
                methods.document(
                    "provide normalized input or to normalized the resulting quaternion.",
                );
                methods.add_function(
                    "from_xyzw",
                    |_, (a_0, a_1, a_2, a_3): (f32, f32, f32, f32)| {
                        Ok(LuaQuat::new(Quat::from_xyzw(a_0, a_1, a_2, a_3)))
                    },
                );
                methods.document("Creates a new rotation quaternion from a 4D vector.");
                methods.document("");
                methods.document("# Preconditions");
                methods.document("");
                methods . document ("This function does not check if the input is normalized, it is up to the user to") ;
                methods.document(
                    "provide normalized input or to normalized the resulting quaternion.",
                );
                methods.add_function("from_vec4", |_, (a_0): (LuaVec4)| {
                    Ok(LuaQuat::new(Quat::from_vec4(a_0.clone())))
                });
                methods . document ("Create a quaternion for a normalized rotation `axis` and `angle` (in radians).") ;
                methods.document("The axis must be normalized (unit-length).");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_axis_angle", |_, (a_0, a_1): (LuaVec3, f32)| {
                    Ok(LuaQuat::new(Quat::from_axis_angle(a_0.clone(), a_1)))
                });
                methods.document(
                    "Create a quaternion that rotates `v.length()` radians around `v.normalize()`.",
                );
                methods.document("");
                methods
                    .document("`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.");
                methods.add_function("from_scaled_axis", |_, (a_0): (LuaVec3)| {
                    Ok(LuaQuat::new(Quat::from_scaled_axis(a_0.clone())))
                });
                methods.document(
                    "Creates a quaternion from the `angle` (in radians) around the x axis.",
                );
                methods.add_function("from_rotation_x", |_, (a_0): (f32)| {
                    Ok(LuaQuat::new(Quat::from_rotation_x(a_0)))
                });
                methods.document(
                    "Creates a quaternion from the `angle` (in radians) around the y axis.",
                );
                methods.add_function("from_rotation_y", |_, (a_0): (f32)| {
                    Ok(LuaQuat::new(Quat::from_rotation_y(a_0)))
                });
                methods.document(
                    "Creates a quaternion from the `angle` (in radians) around the z axis.",
                );
                methods.add_function("from_rotation_z", |_, (a_0): (f32)| {
                    Ok(LuaQuat::new(Quat::from_rotation_z(a_0)))
                });
                methods . document ("Creates a quaternion from the given Euler rotation sequence and the angles (in radians).") ;
                methods.add_function(
                    "from_euler",
                    |_, (a_0, a_1, a_2, a_3): (LuaEulerRot, f32, f32, f32)| {
                        Ok(LuaQuat::new(Quat::from_euler(a_0.clone(), a_1, a_2, a_3)))
                    },
                );
                methods.document("Creates a quaternion from a 3x3 rotation matrix.");
                methods.add_function("from_mat3", |_, (a_0): (LuaMat3)| {
                    Ok(a_0.val(|a_0| LuaQuat::new(Quat::from_mat3(a_0))))
                });
                methods . document ("Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.") ;
                methods.add_function("from_mat4", |_, (a_0): (LuaMat4)| {
                    Ok(a_0.val(|a_0| LuaQuat::new(Quat::from_mat4(a_0))))
                });
                methods . document ("Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the") ;
                methods.document(
                    "plane spanned by the two vectors.  Will rotate at most 180 degrees.",
                );
                methods.document("");
                methods.document("The input vectors must be normalized (unit-length).");
                methods.document("");
                methods.document("`from_rotation_arc(from, to) * from ≈ to`.");
                methods.document("");
                methods.document(
                    "For near-singular cases (from≈to and from≈-to) the current implementation",
                );
                methods.document("is only accurate to about 0.001 (for `f32`).");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.") ;
                methods.add_function("from_rotation_arc", |_, (a_0, a_1): (LuaVec3, LuaVec3)| {
                    Ok(LuaQuat::new(Quat::from_rotation_arc(
                        a_0.clone(),
                        a_1.clone(),
                    )))
                });
                methods . document ("Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means") ;
                methods . document ("that the resulting quaternion will rotate `from` so that it is colinear with `to`.") ;
                methods.document("");
                methods . document ("The rotation is in the plane spanned by the two vectors.  Will rotate at most 90") ;
                methods.document("degrees.");
                methods.document("");
                methods.document("The input vectors must be normalized (unit-length).");
                methods.document("");
                methods
                    .document("`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.") ;
                methods.add_function(
                    "from_rotation_arc_colinear",
                    |_, (a_0, a_1): (LuaVec3, LuaVec3)| {
                        Ok(LuaQuat::new(Quat::from_rotation_arc_colinear(
                            a_0.clone(),
                            a_1.clone(),
                        )))
                    },
                );
                methods . document ("Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is") ;
                methods.document("around the z axis. Will rotate at most 180 degrees.");
                methods.document("");
                methods.document("The input vectors must be normalized (unit-length).");
                methods.document("");
                methods.document("`from_rotation_arc_2d(from, to) * from ≈ to`.");
                methods.document("");
                methods.document(
                    "For near-singular cases (from≈to and from≈-to) the current implementation",
                );
                methods.document("is only accurate to about 0.001 (for `f32`).");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.") ;
                methods.add_function(
                    "from_rotation_arc_2d",
                    |_, (a_0, a_1): (LuaVec2, LuaVec2)| {
                        Ok(LuaQuat::new(Quat::from_rotation_arc_2d(
                            a_0.clone(),
                            a_1.clone(),
                        )))
                    },
                );
            }
        }
        impl tealr::TypeName for LuaQuatGlobals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaQuatGlobals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaQuatGlobals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaQuatGlobals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        struct LuaDQuatGlobals;
        impl tealr::mlu::TealData for LuaDQuatGlobals {
            fn add_methods<'lua, T: tealr::mlu::TealDataMethods<'lua, Self>>(methods: &mut T) {
                methods.document_type("Global methods for DQuat");
                methods.document("Creates a new rotation quaternion.");
                methods.document("");
                methods . document ("This should generally not be called manually unless you know what you are doing.") ;
                methods . document ("Use one of the other constructors instead such as `identity` or `from_axis_angle`.") ;
                methods.document("");
                methods.document(
                    "`from_xyzw` is mostly used by unit tests and `serde` deserialization.",
                );
                methods.document("");
                methods.document("# Preconditions");
                methods.document("");
                methods . document ("This function does not check if the input is normalized, it is up to the user to") ;
                methods.document(
                    "provide normalized input or to normalized the resulting quaternion.",
                );
                methods.add_function(
                    "from_xyzw",
                    |_, (a_0, a_1, a_2, a_3): (f64, f64, f64, f64)| {
                        Ok(LuaDQuat::new(DQuat::from_xyzw(a_0, a_1, a_2, a_3)))
                    },
                );
                methods.document("Creates a new rotation quaternion from a 4D vector.");
                methods.document("");
                methods.document("# Preconditions");
                methods.document("");
                methods . document ("This function does not check if the input is normalized, it is up to the user to") ;
                methods.document(
                    "provide normalized input or to normalized the resulting quaternion.",
                );
                methods.add_function("from_vec4", |_, (a_0): (LuaDVec4)| {
                    Ok(LuaDQuat::new(DQuat::from_vec4(a_0.clone())))
                });
                methods . document ("Create a quaternion for a normalized rotation `axis` and `angle` (in radians).") ;
                methods.document("The axis must be normalized (unit-length).");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods.document(
                    "Will panic if `axis` is not normalized when `glam_assert` is enabled.",
                );
                methods.add_function("from_axis_angle", |_, (a_0, a_1): (LuaDVec3, f64)| {
                    Ok(LuaDQuat::new(DQuat::from_axis_angle(a_0.clone(), a_1)))
                });
                methods.document(
                    "Create a quaternion that rotates `v.length()` radians around `v.normalize()`.",
                );
                methods.document("");
                methods
                    .document("`from_scaled_axis(Vec3::ZERO)` results in the identity quaternion.");
                methods.add_function("from_scaled_axis", |_, (a_0): (LuaDVec3)| {
                    Ok(LuaDQuat::new(DQuat::from_scaled_axis(a_0.clone())))
                });
                methods.document(
                    "Creates a quaternion from the `angle` (in radians) around the x axis.",
                );
                methods.add_function("from_rotation_x", |_, (a_0): (f64)| {
                    Ok(LuaDQuat::new(DQuat::from_rotation_x(a_0)))
                });
                methods.document(
                    "Creates a quaternion from the `angle` (in radians) around the y axis.",
                );
                methods.add_function("from_rotation_y", |_, (a_0): (f64)| {
                    Ok(LuaDQuat::new(DQuat::from_rotation_y(a_0)))
                });
                methods.document(
                    "Creates a quaternion from the `angle` (in radians) around the z axis.",
                );
                methods.add_function("from_rotation_z", |_, (a_0): (f64)| {
                    Ok(LuaDQuat::new(DQuat::from_rotation_z(a_0)))
                });
                methods . document ("Creates a quaternion from the given Euler rotation sequence and the angles (in radians).") ;
                methods.add_function(
                    "from_euler",
                    |_, (a_0, a_1, a_2, a_3): (LuaEulerRot, f64, f64, f64)| {
                        Ok(LuaDQuat::new(DQuat::from_euler(a_0.clone(), a_1, a_2, a_3)))
                    },
                );
                methods.document("Creates a quaternion from a 3x3 rotation matrix.");
                methods.add_function("from_mat3", |_, (a_0): (LuaDMat3)| {
                    Ok(a_0.val(|a_0| LuaDQuat::new(DQuat::from_mat3(a_0))))
                });
                methods . document ("Creates a quaternion from a 3x3 rotation matrix inside a homogeneous 4x4 matrix.") ;
                methods.add_function("from_mat4", |_, (a_0): (LuaDMat4)| {
                    Ok(a_0.val(|a_0| LuaDQuat::new(DQuat::from_mat4(a_0))))
                });
                methods . document ("Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the") ;
                methods.document(
                    "plane spanned by the two vectors.  Will rotate at most 180 degrees.",
                );
                methods.document("");
                methods.document("The input vectors must be normalized (unit-length).");
                methods.document("");
                methods.document("`from_rotation_arc(from, to) * from ≈ to`.");
                methods.document("");
                methods.document(
                    "For near-singular cases (from≈to and from≈-to) the current implementation",
                );
                methods.document("is only accurate to about 0.001 (for `f32`).");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.") ;
                methods.add_function(
                    "from_rotation_arc",
                    |_, (a_0, a_1): (LuaDVec3, LuaDVec3)| {
                        Ok(LuaDQuat::new(DQuat::from_rotation_arc(
                            a_0.clone(),
                            a_1.clone(),
                        )))
                    },
                );
                methods . document ("Gets the minimal rotation for transforming `from` to either `to` or `-to`.  This means") ;
                methods . document ("that the resulting quaternion will rotate `from` so that it is colinear with `to`.") ;
                methods.document("");
                methods . document ("The rotation is in the plane spanned by the two vectors.  Will rotate at most 90") ;
                methods.document("degrees.");
                methods.document("");
                methods.document("The input vectors must be normalized (unit-length).");
                methods.document("");
                methods
                    .document("`to.dot(from_rotation_arc_colinear(from, to) * from).abs() ≈ 1`.");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.") ;
                methods.add_function(
                    "from_rotation_arc_colinear",
                    |_, (a_0, a_1): (LuaDVec3, LuaDVec3)| {
                        Ok(LuaDQuat::new(DQuat::from_rotation_arc_colinear(
                            a_0.clone(),
                            a_1.clone(),
                        )))
                    },
                );
                methods . document ("Gets the minimal rotation for transforming `from` to `to`.  The resulting rotation is") ;
                methods.document("around the z axis. Will rotate at most 180 degrees.");
                methods.document("");
                methods.document("The input vectors must be normalized (unit-length).");
                methods.document("");
                methods.document("`from_rotation_arc_2d(from, to) * from ≈ to`.");
                methods.document("");
                methods.document(
                    "For near-singular cases (from≈to and from≈-to) the current implementation",
                );
                methods.document("is only accurate to about 0.001 (for `f32`).");
                methods.document("");
                methods.document("# Panics");
                methods.document("");
                methods . document ("Will panic if `from` or `to` are not normalized when `glam_assert` is enabled.") ;
                methods.add_function(
                    "from_rotation_arc_2d",
                    |_, (a_0, a_1): (LuaDVec2, LuaDVec2)| {
                        Ok(LuaDQuat::new(DQuat::from_rotation_arc_2d(
                            a_0.clone(),
                            a_1.clone(),
                        )))
                    },
                );
            }
        }
        impl tealr::TypeName for LuaDQuatGlobals {
            fn get_type_parts() -> std::borrow::Cow<'static, [tealr::NamePart]> {
                std::borrow::Cow::Borrowed(&[tealr::NamePart::Type(tealr::TealType {
                    name: std::borrow::Cow::Borrowed("LuaDQuatGlobals"),
                    generics: None,
                    type_kind: tealr::KindOfType::External,
                })])
            }
        }
        impl mlua::UserData for LuaDQuatGlobals {
            fn add_fields<'lua, F: mlua::prelude::LuaUserDataFields<'lua, Self>>(fields: &mut F) {
                let mut wrapper = ::tealr::mlu::UserDataWrapper::from_user_data_fields(fields);
                <Self as ::tealr::mlu::TealData>::add_fields(&mut wrapper)
            }
            fn add_methods<'lua, M: mlua::prelude::LuaUserDataMethods<'lua, Self>>(
                methods: &mut M,
            ) {
                let mut x = ::tealr::mlu::UserDataWrapper::from_user_data_methods(methods);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut x);
            }
        }
        impl tealr::TypeBody for LuaDQuatGlobals {
            fn get_type_body() -> tealr::TypeGenerator {
                let mut gen = ::tealr::RecordGenerator::new::<Self>(false);
                gen.is_user_data = true;
                <Self as ::tealr::mlu::TealData>::add_fields(&mut gen);
                <Self as ::tealr::mlu::TealData>::add_methods(&mut gen);
                <_ as ::std::convert::From<_>>::from(gen)
            }
        }
        pub struct LuaBevyAPIProvider;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for LuaBevyAPIProvider {
            #[inline]
            fn default() -> LuaBevyAPIProvider {
                LuaBevyAPIProvider {}
            }
        }
        impl crate::APIProvider for LuaBevyAPIProvider {
            type Target = ::std::sync::Mutex<Lua>;
            type DocTarget = crate::LuaDocFragment;
            fn attach_api(
                &mut self,
                c: &mut <Self as crate::APIProvider>::Target,
            ) -> Result<(), crate::ScriptError> {
                let lua_ctx = c.lock().expect("Could not get lock on script context");
                tealr::mlu::set_global_env::<BevyAPIGlobals>(&lua_ctx)?;
                Ok(())
            }
            fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
                Some(crate::LuaDocFragment::new(|tw| {
                    tw.document_global_instance::<BevyAPIGlobals>()
                        .unwrap()
                        .process_type::<LuaEntity>()
                        .process_type::<LuaVec2>()
                        .process_type::<LuaVec3>()
                        .process_type::<LuaVec4>()
                        .process_type::<LuaDVec2>()
                        .process_type::<LuaDVec3>()
                        .process_type::<LuaDVec4>()
                        .process_type::<LuaIVec2>()
                        .process_type::<LuaIVec3>()
                        .process_type::<LuaIVec4>()
                        .process_type::<LuaUVec2>()
                        .process_type::<LuaUVec3>()
                        .process_type::<LuaUVec4>()
                        .process_type::<LuaMat3>()
                        .process_type::<LuaMat4>()
                        .process_type::<LuaDMat3>()
                        .process_type::<LuaDMat4>()
                        .process_type::<LuaQuat>()
                        .process_type::<LuaDQuat>()
                        .process_type::<LuaEulerRot>()
                        .process_type::<LuaEntityGlobals>()
                        .process_type::<LuaVec2Globals>()
                        .process_type::<LuaVec3Globals>()
                        .process_type::<LuaVec4Globals>()
                        .process_type::<LuaDVec2Globals>()
                        .process_type::<LuaDVec3Globals>()
                        .process_type::<LuaDVec4Globals>()
                        .process_type::<LuaIVec2Globals>()
                        .process_type::<LuaIVec3Globals>()
                        .process_type::<LuaIVec4Globals>()
                        .process_type::<LuaUVec2Globals>()
                        .process_type::<LuaUVec3Globals>()
                        .process_type::<LuaUVec4Globals>()
                        .process_type::<LuaMat3Globals>()
                        .process_type::<LuaMat4Globals>()
                        .process_type::<LuaDMat3Globals>()
                        .process_type::<LuaDMat4Globals>()
                        .process_type::<LuaQuatGlobals>()
                        .process_type::<LuaDQuatGlobals>()
                        .process_type::<LuaComponent>()
                        .process_type::<LuaResource>()
                        .process_type::<LuaWorld>()
                }))
            }
        }
        pub static BEVY_TO_LUA: Map<
            &'static str,
            for<'l> fn(&crate::LuaRef, &'l Lua) -> tealr::mlu::mlua::Value<'l>,
        > = {
            #[allow(dead_code)]
            enum ProcMacroHack {
                Value = ("\"usize\" => | r, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < usize > ().unwrap().to_i64().unwrap())), \"isize\"\n=> | r, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < isize > ().unwrap().to_i64().unwrap())), \"i128\" =>\n| r, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i128 > ().unwrap().to_i64().unwrap())), \"i64\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i64 > ().unwrap().to_i64().unwrap())), \"i32\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i32 > ().unwrap().to_i64().unwrap())), \"i16\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i16 > ().unwrap().to_i64().unwrap())), \"i8\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < i8 > ().unwrap().to_i64().unwrap())), \"u128\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u128 > ().unwrap().to_i64().unwrap())), \"u64\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u64 > ().unwrap().to_i64().unwrap())), \"u32\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u32 > ().unwrap().to_i64().unwrap())), \"u16\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u16 > ().unwrap().to_i64().unwrap())), \"u8\" => |\nr, _ |\nr.get(| s, _ | Value ::\nInteger(s.downcast_ref :: < u8 > ().unwrap().to_i64().unwrap())), \"f32\" => |\nr, _ |\nr.get(| s, _ | Value ::\nNumber(s.downcast_ref :: < f32 > ().unwrap().to_f64().unwrap())), \"f64\" => |\nr, _ |\nr.get(| s, _ | Value ::\nNumber(s.downcast_ref :: < f64 > ().unwrap().to_f64().unwrap())),\n\"alloc::string::String\" => | r, c |\nr.get(| s, _ | Value ::\nString(c.create_string(s.downcast_ref :: < String > ().unwrap()).unwrap())),\n\"bevy_ecs::entity::Entity\" => | r, c |\n{\n    let usr = c.create_userdata(LuaEntity :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::vec2::Vec2\" => | r, c |\n{\n    let usr = c.create_userdata(LuaVec2 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::vec3::Vec3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaVec3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::sse2::vec4::Vec4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaVec4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::dvec2::DVec2\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDVec2 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::dvec3::DVec3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDVec3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::dvec4::DVec4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDVec4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::i32::ivec2::IVec2\" => | r, c |\n{\n    let usr = c.create_userdata(LuaIVec2 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::i32::ivec3::IVec3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaIVec3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::i32::ivec4::IVec4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaIVec4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::u32::uvec2::UVec2\" => | r, c |\n{\n    let usr = c.create_userdata(LuaUVec2 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::u32::uvec3::UVec3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaUVec3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::u32::uvec4::UVec4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaUVec4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::mat3::Mat3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaMat3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::sse2::mat4::Mat4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaMat4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::dmat3::DMat3\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDMat3 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::dmat4::DMat4\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDMat4 :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f32::sse2::quat::Quat\" => | r, c |\n{\n    let usr = c.create_userdata(LuaQuat :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::f64::dquat::DQuat\" => | r, c |\n{\n    let usr = c.create_userdata(LuaDQuat :: base_to_self(r)).unwrap() ; Value\n    :: UserData(usr)\n}, \"glam::euler::EulerRot\" => | r, c |\n{\n    let usr = c.create_userdata(LuaEulerRot :: base_to_self(r)).unwrap() ;\n    Value :: UserData(usr)\n}," , 0) . 1 , }
            phf::Map {
                key: 15467950696543387533u64,
                disps: &[
                    (0u32, 15u32),
                    (1u32, 31u32),
                    (12u32, 9u32),
                    (0u32, 23u32),
                    (26u32, 28u32),
                    (0u32, 1u32),
                    (0u32, 0u32),
                ],
                entries: &[
                    ("glam::f64::dvec3::DVec3", |r, c| {
                        let usr = c.create_userdata(LuaDVec3::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::i32::ivec4::IVec4", |r, c| {
                        let usr = c.create_userdata(LuaIVec4::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::i32::ivec3::IVec3", |r, c| {
                        let usr = c.create_userdata(LuaIVec3::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::f32::sse2::vec4::Vec4", |r, c| {
                        let usr = c.create_userdata(LuaVec4::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::i32::ivec2::IVec2", |r, c| {
                        let usr = c.create_userdata(LuaIVec2::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("i64", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<i64>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("i16", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<i16>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("u32", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<u32>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("glam::u32::uvec4::UVec4", |r, c| {
                        let usr = c.create_userdata(LuaUVec4::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::f32::mat3::Mat3", |r, c| {
                        let usr = c.create_userdata(LuaMat3::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::f64::dmat3::DMat3", |r, c| {
                        let usr = c.create_userdata(LuaDMat3::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("u64", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<u64>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("glam::f64::dvec2::DVec2", |r, c| {
                        let usr = c.create_userdata(LuaDVec2::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("i32", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<i32>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("u128", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<u128>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("glam::u32::uvec3::UVec3", |r, c| {
                        let usr = c.create_userdata(LuaUVec3::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::f32::vec2::Vec2", |r, c| {
                        let usr = c.create_userdata(LuaVec2::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("f64", |r, _| {
                        r.get(|s, _| {
                            Value::Number(s.downcast_ref::<f64>().unwrap().to_f64().unwrap())
                        })
                    }),
                    ("usize", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<usize>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("glam::euler::EulerRot", |r, c| {
                        let usr = c.create_userdata(LuaEulerRot::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("u8", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<u8>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("glam::f32::sse2::mat4::Mat4", |r, c| {
                        let usr = c.create_userdata(LuaMat4::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("i128", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<i128>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("glam::f64::dquat::DQuat", |r, c| {
                        let usr = c.create_userdata(LuaDQuat::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::f64::dmat4::DMat4", |r, c| {
                        let usr = c.create_userdata(LuaDMat4::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("f32", |r, _| {
                        r.get(|s, _| {
                            Value::Number(s.downcast_ref::<f32>().unwrap().to_f64().unwrap())
                        })
                    }),
                    ("isize", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<isize>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("i8", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<i8>().unwrap().to_i64().unwrap())
                        })
                    }),
                    ("glam::f32::vec3::Vec3", |r, c| {
                        let usr = c.create_userdata(LuaVec3::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("alloc::string::String", |r, c| {
                        r.get(|s, _| {
                            Value::String(
                                c.create_string(s.downcast_ref::<String>().unwrap())
                                    .unwrap(),
                            )
                        })
                    }),
                    ("bevy_ecs::entity::Entity", |r, c| {
                        let usr = c.create_userdata(LuaEntity::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::f32::sse2::quat::Quat", |r, c| {
                        let usr = c.create_userdata(LuaQuat::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::f64::dvec4::DVec4", |r, c| {
                        let usr = c.create_userdata(LuaDVec4::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("glam::u32::uvec2::UVec2", |r, c| {
                        let usr = c.create_userdata(LuaUVec2::base_to_self(r)).unwrap();
                        Value::UserData(usr)
                    }),
                    ("u16", |r, _| {
                        r.get(|s, _| {
                            Value::Integer(s.downcast_ref::<u16>().unwrap().to_i64().unwrap())
                        })
                    }),
                ],
            }
        };
        pub static APPLY_LUA_TO_BEVY: Map<
            &'static str,
            for<'l> fn(
                &mut crate::LuaRef,
                &'l Lua,
                tealr::mlu::mlua::Value<'l>,
            ) -> Result<(), tealr::mlu::mlua::Error>,
        > = {
            #[allow(dead_code)]
            enum ProcMacroHack {
                Value = ("\"usize\" => | r, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_usize().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with usize\".to_owned())) ?))), \"isize\" =>\n| r, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_isize().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with isize\".to_owned())) ?))), \"i128\" => |\nr, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i128().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i128\".to_owned())) ?))), \"i64\" => |\nr, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i64().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i64\".to_owned())) ?))), \"i32\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i32().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i32\".to_owned())) ?))), \"i16\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i16().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i16\".to_owned())) ?))), \"i8\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_i8().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with i8\".to_owned())) ?))), \"u128\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u128().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u128\".to_owned())) ?))), \"u64\" => |\nr, c, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u64().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u64\".to_owned())) ?))), \"u32\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u32().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u32\".to_owned())) ?))), \"u16\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u16().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u16\".to_owned())) ?))), \"u8\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_integer(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not an integer\".to_owned()))\n?.to_u8().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with u8\".to_owned())) ?))), \"f32\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_number(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not a number\".to_owned()))\n?.to_f32().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with f32\".to_owned())) ?))), \"f64\" => | r,\nc, v : Value |\nr.get_mut(| s, _ |\nOk(s.apply(& c.coerce_number(v)\n?.ok_or_else(| | Error :: RuntimeError(\"Not a number\".to_owned()))\n?.to_f64().ok_or_else(| | Error ::\nRuntimeError(\"Value not compatibile with f64\".to_owned())) ?))),\n\"alloc::string::String\" => | r, c, v : Value | c.coerce_string(v)\n?.ok_or_else(| | Error ::\nRuntimeError(\"Not a string\".to_owned())).and_then(| string |\nr.get_mut(| s, _ | Ok(s.apply(& string.to_str() ?.to_owned())))),\n\"bevy_ecs::entity::Entity\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaEntity > () ? ; LuaEntity ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::vec2::Vec2\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaVec2 > () ? ; LuaVec2 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::vec3::Vec3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaVec3 > () ? ; LuaVec3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::sse2::vec4::Vec4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaVec4 > () ? ; LuaVec4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::dvec2::DVec2\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDVec2 > () ? ; LuaDVec2 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::dvec3::DVec3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDVec3 > () ? ; LuaDVec3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::dvec4::DVec4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDVec4 > () ? ; LuaDVec4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::i32::ivec2::IVec2\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaIVec2 > () ? ; LuaIVec2 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::i32::ivec3::IVec3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaIVec3 > () ? ; LuaIVec3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::i32::ivec4::IVec4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaIVec4 > () ? ; LuaIVec4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::u32::uvec2::UVec2\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaUVec2 > () ? ; LuaUVec2 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::u32::uvec3::UVec3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaUVec3 > () ? ; LuaUVec3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::u32::uvec4::UVec4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaUVec4 > () ? ; LuaUVec4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::mat3::Mat3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaMat3 > () ? ; LuaMat3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::sse2::mat4::Mat4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaMat4 > () ? ; LuaMat4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::dmat3::DMat3\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDMat3 > () ? ; LuaDMat3 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::dmat4::DMat4\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDMat4 > () ? ; LuaDMat4 ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f32::sse2::quat::Quat\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaQuat > () ? ; LuaQuat ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::f64::dquat::DQuat\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaDQuat > () ? ; LuaDQuat ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}, \"glam::euler::EulerRot\" => | r, c, n |\n{\n    if let Value :: UserData(v) = n\n    {\n        let mut v = v.borrow_mut :: < LuaEulerRot > () ? ; LuaEulerRot ::\n        apply_self_to_base(v.deref_mut(), r) ; Ok(())\n    } else { Err(Error :: RuntimeError(\"Invalid type\".to_owned())) }\n}," , 0) . 1 , }
            phf::Map {
                key: 15467950696543387533u64,
                disps: &[
                    (0u32, 15u32),
                    (1u32, 31u32),
                    (12u32, 9u32),
                    (0u32, 23u32),
                    (26u32, 28u32),
                    (0u32, 1u32),
                    (0u32, 0u32),
                ],
                entries: &[
                    ("glam::f64::dvec3::DVec3", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaDVec3>()?;
                            LuaDVec3::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::i32::ivec4::IVec4", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaIVec4>()?;
                            LuaIVec4::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::i32::ivec3::IVec3", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaIVec3>()?;
                            LuaIVec3::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::f32::sse2::vec4::Vec4", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaVec4>()?;
                            LuaVec4::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::i32::ivec2::IVec2", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaIVec2>()?;
                            LuaIVec2::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("i64", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_i64()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with i64".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("i16", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_i16()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with i16".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("u32", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_u32()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with u32".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("glam::u32::uvec4::UVec4", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaUVec4>()?;
                            LuaUVec4::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::f32::mat3::Mat3", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaMat3>()?;
                            LuaMat3::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::f64::dmat3::DMat3", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaDMat3>()?;
                            LuaDMat3::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("u64", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_u64()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with u64".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("glam::f64::dvec2::DVec2", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaDVec2>()?;
                            LuaDVec2::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("i32", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_i32()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with i32".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("u128", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_u128()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with u128".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("glam::u32::uvec3::UVec3", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaUVec3>()?;
                            LuaUVec3::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::f32::vec2::Vec2", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaVec2>()?;
                            LuaVec2::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("f64", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_number(v)?
                                    .ok_or_else(|| Error::RuntimeError("Not a number".to_owned()))?
                                    .to_f64()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with f64".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("usize", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_usize()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with usize".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("glam::euler::EulerRot", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaEulerRot>()?;
                            LuaEulerRot::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("u8", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_u8()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with u8".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("glam::f32::sse2::mat4::Mat4", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaMat4>()?;
                            LuaMat4::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("i128", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_i128()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with i128".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("glam::f64::dquat::DQuat", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaDQuat>()?;
                            LuaDQuat::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::f64::dmat4::DMat4", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaDMat4>()?;
                            LuaDMat4::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("f32", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_number(v)?
                                    .ok_or_else(|| Error::RuntimeError("Not a number".to_owned()))?
                                    .to_f32()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with f32".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("isize", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_isize()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with isize".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("i8", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_i8()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with i8".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                    ("glam::f32::vec3::Vec3", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaVec3>()?;
                            LuaVec3::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("alloc::string::String", |r, c, v: Value| {
                        c.coerce_string(v)?
                            .ok_or_else(|| Error::RuntimeError("Not a string".to_owned()))
                            .and_then(|string| {
                                r.get_mut(|s, _| Ok(s.apply(&string.to_str()?.to_owned())))
                            })
                    }),
                    ("bevy_ecs::entity::Entity", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaEntity>()?;
                            LuaEntity::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::f32::sse2::quat::Quat", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaQuat>()?;
                            LuaQuat::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::f64::dvec4::DVec4", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaDVec4>()?;
                            LuaDVec4::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("glam::u32::uvec2::UVec2", |r, c, n| {
                        if let Value::UserData(v) = n {
                            let mut v = v.borrow_mut::<LuaUVec2>()?;
                            LuaUVec2::apply_self_to_base(v.deref_mut(), r);
                            Ok(())
                        } else {
                            Err(Error::RuntimeError("Invalid type".to_owned()))
                        }
                    }),
                    ("u16", |r, c, v: Value| {
                        r.get_mut(|s, _| {
                            Ok(s.apply(
                                &c.coerce_integer(v)?
                                    .ok_or_else(|| {
                                        Error::RuntimeError("Not an integer".to_owned())
                                    })?
                                    .to_u16()
                                    .ok_or_else(|| {
                                        Error::RuntimeError(
                                            "Value not compatibile with u16".to_owned(),
                                        )
                                    })?,
                            ))
                        })
                    }),
                ],
            }
        };
        #[allow(non_camel_case_types)]
        pub enum UnionLuaVec2 {
            LuaVec2(LuaVec2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaVec2 {
            #[inline]
            fn clone(&self) -> UnionLuaVec2 {
                match (&*self,) {
                    (&UnionLuaVec2::LuaVec2(ref __self_0),) => {
                        UnionLuaVec2::LuaVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec2 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaVec2::LuaVec2(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec2 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec2::LuaVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaVec2",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaVec2 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaVec2f32 {
            LuaVec2(LuaVec2),
            f32(f32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaVec2f32 {
            #[inline]
            fn clone(&self) -> UnionLuaVec2f32 {
                match (&*self,) {
                    (&UnionLuaVec2f32::LuaVec2(ref __self_0),) => {
                        UnionLuaVec2f32::LuaVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaVec2f32::f32(ref __self_0),) => {
                        UnionLuaVec2f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec2f32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaVec2f32::LuaVec2(x) => x.to_lua(lua),
                    UnionLuaVec2f32::f32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec2f32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec2f32::LuaVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec2f32::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaVec2 | f32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaVec2f32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf32LuaVec2 {
            f32(f32),
            LuaVec2(LuaVec2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf32LuaVec2 {
            #[inline]
            fn clone(&self) -> Unionf32LuaVec2 {
                match (&*self,) {
                    (&Unionf32LuaVec2::f32(ref __self_0),) => {
                        Unionf32LuaVec2::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf32LuaVec2::LuaVec2(ref __self_0),) => {
                        Unionf32LuaVec2::LuaVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaVec2 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf32LuaVec2::f32(x) => x.to_lua(lua),
                    Unionf32LuaVec2::LuaVec2(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaVec2 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaVec2::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaVec2::LuaVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f32 | LuaVec2",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf32LuaVec2 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaVec3 {
            LuaVec3(LuaVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaVec3 {
            #[inline]
            fn clone(&self) -> UnionLuaVec3 {
                match (&*self,) {
                    (&UnionLuaVec3::LuaVec3(ref __self_0),) => {
                        UnionLuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaVec3::LuaVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec3::LuaVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaVec3f32 {
            LuaVec3(LuaVec3),
            f32(f32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaVec3f32 {
            #[inline]
            fn clone(&self) -> UnionLuaVec3f32 {
                match (&*self,) {
                    (&UnionLuaVec3f32::LuaVec3(ref __self_0),) => {
                        UnionLuaVec3f32::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaVec3f32::f32(ref __self_0),) => {
                        UnionLuaVec3f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec3f32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaVec3f32::LuaVec3(x) => x.to_lua(lua),
                    UnionLuaVec3f32::f32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec3f32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec3f32::LuaVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec3f32::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaVec3 | f32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaVec3f32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf32LuaVec3 {
            f32(f32),
            LuaVec3(LuaVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf32LuaVec3 {
            #[inline]
            fn clone(&self) -> Unionf32LuaVec3 {
                match (&*self,) {
                    (&Unionf32LuaVec3::f32(ref __self_0),) => {
                        Unionf32LuaVec3::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf32LuaVec3::LuaVec3(ref __self_0),) => {
                        Unionf32LuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf32LuaVec3::f32(x) => x.to_lua(lua),
                    Unionf32LuaVec3::LuaVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaVec3::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaVec3::LuaVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f32 | LuaVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf32LuaVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaVec4 {
            LuaVec4(LuaVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaVec4 {
            #[inline]
            fn clone(&self) -> UnionLuaVec4 {
                match (&*self,) {
                    (&UnionLuaVec4::LuaVec4(ref __self_0),) => {
                        UnionLuaVec4::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaVec4::LuaVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec4::LuaVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaVec4f32 {
            LuaVec4(LuaVec4),
            f32(f32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaVec4f32 {
            #[inline]
            fn clone(&self) -> UnionLuaVec4f32 {
                match (&*self,) {
                    (&UnionLuaVec4f32::LuaVec4(ref __self_0),) => {
                        UnionLuaVec4f32::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaVec4f32::f32(ref __self_0),) => {
                        UnionLuaVec4f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaVec4f32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaVec4f32::LuaVec4(x) => x.to_lua(lua),
                    UnionLuaVec4f32::f32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaVec4f32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec4f32::LuaVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaVec4f32::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaVec4 | f32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaVec4f32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf32LuaVec4 {
            f32(f32),
            LuaVec4(LuaVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf32LuaVec4 {
            #[inline]
            fn clone(&self) -> Unionf32LuaVec4 {
                match (&*self,) {
                    (&Unionf32LuaVec4::f32(ref __self_0),) => {
                        Unionf32LuaVec4::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf32LuaVec4::LuaVec4(ref __self_0),) => {
                        Unionf32LuaVec4::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf32LuaVec4::f32(x) => x.to_lua(lua),
                    Unionf32LuaVec4::LuaVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaVec4::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaVec4::LuaVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f32 | LuaVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf32LuaVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDVec2 {
            LuaDVec2(LuaDVec2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDVec2 {
            #[inline]
            fn clone(&self) -> UnionLuaDVec2 {
                match (&*self,) {
                    (&UnionLuaDVec2::LuaDVec2(ref __self_0),) => {
                        UnionLuaDVec2::LuaDVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec2 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDVec2::LuaDVec2(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec2 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec2::LuaDVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDVec2",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDVec2 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDVec2f64 {
            LuaDVec2(LuaDVec2),
            f64(f64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDVec2f64 {
            #[inline]
            fn clone(&self) -> UnionLuaDVec2f64 {
                match (&*self,) {
                    (&UnionLuaDVec2f64::LuaDVec2(ref __self_0),) => {
                        UnionLuaDVec2f64::LuaDVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaDVec2f64::f64(ref __self_0),) => {
                        UnionLuaDVec2f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec2f64 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDVec2f64::LuaDVec2(x) => x.to_lua(lua),
                    UnionLuaDVec2f64::f64(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec2f64 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec2f64::LuaDVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec2f64::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDVec2 | f64",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDVec2f64 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf64LuaDVec2 {
            f64(f64),
            LuaDVec2(LuaDVec2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf64LuaDVec2 {
            #[inline]
            fn clone(&self) -> Unionf64LuaDVec2 {
                match (&*self,) {
                    (&Unionf64LuaDVec2::f64(ref __self_0),) => {
                        Unionf64LuaDVec2::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf64LuaDVec2::LuaDVec2(ref __self_0),) => {
                        Unionf64LuaDVec2::LuaDVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDVec2 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf64LuaDVec2::f64(x) => x.to_lua(lua),
                    Unionf64LuaDVec2::LuaDVec2(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDVec2 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDVec2::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDVec2::LuaDVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f64 | LuaDVec2",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf64LuaDVec2 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDVec3 {
            LuaDVec3(LuaDVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDVec3 {
            #[inline]
            fn clone(&self) -> UnionLuaDVec3 {
                match (&*self,) {
                    (&UnionLuaDVec3::LuaDVec3(ref __self_0),) => {
                        UnionLuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDVec3::LuaDVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec3::LuaDVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDVec3f64 {
            LuaDVec3(LuaDVec3),
            f64(f64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDVec3f64 {
            #[inline]
            fn clone(&self) -> UnionLuaDVec3f64 {
                match (&*self,) {
                    (&UnionLuaDVec3f64::LuaDVec3(ref __self_0),) => {
                        UnionLuaDVec3f64::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaDVec3f64::f64(ref __self_0),) => {
                        UnionLuaDVec3f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec3f64 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDVec3f64::LuaDVec3(x) => x.to_lua(lua),
                    UnionLuaDVec3f64::f64(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec3f64 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec3f64::LuaDVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec3f64::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDVec3 | f64",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDVec3f64 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf64LuaDVec3 {
            f64(f64),
            LuaDVec3(LuaDVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf64LuaDVec3 {
            #[inline]
            fn clone(&self) -> Unionf64LuaDVec3 {
                match (&*self,) {
                    (&Unionf64LuaDVec3::f64(ref __self_0),) => {
                        Unionf64LuaDVec3::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf64LuaDVec3::LuaDVec3(ref __self_0),) => {
                        Unionf64LuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf64LuaDVec3::f64(x) => x.to_lua(lua),
                    Unionf64LuaDVec3::LuaDVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDVec3::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDVec3::LuaDVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f64 | LuaDVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf64LuaDVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDVec4 {
            LuaDVec4(LuaDVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDVec4 {
            #[inline]
            fn clone(&self) -> UnionLuaDVec4 {
                match (&*self,) {
                    (&UnionLuaDVec4::LuaDVec4(ref __self_0),) => {
                        UnionLuaDVec4::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDVec4::LuaDVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec4::LuaDVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDVec4f64 {
            LuaDVec4(LuaDVec4),
            f64(f64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDVec4f64 {
            #[inline]
            fn clone(&self) -> UnionLuaDVec4f64 {
                match (&*self,) {
                    (&UnionLuaDVec4f64::LuaDVec4(ref __self_0),) => {
                        UnionLuaDVec4f64::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaDVec4f64::f64(ref __self_0),) => {
                        UnionLuaDVec4f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDVec4f64 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDVec4f64::LuaDVec4(x) => x.to_lua(lua),
                    UnionLuaDVec4f64::f64(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDVec4f64 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec4f64::LuaDVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDVec4f64::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDVec4 | f64",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDVec4f64 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf64LuaDVec4 {
            f64(f64),
            LuaDVec4(LuaDVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf64LuaDVec4 {
            #[inline]
            fn clone(&self) -> Unionf64LuaDVec4 {
                match (&*self,) {
                    (&Unionf64LuaDVec4::f64(ref __self_0),) => {
                        Unionf64LuaDVec4::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf64LuaDVec4::LuaDVec4(ref __self_0),) => {
                        Unionf64LuaDVec4::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf64LuaDVec4::f64(x) => x.to_lua(lua),
                    Unionf64LuaDVec4::LuaDVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDVec4::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDVec4::LuaDVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f64 | LuaDVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf64LuaDVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaIVec2 {
            LuaIVec2(LuaIVec2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaIVec2 {
            #[inline]
            fn clone(&self) -> UnionLuaIVec2 {
                match (&*self,) {
                    (&UnionLuaIVec2::LuaIVec2(ref __self_0),) => {
                        UnionLuaIVec2::LuaIVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec2 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaIVec2::LuaIVec2(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec2 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaIVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec2::LuaIVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaIVec2",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaIVec2 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaIVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaIVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaIVec2i32 {
            LuaIVec2(LuaIVec2),
            i32(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaIVec2i32 {
            #[inline]
            fn clone(&self) -> UnionLuaIVec2i32 {
                match (&*self,) {
                    (&UnionLuaIVec2i32::LuaIVec2(ref __self_0),) => {
                        UnionLuaIVec2i32::LuaIVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaIVec2i32::i32(ref __self_0),) => {
                        UnionLuaIVec2i32::i32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec2i32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaIVec2i32::LuaIVec2(x) => x.to_lua(lua),
                    UnionLuaIVec2i32::i32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec2i32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaIVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec2i32::LuaIVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match i32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec2i32::i32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaIVec2 | i32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaIVec2i32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaIVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut i32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaIVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((i32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unioni32LuaIVec2 {
            i32(i32),
            LuaIVec2(LuaIVec2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unioni32LuaIVec2 {
            #[inline]
            fn clone(&self) -> Unioni32LuaIVec2 {
                match (&*self,) {
                    (&Unioni32LuaIVec2::i32(ref __self_0),) => {
                        Unioni32LuaIVec2::i32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unioni32LuaIVec2::LuaIVec2(ref __self_0),) => {
                        Unioni32LuaIVec2::LuaIVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unioni32LuaIVec2 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unioni32LuaIVec2::i32(x) => x.to_lua(lua),
                    Unioni32LuaIVec2::LuaIVec2(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unioni32LuaIVec2 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match i32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unioni32LuaIVec2::i32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaIVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unioni32LuaIVec2::LuaIVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "i32 | LuaIVec2",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unioni32LuaIVec2 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut i32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaIVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((i32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaIVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaIVec3 {
            LuaIVec3(LuaIVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaIVec3 {
            #[inline]
            fn clone(&self) -> UnionLuaIVec3 {
                match (&*self,) {
                    (&UnionLuaIVec3::LuaIVec3(ref __self_0),) => {
                        UnionLuaIVec3::LuaIVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaIVec3::LuaIVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaIVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec3::LuaIVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaIVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaIVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaIVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaIVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaIVec3i32 {
            LuaIVec3(LuaIVec3),
            i32(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaIVec3i32 {
            #[inline]
            fn clone(&self) -> UnionLuaIVec3i32 {
                match (&*self,) {
                    (&UnionLuaIVec3i32::LuaIVec3(ref __self_0),) => {
                        UnionLuaIVec3i32::LuaIVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaIVec3i32::i32(ref __self_0),) => {
                        UnionLuaIVec3i32::i32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec3i32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaIVec3i32::LuaIVec3(x) => x.to_lua(lua),
                    UnionLuaIVec3i32::i32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec3i32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaIVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec3i32::LuaIVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match i32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec3i32::i32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaIVec3 | i32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaIVec3i32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaIVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut i32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaIVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((i32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unioni32LuaIVec3 {
            i32(i32),
            LuaIVec3(LuaIVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unioni32LuaIVec3 {
            #[inline]
            fn clone(&self) -> Unioni32LuaIVec3 {
                match (&*self,) {
                    (&Unioni32LuaIVec3::i32(ref __self_0),) => {
                        Unioni32LuaIVec3::i32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unioni32LuaIVec3::LuaIVec3(ref __self_0),) => {
                        Unioni32LuaIVec3::LuaIVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unioni32LuaIVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unioni32LuaIVec3::i32(x) => x.to_lua(lua),
                    Unioni32LuaIVec3::LuaIVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unioni32LuaIVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match i32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unioni32LuaIVec3::i32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaIVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unioni32LuaIVec3::LuaIVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "i32 | LuaIVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unioni32LuaIVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut i32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaIVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((i32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaIVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaIVec4 {
            LuaIVec4(LuaIVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaIVec4 {
            #[inline]
            fn clone(&self) -> UnionLuaIVec4 {
                match (&*self,) {
                    (&UnionLuaIVec4::LuaIVec4(ref __self_0),) => {
                        UnionLuaIVec4::LuaIVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaIVec4::LuaIVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaIVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec4::LuaIVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaIVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaIVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaIVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaIVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaIVec4i32 {
            LuaIVec4(LuaIVec4),
            i32(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaIVec4i32 {
            #[inline]
            fn clone(&self) -> UnionLuaIVec4i32 {
                match (&*self,) {
                    (&UnionLuaIVec4i32::LuaIVec4(ref __self_0),) => {
                        UnionLuaIVec4i32::LuaIVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaIVec4i32::i32(ref __self_0),) => {
                        UnionLuaIVec4i32::i32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaIVec4i32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaIVec4i32::LuaIVec4(x) => x.to_lua(lua),
                    UnionLuaIVec4i32::i32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaIVec4i32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaIVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec4i32::LuaIVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match i32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaIVec4i32::i32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaIVec4 | i32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaIVec4i32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaIVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut i32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaIVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((i32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unioni32LuaIVec4 {
            i32(i32),
            LuaIVec4(LuaIVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unioni32LuaIVec4 {
            #[inline]
            fn clone(&self) -> Unioni32LuaIVec4 {
                match (&*self,) {
                    (&Unioni32LuaIVec4::i32(ref __self_0),) => {
                        Unioni32LuaIVec4::i32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unioni32LuaIVec4::LuaIVec4(ref __self_0),) => {
                        Unioni32LuaIVec4::LuaIVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unioni32LuaIVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unioni32LuaIVec4::i32(x) => x.to_lua(lua),
                    Unioni32LuaIVec4::LuaIVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unioni32LuaIVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match i32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unioni32LuaIVec4::i32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaIVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unioni32LuaIVec4::LuaIVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "i32 | LuaIVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unioni32LuaIVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut i32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaIVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((i32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaIVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaUVec2 {
            LuaUVec2(LuaUVec2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaUVec2 {
            #[inline]
            fn clone(&self) -> UnionLuaUVec2 {
                match (&*self,) {
                    (&UnionLuaUVec2::LuaUVec2(ref __self_0),) => {
                        UnionLuaUVec2::LuaUVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec2 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaUVec2::LuaUVec2(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec2 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaUVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec2::LuaUVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaUVec2",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaUVec2 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaUVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaUVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaUVec2u32 {
            LuaUVec2(LuaUVec2),
            u32(u32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaUVec2u32 {
            #[inline]
            fn clone(&self) -> UnionLuaUVec2u32 {
                match (&*self,) {
                    (&UnionLuaUVec2u32::LuaUVec2(ref __self_0),) => {
                        UnionLuaUVec2u32::LuaUVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaUVec2u32::u32(ref __self_0),) => {
                        UnionLuaUVec2u32::u32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec2u32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaUVec2u32::LuaUVec2(x) => x.to_lua(lua),
                    UnionLuaUVec2u32::u32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec2u32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaUVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec2u32::LuaUVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match u32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec2u32::u32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaUVec2 | u32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaUVec2u32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaUVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut u32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaUVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((u32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionu32LuaUVec2 {
            u32(u32),
            LuaUVec2(LuaUVec2),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionu32LuaUVec2 {
            #[inline]
            fn clone(&self) -> Unionu32LuaUVec2 {
                match (&*self,) {
                    (&Unionu32LuaUVec2::u32(ref __self_0),) => {
                        Unionu32LuaUVec2::u32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionu32LuaUVec2::LuaUVec2(ref __self_0),) => {
                        Unionu32LuaUVec2::LuaUVec2(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionu32LuaUVec2 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionu32LuaUVec2::u32(x) => x.to_lua(lua),
                    Unionu32LuaUVec2::LuaUVec2(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionu32LuaUVec2 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match u32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionu32LuaUVec2::u32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaUVec2::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionu32LuaUVec2::LuaUVec2(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "u32 | LuaUVec2",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionu32LuaUVec2 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut u32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaUVec2::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((u32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaUVec2::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaUVec3 {
            LuaUVec3(LuaUVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaUVec3 {
            #[inline]
            fn clone(&self) -> UnionLuaUVec3 {
                match (&*self,) {
                    (&UnionLuaUVec3::LuaUVec3(ref __self_0),) => {
                        UnionLuaUVec3::LuaUVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaUVec3::LuaUVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaUVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec3::LuaUVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaUVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaUVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaUVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaUVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaUVec3u32 {
            LuaUVec3(LuaUVec3),
            u32(u32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaUVec3u32 {
            #[inline]
            fn clone(&self) -> UnionLuaUVec3u32 {
                match (&*self,) {
                    (&UnionLuaUVec3u32::LuaUVec3(ref __self_0),) => {
                        UnionLuaUVec3u32::LuaUVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaUVec3u32::u32(ref __self_0),) => {
                        UnionLuaUVec3u32::u32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec3u32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaUVec3u32::LuaUVec3(x) => x.to_lua(lua),
                    UnionLuaUVec3u32::u32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec3u32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaUVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec3u32::LuaUVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match u32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec3u32::u32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaUVec3 | u32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaUVec3u32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaUVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut u32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaUVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((u32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionu32LuaUVec3 {
            u32(u32),
            LuaUVec3(LuaUVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionu32LuaUVec3 {
            #[inline]
            fn clone(&self) -> Unionu32LuaUVec3 {
                match (&*self,) {
                    (&Unionu32LuaUVec3::u32(ref __self_0),) => {
                        Unionu32LuaUVec3::u32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionu32LuaUVec3::LuaUVec3(ref __self_0),) => {
                        Unionu32LuaUVec3::LuaUVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionu32LuaUVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionu32LuaUVec3::u32(x) => x.to_lua(lua),
                    Unionu32LuaUVec3::LuaUVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionu32LuaUVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match u32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionu32LuaUVec3::u32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaUVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionu32LuaUVec3::LuaUVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "u32 | LuaUVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionu32LuaUVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut u32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaUVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((u32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaUVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaUVec4 {
            LuaUVec4(LuaUVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaUVec4 {
            #[inline]
            fn clone(&self) -> UnionLuaUVec4 {
                match (&*self,) {
                    (&UnionLuaUVec4::LuaUVec4(ref __self_0),) => {
                        UnionLuaUVec4::LuaUVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaUVec4::LuaUVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaUVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec4::LuaUVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaUVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaUVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaUVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaUVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaUVec4u32 {
            LuaUVec4(LuaUVec4),
            u32(u32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaUVec4u32 {
            #[inline]
            fn clone(&self) -> UnionLuaUVec4u32 {
                match (&*self,) {
                    (&UnionLuaUVec4u32::LuaUVec4(ref __self_0),) => {
                        UnionLuaUVec4u32::LuaUVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaUVec4u32::u32(ref __self_0),) => {
                        UnionLuaUVec4u32::u32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaUVec4u32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaUVec4u32::LuaUVec4(x) => x.to_lua(lua),
                    UnionLuaUVec4u32::u32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaUVec4u32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaUVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec4u32::LuaUVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match u32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaUVec4u32::u32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaUVec4 | u32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaUVec4u32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaUVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut u32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaUVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((u32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionu32LuaUVec4 {
            u32(u32),
            LuaUVec4(LuaUVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionu32LuaUVec4 {
            #[inline]
            fn clone(&self) -> Unionu32LuaUVec4 {
                match (&*self,) {
                    (&Unionu32LuaUVec4::u32(ref __self_0),) => {
                        Unionu32LuaUVec4::u32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionu32LuaUVec4::LuaUVec4(ref __self_0),) => {
                        Unionu32LuaUVec4::LuaUVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionu32LuaUVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionu32LuaUVec4::u32(x) => x.to_lua(lua),
                    Unionu32LuaUVec4::LuaUVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionu32LuaUVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match u32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionu32LuaUVec4::u32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaUVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionu32LuaUVec4::LuaUVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "u32 | LuaUVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionu32LuaUVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut u32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaUVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((u32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaUVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaMat3 {
            LuaMat3(LuaMat3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaMat3 {
            #[inline]
            fn clone(&self) -> UnionLuaMat3 {
                match (&*self,) {
                    (&UnionLuaMat3::LuaMat3(ref __self_0),) => {
                        UnionLuaMat3::LuaMat3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaMat3::LuaMat3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaMat3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat3::LuaMat3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaMat3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaMat3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaMat3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaMat3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaMat3LuaVec3 {
            LuaMat3(LuaMat3),
            LuaVec3(LuaVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaMat3LuaVec3 {
            #[inline]
            fn clone(&self) -> UnionLuaMat3LuaVec3 {
                match (&*self,) {
                    (&UnionLuaMat3LuaVec3::LuaMat3(ref __self_0),) => {
                        UnionLuaMat3LuaVec3::LuaMat3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaMat3LuaVec3::LuaVec3(ref __self_0),) => {
                        UnionLuaMat3LuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat3LuaVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaMat3LuaVec3::LuaMat3(x) => x.to_lua(lua),
                    UnionLuaMat3LuaVec3::LuaVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat3LuaVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaMat3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat3LuaVec3::LuaMat3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat3LuaVec3::LuaVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaMat3 | LuaVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaMat3LuaVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaMat3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaMat3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaMat3LuaVec3f32 {
            LuaMat3(LuaMat3),
            LuaVec3(LuaVec3),
            f32(f32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaMat3LuaVec3f32 {
            #[inline]
            fn clone(&self) -> UnionLuaMat3LuaVec3f32 {
                match (&*self,) {
                    (&UnionLuaMat3LuaVec3f32::LuaMat3(ref __self_0),) => {
                        UnionLuaMat3LuaVec3f32::LuaMat3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaMat3LuaVec3f32::LuaVec3(ref __self_0),) => {
                        UnionLuaMat3LuaVec3f32::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaMat3LuaVec3f32::f32(ref __self_0),) => {
                        UnionLuaMat3LuaVec3f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat3LuaVec3f32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaMat3LuaVec3f32::LuaMat3(x) => x.to_lua(lua),
                    UnionLuaMat3LuaVec3f32::LuaVec3(x) => x.to_lua(lua),
                    UnionLuaMat3LuaVec3f32::f32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat3LuaVec3f32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaMat3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat3LuaVec3f32::LuaMat3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat3LuaVec3f32::LuaVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat3LuaVec3f32::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaMat3 | LuaVec3 | f32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaMat3LuaVec3f32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaMat3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaMat3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf32LuaMat3 {
            f32(f32),
            LuaMat3(LuaMat3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf32LuaMat3 {
            #[inline]
            fn clone(&self) -> Unionf32LuaMat3 {
                match (&*self,) {
                    (&Unionf32LuaMat3::f32(ref __self_0),) => {
                        Unionf32LuaMat3::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf32LuaMat3::LuaMat3(ref __self_0),) => {
                        Unionf32LuaMat3::LuaMat3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaMat3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf32LuaMat3::f32(x) => x.to_lua(lua),
                    Unionf32LuaMat3::LuaMat3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaMat3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaMat3::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaMat3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaMat3::LuaMat3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f32 | LuaMat3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf32LuaMat3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaMat3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaMat3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaMat4 {
            LuaMat4(LuaMat4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaMat4 {
            #[inline]
            fn clone(&self) -> UnionLuaMat4 {
                match (&*self,) {
                    (&UnionLuaMat4::LuaMat4(ref __self_0),) => {
                        UnionLuaMat4::LuaMat4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaMat4::LuaMat4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaMat4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat4::LuaMat4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaMat4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaMat4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaMat4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaMat4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaMat4LuaVec4 {
            LuaMat4(LuaMat4),
            LuaVec4(LuaVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaMat4LuaVec4 {
            #[inline]
            fn clone(&self) -> UnionLuaMat4LuaVec4 {
                match (&*self,) {
                    (&UnionLuaMat4LuaVec4::LuaMat4(ref __self_0),) => {
                        UnionLuaMat4LuaVec4::LuaMat4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaMat4LuaVec4::LuaVec4(ref __self_0),) => {
                        UnionLuaMat4LuaVec4::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat4LuaVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaMat4LuaVec4::LuaMat4(x) => x.to_lua(lua),
                    UnionLuaMat4LuaVec4::LuaVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat4LuaVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaMat4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat4LuaVec4::LuaMat4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat4LuaVec4::LuaVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaMat4 | LuaVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaMat4LuaVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaMat4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaMat4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaMat4LuaVec4f32 {
            LuaMat4(LuaMat4),
            LuaVec4(LuaVec4),
            f32(f32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaMat4LuaVec4f32 {
            #[inline]
            fn clone(&self) -> UnionLuaMat4LuaVec4f32 {
                match (&*self,) {
                    (&UnionLuaMat4LuaVec4f32::LuaMat4(ref __self_0),) => {
                        UnionLuaMat4LuaVec4f32::LuaMat4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaMat4LuaVec4f32::LuaVec4(ref __self_0),) => {
                        UnionLuaMat4LuaVec4f32::LuaVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaMat4LuaVec4f32::f32(ref __self_0),) => {
                        UnionLuaMat4LuaVec4f32::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaMat4LuaVec4f32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaMat4LuaVec4f32::LuaMat4(x) => x.to_lua(lua),
                    UnionLuaMat4LuaVec4f32::LuaVec4(x) => x.to_lua(lua),
                    UnionLuaMat4LuaVec4f32::f32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaMat4LuaVec4f32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaMat4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat4LuaVec4f32::LuaMat4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat4LuaVec4f32::LuaVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaMat4LuaVec4f32::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaMat4 | LuaVec4 | f32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaMat4LuaVec4f32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaMat4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaMat4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf32LuaMat4 {
            f32(f32),
            LuaMat4(LuaMat4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf32LuaMat4 {
            #[inline]
            fn clone(&self) -> Unionf32LuaMat4 {
                match (&*self,) {
                    (&Unionf32LuaMat4::f32(ref __self_0),) => {
                        Unionf32LuaMat4::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf32LuaMat4::LuaMat4(ref __self_0),) => {
                        Unionf32LuaMat4::LuaMat4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaMat4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf32LuaMat4::f32(x) => x.to_lua(lua),
                    Unionf32LuaMat4::LuaMat4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaMat4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaMat4::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaMat4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaMat4::LuaMat4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f32 | LuaMat4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf32LuaMat4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaMat4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaMat4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDMat3 {
            LuaDMat3(LuaDMat3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDMat3 {
            #[inline]
            fn clone(&self) -> UnionLuaDMat3 {
                match (&*self,) {
                    (&UnionLuaDMat3::LuaDMat3(ref __self_0),) => {
                        UnionLuaDMat3::LuaDMat3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDMat3::LuaDMat3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDMat3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat3::LuaDMat3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDMat3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDMat3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDMat3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDMat3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDMat3LuaDVec3 {
            LuaDMat3(LuaDMat3),
            LuaDVec3(LuaDVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDMat3LuaDVec3 {
            #[inline]
            fn clone(&self) -> UnionLuaDMat3LuaDVec3 {
                match (&*self,) {
                    (&UnionLuaDMat3LuaDVec3::LuaDMat3(ref __self_0),) => {
                        UnionLuaDMat3LuaDVec3::LuaDMat3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaDMat3LuaDVec3::LuaDVec3(ref __self_0),) => {
                        UnionLuaDMat3LuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat3LuaDVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDMat3LuaDVec3::LuaDMat3(x) => x.to_lua(lua),
                    UnionLuaDMat3LuaDVec3::LuaDVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat3LuaDVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDMat3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat3LuaDVec3::LuaDMat3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat3LuaDVec3::LuaDVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDMat3 | LuaDVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDMat3LuaDVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDMat3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDMat3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDMat3LuaDVec3f64 {
            LuaDMat3(LuaDMat3),
            LuaDVec3(LuaDVec3),
            f64(f64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDMat3LuaDVec3f64 {
            #[inline]
            fn clone(&self) -> UnionLuaDMat3LuaDVec3f64 {
                match (&*self,) {
                    (&UnionLuaDMat3LuaDVec3f64::LuaDMat3(ref __self_0),) => {
                        UnionLuaDMat3LuaDVec3f64::LuaDMat3(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&UnionLuaDMat3LuaDVec3f64::LuaDVec3(ref __self_0),) => {
                        UnionLuaDMat3LuaDVec3f64::LuaDVec3(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&UnionLuaDMat3LuaDVec3f64::f64(ref __self_0),) => {
                        UnionLuaDMat3LuaDVec3f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat3LuaDVec3f64 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDMat3LuaDVec3f64::LuaDMat3(x) => x.to_lua(lua),
                    UnionLuaDMat3LuaDVec3f64::LuaDVec3(x) => x.to_lua(lua),
                    UnionLuaDMat3LuaDVec3f64::f64(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat3LuaDVec3f64 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDMat3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat3LuaDVec3f64::LuaDMat3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat3LuaDVec3f64::LuaDVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat3LuaDVec3f64::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDMat3 | LuaDVec3 | f64",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDMat3LuaDVec3f64 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDMat3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDMat3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf64LuaDMat3 {
            f64(f64),
            LuaDMat3(LuaDMat3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf64LuaDMat3 {
            #[inline]
            fn clone(&self) -> Unionf64LuaDMat3 {
                match (&*self,) {
                    (&Unionf64LuaDMat3::f64(ref __self_0),) => {
                        Unionf64LuaDMat3::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf64LuaDMat3::LuaDMat3(ref __self_0),) => {
                        Unionf64LuaDMat3::LuaDMat3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDMat3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf64LuaDMat3::f64(x) => x.to_lua(lua),
                    Unionf64LuaDMat3::LuaDMat3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDMat3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDMat3::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDMat3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDMat3::LuaDMat3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f64 | LuaDMat3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf64LuaDMat3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDMat3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDMat3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDMat4 {
            LuaDMat4(LuaDMat4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDMat4 {
            #[inline]
            fn clone(&self) -> UnionLuaDMat4 {
                match (&*self,) {
                    (&UnionLuaDMat4::LuaDMat4(ref __self_0),) => {
                        UnionLuaDMat4::LuaDMat4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDMat4::LuaDMat4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDMat4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat4::LuaDMat4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDMat4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDMat4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDMat4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDMat4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDMat4LuaDVec4 {
            LuaDMat4(LuaDMat4),
            LuaDVec4(LuaDVec4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDMat4LuaDVec4 {
            #[inline]
            fn clone(&self) -> UnionLuaDMat4LuaDVec4 {
                match (&*self,) {
                    (&UnionLuaDMat4LuaDVec4::LuaDMat4(ref __self_0),) => {
                        UnionLuaDMat4LuaDVec4::LuaDMat4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaDMat4LuaDVec4::LuaDVec4(ref __self_0),) => {
                        UnionLuaDMat4LuaDVec4::LuaDVec4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat4LuaDVec4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDMat4LuaDVec4::LuaDMat4(x) => x.to_lua(lua),
                    UnionLuaDMat4LuaDVec4::LuaDVec4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat4LuaDVec4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDMat4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat4LuaDVec4::LuaDMat4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat4LuaDVec4::LuaDVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDMat4 | LuaDVec4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDMat4LuaDVec4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDMat4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDMat4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDMat4LuaDVec4f64 {
            LuaDMat4(LuaDMat4),
            LuaDVec4(LuaDVec4),
            f64(f64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDMat4LuaDVec4f64 {
            #[inline]
            fn clone(&self) -> UnionLuaDMat4LuaDVec4f64 {
                match (&*self,) {
                    (&UnionLuaDMat4LuaDVec4f64::LuaDMat4(ref __self_0),) => {
                        UnionLuaDMat4LuaDVec4f64::LuaDMat4(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&UnionLuaDMat4LuaDVec4f64::LuaDVec4(ref __self_0),) => {
                        UnionLuaDMat4LuaDVec4f64::LuaDVec4(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&UnionLuaDMat4LuaDVec4f64::f64(ref __self_0),) => {
                        UnionLuaDMat4LuaDVec4f64::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDMat4LuaDVec4f64 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDMat4LuaDVec4f64::LuaDMat4(x) => x.to_lua(lua),
                    UnionLuaDMat4LuaDVec4f64::LuaDVec4(x) => x.to_lua(lua),
                    UnionLuaDMat4LuaDVec4f64::f64(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDMat4LuaDVec4f64 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDMat4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat4LuaDVec4f64::LuaDMat4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat4LuaDVec4f64::LuaDVec4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDMat4LuaDVec4f64::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDMat4 | LuaDVec4 | f64",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDMat4LuaDVec4f64 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDMat4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDMat4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf64LuaDMat4 {
            f64(f64),
            LuaDMat4(LuaDMat4),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf64LuaDMat4 {
            #[inline]
            fn clone(&self) -> Unionf64LuaDMat4 {
                match (&*self,) {
                    (&Unionf64LuaDMat4::f64(ref __self_0),) => {
                        Unionf64LuaDMat4::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf64LuaDMat4::LuaDMat4(ref __self_0),) => {
                        Unionf64LuaDMat4::LuaDMat4(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDMat4 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf64LuaDMat4::f64(x) => x.to_lua(lua),
                    Unionf64LuaDMat4::LuaDMat4(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDMat4 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDMat4::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDMat4::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDMat4::LuaDMat4(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f64 | LuaDMat4",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf64LuaDMat4 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDMat4::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDMat4::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaQuat {
            LuaQuat(LuaQuat),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaQuat {
            #[inline]
            fn clone(&self) -> UnionLuaQuat {
                match (&*self,) {
                    (&UnionLuaQuat::LuaQuat(ref __self_0),) => {
                        UnionLuaQuat::LuaQuat(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaQuat {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaQuat::LuaQuat(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaQuat {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaQuat::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaQuat::LuaQuat(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaQuat",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaQuat {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaQuat::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaQuat::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf32 {
            f32(f32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf32 {
            #[inline]
            fn clone(&self) -> Unionf32 {
                match (&*self,) {
                    (&Unionf32::f32(ref __self_0),) => {
                        Unionf32::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf32::f32(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f32",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf32 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaQuatLuaVec3 {
            LuaQuat(LuaQuat),
            LuaVec3(LuaVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaQuatLuaVec3 {
            #[inline]
            fn clone(&self) -> UnionLuaQuatLuaVec3 {
                match (&*self,) {
                    (&UnionLuaQuatLuaVec3::LuaQuat(ref __self_0),) => {
                        UnionLuaQuatLuaVec3::LuaQuat(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaQuatLuaVec3::LuaVec3(ref __self_0),) => {
                        UnionLuaQuatLuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaQuatLuaVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaQuatLuaVec3::LuaQuat(x) => x.to_lua(lua),
                    UnionLuaQuatLuaVec3::LuaVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaQuatLuaVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaQuat::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaQuatLuaVec3::LuaQuat(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaQuatLuaVec3::LuaVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaQuat | LuaVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaQuatLuaVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaQuat::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaQuat::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf32LuaQuatLuaVec3 {
            f32(f32),
            LuaQuat(LuaQuat),
            LuaVec3(LuaVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf32LuaQuatLuaVec3 {
            #[inline]
            fn clone(&self) -> Unionf32LuaQuatLuaVec3 {
                match (&*self,) {
                    (&Unionf32LuaQuatLuaVec3::f32(ref __self_0),) => {
                        Unionf32LuaQuatLuaVec3::f32(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf32LuaQuatLuaVec3::LuaQuat(ref __self_0),) => {
                        Unionf32LuaQuatLuaVec3::LuaQuat(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf32LuaQuatLuaVec3::LuaVec3(ref __self_0),) => {
                        Unionf32LuaQuatLuaVec3::LuaVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf32LuaQuatLuaVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf32LuaQuatLuaVec3::f32(x) => x.to_lua(lua),
                    Unionf32LuaQuatLuaVec3::LuaQuat(x) => x.to_lua(lua),
                    Unionf32LuaQuatLuaVec3::LuaVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf32LuaQuatLuaVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f32::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaQuatLuaVec3::f32(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaQuat::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaQuatLuaVec3::LuaQuat(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf32LuaQuatLuaVec3::LuaVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f32 | LuaQuat | LuaVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf32LuaQuatLuaVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f32::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaQuat::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f32::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaQuat::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDQuat {
            LuaDQuat(LuaDQuat),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDQuat {
            #[inline]
            fn clone(&self) -> UnionLuaDQuat {
                match (&*self,) {
                    (&UnionLuaDQuat::LuaDQuat(ref __self_0),) => {
                        UnionLuaDQuat::LuaDQuat(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDQuat {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDQuat::LuaDQuat(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDQuat {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDQuat::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDQuat::LuaDQuat(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDQuat",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDQuat {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDQuat::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDQuat::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf64 {
            f64(f64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf64 {
            #[inline]
            fn clone(&self) -> Unionf64 {
                match (&*self,) {
                    (&Unionf64::f64(ref __self_0),) => {
                        Unionf64::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf64::f64(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f64",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf64 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum UnionLuaDQuatLuaDVec3 {
            LuaDQuat(LuaDQuat),
            LuaDVec3(LuaDVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for UnionLuaDQuatLuaDVec3 {
            #[inline]
            fn clone(&self) -> UnionLuaDQuatLuaDVec3 {
                match (&*self,) {
                    (&UnionLuaDQuatLuaDVec3::LuaDQuat(ref __self_0),) => {
                        UnionLuaDQuatLuaDVec3::LuaDQuat(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&UnionLuaDQuatLuaDVec3::LuaDVec3(ref __self_0),) => {
                        UnionLuaDQuatLuaDVec3::LuaDVec3(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for UnionLuaDQuatLuaDVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    UnionLuaDQuatLuaDVec3::LuaDQuat(x) => x.to_lua(lua),
                    UnionLuaDQuatLuaDVec3::LuaDVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for UnionLuaDQuatLuaDVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match LuaDQuat::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDQuatLuaDVec3::LuaDQuat(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(UnionLuaDQuatLuaDVec3::LuaDVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "LuaDQuat | LuaDVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for UnionLuaDQuatLuaDVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut LuaDQuat::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((LuaDQuat::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
        #[allow(non_camel_case_types)]
        pub enum Unionf64LuaDQuatLuaDVec3 {
            f64(f64),
            LuaDQuat(LuaDQuat),
            LuaDVec3(LuaDVec3),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for Unionf64LuaDQuatLuaDVec3 {
            #[inline]
            fn clone(&self) -> Unionf64LuaDQuatLuaDVec3 {
                match (&*self,) {
                    (&Unionf64LuaDQuatLuaDVec3::f64(ref __self_0),) => {
                        Unionf64LuaDQuatLuaDVec3::f64(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Unionf64LuaDQuatLuaDVec3::LuaDQuat(ref __self_0),) => {
                        Unionf64LuaDQuatLuaDVec3::LuaDQuat(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&Unionf64LuaDQuatLuaDVec3::LuaDVec3(ref __self_0),) => {
                        Unionf64LuaDQuatLuaDVec3::LuaDVec3(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::ToLua<'lua> for Unionf64LuaDQuatLuaDVec3 {
            fn to_lua(
                self,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<::tealr::mlu::mlua::Value<'lua>, ::tealr::mlu::mlua::Error>
            {
                match self {
                    Unionf64LuaDQuatLuaDVec3::f64(x) => x.to_lua(lua),
                    Unionf64LuaDQuatLuaDVec3::LuaDQuat(x) => x.to_lua(lua),
                    Unionf64LuaDQuatLuaDVec3::LuaDVec3(x) => x.to_lua(lua),
                }
            }
        }
        impl<'lua> ::tealr::mlu::mlua::FromLua<'lua> for Unionf64LuaDQuatLuaDVec3 {
            fn from_lua(
                value: ::tealr::mlu::mlua::Value<'lua>,
                lua: &'lua ::tealr::mlu::mlua::Lua,
            ) -> ::std::result::Result<Self, ::tealr::mlu::mlua::Error> {
                match f64::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDQuatLuaDVec3::f64(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDQuat::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDQuatLuaDVec3::LuaDQuat(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                match LuaDVec3::from_lua(value.clone(), lua) {
                    Ok(x) => return Ok(Unionf64LuaDQuatLuaDVec3::LuaDVec3(x)),
                    Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                        from: _,
                        to: _,
                        message: _,
                    }) => {}
                    Err(x) => return Err(x),
                };
                Err(::tealr::mlu::mlua::Error::FromLuaConversionError {
                    to: "f64 | LuaDQuat | LuaDVec3",
                    from: value.type_name(),
                    message: None,
                })
            }
        }
        impl ::tealr::TypeName for Unionf64LuaDQuatLuaDVec3 {
            fn get_type_parts() -> ::std::borrow::Cow<'static, [::tealr::NamePart]> {
                let mut name = Vec::new();
                name.append(&mut f64::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDQuat::get_type_parts().to_vec());
                name.push(" | ".into());
                name.append(&mut LuaDVec3::get_type_parts().to_vec());
                name.push(" | ".into());
                name.pop();
                std::borrow::Cow::Owned(name)
            }
            fn collect_children(v: &mut Vec<::tealr::TealType>) {
                use ::tealr::TealMultiValue;
                v.extend((f64::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDQuat::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
                v.extend((LuaDVec3::get_types().into_iter()).filter_map(|v| {
                    if let ::tealr::NamePart::Type(x) = v {
                        Some(x)
                    } else {
                        None
                    }
                }));
            }
            fn get_type_kind() -> ::tealr::KindOfType {
                ::tealr::KindOfType::Builtin
            }
        }
    }
}
